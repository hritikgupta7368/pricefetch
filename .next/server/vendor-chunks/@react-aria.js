"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-aria";
exports.ids = ["vendor-chunks/@react-aria"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-aria/focus/dist/import.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@react-aria/focus/dist/import.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FocusRing: () => (/* binding */ $907718708eab68af$export$1a38b4ad7f578e1d),\n/* harmony export */   FocusScope: () => (/* binding */ $9bf71ea28793e738$export$20e40289641fbbb6),\n/* harmony export */   FocusableProvider: () => (/* binding */ $e6afbd83fe6ebbd2$export$13f3202a3e5ddd5),\n/* harmony export */   createFocusManager: () => (/* binding */ $9bf71ea28793e738$export$c5251b9e124bf29),\n/* harmony export */   focusSafely: () => (/* binding */ $6a99195332edec8b$export$80f3e147d781571c),\n/* harmony export */   getFocusableTreeWalker: () => (/* binding */ $9bf71ea28793e738$export$2d6ec8fc375ceafa),\n/* harmony export */   isElementInChildOfActiveScope: () => (/* binding */ $9bf71ea28793e738$export$1258395f99bf9cbf),\n/* harmony export */   useFocusManager: () => (/* binding */ $9bf71ea28793e738$export$10c5169755ce7bd7),\n/* harmony export */   useFocusRing: () => (/* binding */ $f7dceffc5ad7768b$export$4e328f61c538687f),\n/* harmony export */   useFocusable: () => (/* binding */ $e6afbd83fe6ebbd2$export$4c014de7c8940b4c),\n/* harmony export */   useHasTabbableChild: () => (/* binding */ $83013635b024ae3d$export$eac1895992b9f3d6)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/./node_modules/@react-aria/utils/dist/import.mjs\");\n/* harmony import */ var _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/interactions */ \"(ssr)/./node_modules/@react-aria/interactions/dist/import.mjs\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.m.js\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $6a99195332edec8b$export$80f3e147d781571c(element) {\n    // If the user is interacting with a virtual cursor, e.g. screen reader, then\n    // wait until after any animated transitions that are currently occurring on\n    // the page before shifting focus. This avoids issues with VoiceOver on iOS\n    // causing the page to scroll when moving focus if the element is transitioning\n    // from off the screen.\n    if ((0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__.getInteractionModality)() === \"virtual\") {\n        let lastFocusedElement = document.activeElement;\n        (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.runAfterTransition)(()=>{\n            // If focus did not move and the element is still in the document, focus it.\n            if (document.activeElement === lastFocusedElement && document.contains(element)) (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.focusWithoutScrolling)(element);\n        });\n    } else (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.focusWithoutScrolling)(element);\n}\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $645f2e67b85a24c9$var$isStyleVisible(element) {\n    if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) return false;\n    let { display: display, visibility: visibility } = element.style;\n    let isVisible = display !== \"none\" && visibility !== \"hidden\" && visibility !== \"collapse\";\n    if (isVisible) {\n        const { getComputedStyle: getComputedStyle } = element.ownerDocument.defaultView;\n        let { display: computedDisplay, visibility: computedVisibility } = getComputedStyle(element);\n        isVisible = computedDisplay !== \"none\" && computedVisibility !== \"hidden\" && computedVisibility !== \"collapse\";\n    }\n    return isVisible;\n}\nfunction $645f2e67b85a24c9$var$isAttributeVisible(element, childElement) {\n    return !element.hasAttribute(\"hidden\") && (element.nodeName === \"DETAILS\" && childElement && childElement.nodeName !== \"SUMMARY\" ? element.hasAttribute(\"open\") : true);\n}\nfunction $645f2e67b85a24c9$export$e989c0fffaa6b27a(element, childElement) {\n    return element.nodeName !== \"#comment\" && $645f2e67b85a24c9$var$isStyleVisible(element) && $645f2e67b85a24c9$var$isAttributeVisible(element, childElement) && (!element.parentElement || $645f2e67b85a24c9$export$e989c0fffaa6b27a(element.parentElement, element));\n}\nconst $9bf71ea28793e738$var$FocusContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext(null);\nlet $9bf71ea28793e738$var$activeScope = null;\nfunction $9bf71ea28793e738$export$20e40289641fbbb6(props) {\n    let { children: children, contain: contain, restoreFocus: restoreFocus, autoFocus: autoFocus } = props;\n    let startRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let endRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let scopeRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    let { parentNode: parentNode } = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($9bf71ea28793e738$var$FocusContext) || {};\n    // Create a tree node here so we can add children to it even before it is added to the tree.\n    let node = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new $9bf71ea28793e738$var$TreeNode({\n            scopeRef: scopeRef\n        }), [\n        scopeRef\n    ]);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),\n        // use the active scope as the parent instead of the parent from context. Layout effects run bottom\n        // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope\n        // that is being added should get the activeScope as its parent.\n        let parent = parentNode || $9bf71ea28793e738$export$d06fae2ee68b101e.root;\n        if ($9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(parent.scopeRef) && $9bf71ea28793e738$var$activeScope && !$9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, parent.scopeRef)) {\n            let activeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);\n            if (activeNode) parent = activeNode;\n        }\n        // Add the node to the parent, and to the tree.\n        parent.addChild(node);\n        $9bf71ea28793e738$export$d06fae2ee68b101e.addNode(node);\n    }, [\n        node,\n        parentNode\n    ]);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        let node = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n        if (node) node.contain = !!contain;\n    }, [\n        contain\n    ]);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        var _startRef_current;\n        // Find all rendered nodes between the sentinels and add them to the scope.\n        let node = (_startRef_current = startRef.current) === null || _startRef_current === void 0 ? void 0 : _startRef_current.nextSibling;\n        let nodes = [];\n        while(node && node !== endRef.current){\n            nodes.push(node);\n            node = node.nextSibling;\n        }\n        scopeRef.current = nodes;\n    }, [\n        children\n    ]);\n    $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restoreFocus, contain);\n    $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain);\n    $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain);\n    $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus);\n    // This needs to be an effect so that activeScope is updated after the FocusScope tree is complete.\n    // It cannot be a useLayoutEffect because the parent of this node hasn't been attached in the tree yet.\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let activeElement = document.activeElement;\n        let scope = null;\n        if ($9bf71ea28793e738$var$isElementInScope(activeElement, scopeRef.current)) {\n            // We need to traverse the focusScope tree and find the bottom most scope that\n            // contains the active element and set that as the activeScope.\n            for (let node of $9bf71ea28793e738$export$d06fae2ee68b101e.traverse())if (node.scopeRef && $9bf71ea28793e738$var$isElementInScope(activeElement, node.scopeRef.current)) scope = node;\n            if (scope === $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef)) $9bf71ea28793e738$var$activeScope = scope.scopeRef;\n        }\n    }, [\n        scopeRef\n    ]);\n    // This layout effect cleanup is so that the tree node is removed synchronously with react before the RAF\n    // in useRestoreFocus cleanup runs.\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        return ()=>{\n            var _focusScopeTree_getTreeNode_parent, _focusScopeTree_getTreeNode;\n            var _focusScopeTree_getTreeNode_parent_scopeRef;\n            // Scope may have been re-parented.\n            let parentScope = (_focusScopeTree_getTreeNode_parent_scopeRef = (_focusScopeTree_getTreeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : (_focusScopeTree_getTreeNode_parent = _focusScopeTree_getTreeNode.parent) === null || _focusScopeTree_getTreeNode_parent === void 0 ? void 0 : _focusScopeTree_getTreeNode_parent.scopeRef) !== null && _focusScopeTree_getTreeNode_parent_scopeRef !== void 0 ? _focusScopeTree_getTreeNode_parent_scopeRef : null;\n            if ((scopeRef === $9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope(scopeRef, $9bf71ea28793e738$var$activeScope)) && (!parentScope || $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(parentScope))) $9bf71ea28793e738$var$activeScope = parentScope;\n            $9bf71ea28793e738$export$d06fae2ee68b101e.removeTreeNode(scopeRef);\n        };\n    }, [\n        scopeRef\n    ]);\n    let focusManager = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$9bf71ea28793e738$var$createFocusManagerForScope(scopeRef), []);\n    let value = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            focusManager: focusManager,\n            parentNode: node\n        }), [\n        node,\n        focusManager\n    ]);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($9bf71ea28793e738$var$FocusContext.Provider, {\n        value: value\n    }, /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement(\"span\", {\n        \"data-focus-scope-start\": true,\n        hidden: true,\n        ref: startRef\n    }), children, /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement(\"span\", {\n        \"data-focus-scope-end\": true,\n        hidden: true,\n        ref: endRef\n    }));\n}\nfunction $9bf71ea28793e738$export$10c5169755ce7bd7() {\n    var _useContext;\n    return (_useContext = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($9bf71ea28793e738$var$FocusContext)) === null || _useContext === void 0 ? void 0 : _useContext.focusManager;\n}\nfunction $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef) {\n    return {\n        focusNext (opts = {}) {\n            let scope = scopeRef.current;\n            let { from: from, tabbable: tabbable, wrap: wrap, accept: accept } = opts;\n            let node = from || document.activeElement;\n            let sentinel = scope[0].previousElementSibling;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node, scope) ? node : sentinel;\n            let nextNode = walker.nextNode();\n            if (!nextNode && wrap) {\n                walker.currentNode = sentinel;\n                nextNode = walker.nextNode();\n            }\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusPrevious (opts = {}) {\n            let scope = scopeRef.current;\n            let { from: from, tabbable: tabbable, wrap: wrap, accept: accept } = opts;\n            let node = from || document.activeElement;\n            let sentinel = scope[scope.length - 1].nextElementSibling;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node, scope) ? node : sentinel;\n            let previousNode = walker.previousNode();\n            if (!previousNode && wrap) {\n                walker.currentNode = sentinel;\n                previousNode = walker.previousNode();\n            }\n            if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n            return previousNode;\n        },\n        focusFirst (opts = {}) {\n            let scope = scopeRef.current;\n            let { tabbable: tabbable, accept: accept } = opts;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = scope[0].previousElementSibling;\n            let nextNode = walker.nextNode();\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusLast (opts = {}) {\n            let scope = scopeRef.current;\n            let { tabbable: tabbable, accept: accept } = opts;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = scope[scope.length - 1].nextElementSibling;\n            let previousNode = walker.previousNode();\n            if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n            return previousNode;\n        }\n    };\n}\nconst $9bf71ea28793e738$var$focusableElements = [\n    \"input:not([disabled]):not([type=hidden])\",\n    \"select:not([disabled])\",\n    \"textarea:not([disabled])\",\n    \"button:not([disabled])\",\n    \"a[href]\",\n    \"area[href]\",\n    \"summary\",\n    \"iframe\",\n    \"object\",\n    \"embed\",\n    \"audio[controls]\",\n    \"video[controls]\",\n    \"[contenteditable]\"\n];\nconst $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(\":not([hidden]),\") + \",[tabindex]:not([disabled]):not([hidden])\";\n$9bf71ea28793e738$var$focusableElements.push('[tabindex]:not([tabindex=\"-1\"]):not([disabled])');\nconst $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(':not([hidden]):not([tabindex=\"-1\"]),');\nfunction $9bf71ea28793e738$var$getScopeRoot(scope) {\n    return scope[0].parentElement;\n}\nfunction $9bf71ea28793e738$var$shouldContainFocus(scopeRef) {\n    let scope = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);\n    while(scope && scope.scopeRef !== scopeRef){\n        if (scope.contain) return false;\n        scope = scope.parent;\n    }\n    return true;\n}\nfunction $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain) {\n    let focusedNode = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    let raf = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        let scope = scopeRef.current;\n        if (!contain) {\n            // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment\n            if (raf.current) {\n                cancelAnimationFrame(raf.current);\n                raf.current = undefined;\n            }\n            return;\n        }\n        // Handle the Tab key to contain focus within the scope\n        let onKeyDown = (e)=>{\n            if (e.key !== \"Tab\" || e.altKey || e.ctrlKey || e.metaKey || !$9bf71ea28793e738$var$shouldContainFocus(scopeRef)) return;\n            let focusedElement = document.activeElement;\n            let scope = scopeRef.current;\n            if (!scope || !$9bf71ea28793e738$var$isElementInScope(focusedElement, scope)) return;\n            let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n                tabbable: true\n            }, scope);\n            if (!focusedElement) return;\n            walker.currentNode = focusedElement;\n            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n            if (!nextElement) {\n                walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;\n                nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n            }\n            e.preventDefault();\n            if (nextElement) $9bf71ea28793e738$var$focusElement(nextElement, true);\n        };\n        let onFocus = (e)=>{\n            // If focusing an element in a child scope of the currently active scope, the child becomes active.\n            // Moving out of the active scope to an ancestor is not allowed.\n            if ((!$9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, scopeRef)) && $9bf71ea28793e738$var$isElementInScope(e.target, scopeRef.current)) {\n                $9bf71ea28793e738$var$activeScope = scopeRef;\n                focusedNode.current = e.target;\n            } else if ($9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(e.target, scopeRef)) {\n                // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),\n                // restore focus to the previously focused node or the first tabbable element in the active scope.\n                if (focusedNode.current) focusedNode.current.focus();\n                else if ($9bf71ea28793e738$var$activeScope && $9bf71ea28793e738$var$activeScope.current) $9bf71ea28793e738$var$focusFirstInScope($9bf71ea28793e738$var$activeScope.current);\n            } else if ($9bf71ea28793e738$var$shouldContainFocus(scopeRef)) focusedNode.current = e.target;\n        };\n        let onBlur = (e)=>{\n            // Firefox doesn't shift focus back to the Dialog properly without this\n            if (raf.current) cancelAnimationFrame(raf.current);\n            raf.current = requestAnimationFrame(()=>{\n                // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe\n                if (document.activeElement && $9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(document.activeElement, scopeRef)) {\n                    $9bf71ea28793e738$var$activeScope = scopeRef;\n                    if (document.body.contains(e.target)) {\n                        var _focusedNode_current;\n                        focusedNode.current = e.target;\n                        (_focusedNode_current = focusedNode.current) === null || _focusedNode_current === void 0 ? void 0 : _focusedNode_current.focus();\n                    } else if ($9bf71ea28793e738$var$activeScope.current) $9bf71ea28793e738$var$focusFirstInScope($9bf71ea28793e738$var$activeScope.current);\n                }\n            });\n        };\n        document.addEventListener(\"keydown\", onKeyDown, false);\n        document.addEventListener(\"focusin\", onFocus, false);\n        scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.addEventListener(\"focusin\", onFocus, false));\n        scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.addEventListener(\"focusout\", onBlur, false));\n        return ()=>{\n            document.removeEventListener(\"keydown\", onKeyDown, false);\n            document.removeEventListener(\"focusin\", onFocus, false);\n            scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.removeEventListener(\"focusin\", onFocus, false));\n            scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.removeEventListener(\"focusout\", onBlur, false));\n        };\n    }, [\n        scopeRef,\n        contain\n    ]);\n    // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur\n    // eslint-disable-next-line arrow-body-style\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        return ()=>{\n            if (raf.current) cancelAnimationFrame(raf.current);\n        };\n    }, [\n        raf\n    ]);\n}\nfunction $9bf71ea28793e738$var$isElementInAnyScope(element) {\n    return $9bf71ea28793e738$var$isElementInChildScope(element);\n}\nfunction $9bf71ea28793e738$var$isElementInScope(element, scope) {\n    if (!element) return false;\n    if (!scope) return false;\n    return scope.some((node)=>node.contains(element));\n}\nfunction $9bf71ea28793e738$var$isElementInChildScope(element, scope = null) {\n    // If the element is within a top layer element (e.g. toasts), always allow moving focus there.\n    if (element instanceof Element && element.closest(\"[data-react-aria-top-layer]\")) return true;\n    // node.contains in isElementInScope covers child scopes that are also DOM children,\n    // but does not cover child scopes in portals.\n    for (let { scopeRef: s } of $9bf71ea28793e738$export$d06fae2ee68b101e.traverse($9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scope))){\n        if (s && $9bf71ea28793e738$var$isElementInScope(element, s.current)) return true;\n    }\n    return false;\n}\nfunction $9bf71ea28793e738$export$1258395f99bf9cbf(element) {\n    return $9bf71ea28793e738$var$isElementInChildScope(element, $9bf71ea28793e738$var$activeScope);\n}\nfunction $9bf71ea28793e738$var$isAncestorScope(ancestor, scope) {\n    var _focusScopeTree_getTreeNode;\n    let parent = (_focusScopeTree_getTreeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scope)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : _focusScopeTree_getTreeNode.parent;\n    while(parent){\n        if (parent.scopeRef === ancestor) return true;\n        parent = parent.parent;\n    }\n    return false;\n}\nfunction $9bf71ea28793e738$var$focusElement(element, scroll = false) {\n    if (element != null && !scroll) try {\n        (0, $6a99195332edec8b$export$80f3e147d781571c)(element);\n    } catch (err) {\n    // ignore\n    }\n    else if (element != null) try {\n        element.focus();\n    } catch (err) {\n    // ignore\n    }\n}\nfunction $9bf71ea28793e738$var$focusFirstInScope(scope, tabbable = true) {\n    let sentinel = scope[0].previousElementSibling;\n    let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n    let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n        tabbable: tabbable\n    }, scope);\n    walker.currentNode = sentinel;\n    let nextNode = walker.nextNode();\n    // If the scope does not contain a tabbable element, use the first focusable element.\n    if (tabbable && !nextNode) {\n        scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);\n        walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {\n            tabbable: false\n        }, scope);\n        walker.currentNode = sentinel;\n        nextNode = walker.nextNode();\n    }\n    $9bf71ea28793e738$var$focusElement(nextNode);\n}\nfunction $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus) {\n    const autoFocusRef = (0, react__WEBPACK_IMPORTED_MODULE_0__).useRef(autoFocus);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (autoFocusRef.current) {\n            $9bf71ea28793e738$var$activeScope = scopeRef;\n            if (!$9bf71ea28793e738$var$isElementInScope(document.activeElement, $9bf71ea28793e738$var$activeScope.current) && scopeRef.current) $9bf71ea28793e738$var$focusFirstInScope(scopeRef.current);\n        }\n        autoFocusRef.current = false;\n    }, [\n        scopeRef\n    ]);\n}\nfunction $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restore, contain) {\n    // tracks the active scope, in case restore and contain are both false.\n    // if either are true, this is tracked in useRestoreFocus or useFocusContainment.\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        if (restore || contain) return;\n        let scope = scopeRef.current;\n        let onFocus = (e)=>{\n            let target = e.target;\n            if ($9bf71ea28793e738$var$isElementInScope(target, scopeRef.current)) $9bf71ea28793e738$var$activeScope = scopeRef;\n            else if (!$9bf71ea28793e738$var$isElementInAnyScope(target)) $9bf71ea28793e738$var$activeScope = null;\n        };\n        document.addEventListener(\"focusin\", onFocus, false);\n        scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.addEventListener(\"focusin\", onFocus, false));\n        return ()=>{\n            document.removeEventListener(\"focusin\", onFocus, false);\n            scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.removeEventListener(\"focusin\", onFocus, false));\n        };\n    }, [\n        scopeRef,\n        restore,\n        contain\n    ]);\n}\nfunction $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef) {\n    let scope = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);\n    while(scope && scope.scopeRef !== scopeRef){\n        if (scope.nodeToRestore) return false;\n        scope = scope.parent;\n    }\n    return (scope === null || scope === void 0 ? void 0 : scope.scopeRef) === scopeRef;\n}\nfunction $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain) {\n    // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.\n    const nodeToRestoreRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(typeof document !== \"undefined\" ? document.activeElement : null);\n    // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus\n    // restoring-non-containing scopes should only care if they become active so they can perform the restore\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        let scope = scopeRef.current;\n        if (!restoreFocus || contain) return;\n        let onFocus = ()=>{\n            // If focusing an element in a child scope of the currently active scope, the child becomes active.\n            // Moving out of the active scope to an ancestor is not allowed.\n            if ((!$9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, scopeRef)) && $9bf71ea28793e738$var$isElementInScope(document.activeElement, scopeRef.current)) $9bf71ea28793e738$var$activeScope = scopeRef;\n        };\n        document.addEventListener(\"focusin\", onFocus, false);\n        scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.addEventListener(\"focusin\", onFocus, false));\n        return ()=>{\n            document.removeEventListener(\"focusin\", onFocus, false);\n            scope === null || scope === void 0 ? void 0 : scope.forEach((element)=>element.removeEventListener(\"focusin\", onFocus, false));\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        scopeRef,\n        contain\n    ]);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        if (!restoreFocus) return;\n        // Handle the Tab key so that tabbing out of the scope goes to the next element\n        // after the node that had focus when the scope mounted. This is important when\n        // using portals for overlays, so that focus goes to the expected element when\n        // tabbing out of the overlay.\n        let onKeyDown = (e)=>{\n            if (e.key !== \"Tab\" || e.altKey || e.ctrlKey || e.metaKey || !$9bf71ea28793e738$var$shouldContainFocus(scopeRef)) return;\n            let focusedElement = document.activeElement;\n            if (!$9bf71ea28793e738$var$isElementInScope(focusedElement, scopeRef.current)) return;\n            let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n            if (!treeNode) return;\n            let nodeToRestore = treeNode.nodeToRestore;\n            // Create a DOM tree walker that matches all tabbable elements\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(document.body, {\n                tabbable: true\n            });\n            // Find the next tabbable element after the currently focused element\n            walker.currentNode = focusedElement;\n            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n            if (!nodeToRestore || !document.body.contains(nodeToRestore) || nodeToRestore === document.body) {\n                nodeToRestore = undefined;\n                treeNode.nodeToRestore = undefined;\n            }\n            // If there is no next element, or it is outside the current scope, move focus to the\n            // next element after the node to restore to instead.\n            if ((!nextElement || !$9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {\n                walker.currentNode = nodeToRestore;\n                // Skip over elements within the scope, in case the scope immediately follows the node to restore.\n                do nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n                while ($9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current));\n                e.preventDefault();\n                e.stopPropagation();\n                if (nextElement) $9bf71ea28793e738$var$focusElement(nextElement, true);\n                else // then move focus to the body.\n                // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)\n                if (!$9bf71ea28793e738$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();\n                else $9bf71ea28793e738$var$focusElement(nodeToRestore, true);\n            }\n        };\n        if (!contain) document.addEventListener(\"keydown\", onKeyDown, true);\n        return ()=>{\n            if (!contain) document.removeEventListener(\"keydown\", onKeyDown, true);\n        };\n    }, [\n        scopeRef,\n        restoreFocus,\n        contain\n    ]);\n    // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        if (!restoreFocus) return;\n        let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n        if (!treeNode) return;\n        var _nodeToRestoreRef_current;\n        treeNode.nodeToRestore = (_nodeToRestoreRef_current = nodeToRestoreRef.current) !== null && _nodeToRestoreRef_current !== void 0 ? _nodeToRestoreRef_current : undefined;\n        return ()=>{\n            let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n            if (!treeNode) return;\n            let nodeToRestore = treeNode.nodeToRestore;\n            // if we already lost focus to the body and this was the active scope, then we should attempt to restore\n            if (restoreFocus && nodeToRestore && // eslint-disable-next-line react-hooks/exhaustive-deps\n            ($9bf71ea28793e738$var$isElementInScope(document.activeElement, scopeRef.current) || document.activeElement === document.body && $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef))) {\n                // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it\n                let clonedTree = $9bf71ea28793e738$export$d06fae2ee68b101e.clone();\n                requestAnimationFrame(()=>{\n                    // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere\n                    if (document.activeElement === document.body) {\n                        // look up the tree starting with our scope to find a nodeToRestore still in the DOM\n                        let treeNode = clonedTree.getTreeNode(scopeRef);\n                        while(treeNode){\n                            if (treeNode.nodeToRestore && document.body.contains(treeNode.nodeToRestore)) {\n                                $9bf71ea28793e738$var$focusElement(treeNode.nodeToRestore);\n                                return;\n                            }\n                            treeNode = treeNode.parent;\n                        }\n                        // If no nodeToRestore was found, focus the first element in the nearest\n                        // ancestor scope that is still in the tree.\n                        treeNode = clonedTree.getTreeNode(scopeRef);\n                        while(treeNode){\n                            if (treeNode.scopeRef && treeNode.scopeRef.current && $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(treeNode.scopeRef)) {\n                                $9bf71ea28793e738$var$focusFirstInScope(treeNode.scopeRef.current, true);\n                                return;\n                            }\n                            treeNode = treeNode.parent;\n                        }\n                    }\n                });\n            }\n        };\n    }, [\n        scopeRef,\n        restoreFocus\n    ]);\n}\nfunction $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, opts, scope) {\n    let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR : $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR;\n    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {\n        acceptNode (node) {\n            var _opts_from;\n            // Skip nodes inside the starting node.\n            if (opts === null || opts === void 0 ? void 0 : (_opts_from = opts.from) === null || _opts_from === void 0 ? void 0 : _opts_from.contains(node)) return NodeFilter.FILTER_REJECT;\n            if (node.matches(selector) && (0, $645f2e67b85a24c9$export$e989c0fffaa6b27a)(node) && (!scope || $9bf71ea28793e738$var$isElementInScope(node, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node))) return NodeFilter.FILTER_ACCEPT;\n            return NodeFilter.FILTER_SKIP;\n        }\n    });\n    if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;\n    return walker;\n}\nfunction $9bf71ea28793e738$export$c5251b9e124bf29(ref, defaultOptions = {}) {\n    return {\n        focusNext (opts = {}) {\n            let root = ref.current;\n            if (!root) return null;\n            let { from: from, tabbable: tabbable = defaultOptions.tabbable, wrap: wrap = defaultOptions.wrap, accept: accept = defaultOptions.accept } = opts;\n            let node = from || document.activeElement;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            if (root.contains(node)) walker.currentNode = node;\n            let nextNode = walker.nextNode();\n            if (!nextNode && wrap) {\n                walker.currentNode = root;\n                nextNode = walker.nextNode();\n            }\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusPrevious (opts = defaultOptions) {\n            let root = ref.current;\n            if (!root) return null;\n            let { from: from, tabbable: tabbable = defaultOptions.tabbable, wrap: wrap = defaultOptions.wrap, accept: accept = defaultOptions.accept } = opts;\n            let node = from || document.activeElement;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            if (root.contains(node)) walker.currentNode = node;\n            else {\n                let next = $9bf71ea28793e738$var$last(walker);\n                if (next) $9bf71ea28793e738$var$focusElement(next, true);\n                return next !== null && next !== void 0 ? next : null;\n            }\n            let previousNode = walker.previousNode();\n            if (!previousNode && wrap) {\n                walker.currentNode = root;\n                let lastNode = $9bf71ea28793e738$var$last(walker);\n                if (!lastNode) return null;\n                previousNode = lastNode;\n            }\n            if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n            return previousNode !== null && previousNode !== void 0 ? previousNode : null;\n        },\n        focusFirst (opts = defaultOptions) {\n            let root = ref.current;\n            if (!root) return null;\n            let { tabbable: tabbable = defaultOptions.tabbable, accept: accept = defaultOptions.accept } = opts;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            let nextNode = walker.nextNode();\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusLast (opts = defaultOptions) {\n            let root = ref.current;\n            if (!root) return null;\n            let { tabbable: tabbable = defaultOptions.tabbable, accept: accept = defaultOptions.accept } = opts;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            let next = $9bf71ea28793e738$var$last(walker);\n            if (next) $9bf71ea28793e738$var$focusElement(next, true);\n            return next !== null && next !== void 0 ? next : null;\n        }\n    };\n}\nfunction $9bf71ea28793e738$var$last(walker) {\n    let next = undefined;\n    let last;\n    do {\n        last = walker.lastChild();\n        if (last) next = last;\n    }while (last);\n    return next;\n}\nclass $9bf71ea28793e738$var$Tree {\n    get size() {\n        return this.fastMap.size;\n    }\n    getTreeNode(data) {\n        return this.fastMap.get(data);\n    }\n    addTreeNode(scopeRef, parent, nodeToRestore) {\n        let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);\n        if (!parentNode) return;\n        let node = new $9bf71ea28793e738$var$TreeNode({\n            scopeRef: scopeRef\n        });\n        parentNode.addChild(node);\n        node.parent = parentNode;\n        this.fastMap.set(scopeRef, node);\n        if (nodeToRestore) node.nodeToRestore = nodeToRestore;\n    }\n    addNode(node) {\n        this.fastMap.set(node.scopeRef, node);\n    }\n    removeTreeNode(scopeRef) {\n        // never remove the root\n        if (scopeRef === null) return;\n        let node = this.fastMap.get(scopeRef);\n        if (!node) return;\n        let parentNode = node.parent;\n        // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing\n        // if we are, then replace the siblings restore with the restore from the scope we're removing\n        for (let current of this.traverse())if (current !== node && node.nodeToRestore && current.nodeToRestore && node.scopeRef && node.scopeRef.current && $9bf71ea28793e738$var$isElementInScope(current.nodeToRestore, node.scopeRef.current)) current.nodeToRestore = node.nodeToRestore;\n        let children = node.children;\n        if (parentNode) {\n            parentNode.removeChild(node);\n            if (children.size > 0) children.forEach((child)=>parentNode && parentNode.addChild(child));\n        }\n        this.fastMap.delete(node.scopeRef);\n    }\n    // Pre Order Depth First\n    *traverse(node = this.root) {\n        if (node.scopeRef != null) yield node;\n        if (node.children.size > 0) for (let child of node.children)yield* this.traverse(child);\n    }\n    clone() {\n        var _node_parent;\n        let newTree = new $9bf71ea28793e738$var$Tree();\n        var _node_parent_scopeRef;\n        for (let node of this.traverse())newTree.addTreeNode(node.scopeRef, (_node_parent_scopeRef = (_node_parent = node.parent) === null || _node_parent === void 0 ? void 0 : _node_parent.scopeRef) !== null && _node_parent_scopeRef !== void 0 ? _node_parent_scopeRef : null, node.nodeToRestore);\n        return newTree;\n    }\n    constructor(){\n        this.fastMap = new Map();\n        this.root = new $9bf71ea28793e738$var$TreeNode({\n            scopeRef: null\n        });\n        this.fastMap.set(null, this.root);\n    }\n}\nclass $9bf71ea28793e738$var$TreeNode {\n    addChild(node) {\n        this.children.add(node);\n        node.parent = this;\n    }\n    removeChild(node) {\n        this.children.delete(node);\n        node.parent = undefined;\n    }\n    constructor(props){\n        this.children = new Set();\n        this.contain = false;\n        this.scopeRef = props.scopeRef;\n    }\n}\nlet $9bf71ea28793e738$export$d06fae2ee68b101e = new $9bf71ea28793e738$var$Tree();\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $f7dceffc5ad7768b$export$4e328f61c538687f(props = {}) {\n    let { autoFocus: autoFocus = false, isTextInput: isTextInput, within: within } = props;\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isFocused: false,\n        isFocusVisible: autoFocus || (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__.isFocusVisible)()\n    });\n    let [isFocused, setFocused] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [isFocusVisibleState, setFocusVisible] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>state.current.isFocused && state.current.isFocusVisible);\n    let updateState = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);\n    let onFocusChange = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((isFocused)=>{\n        state.current.isFocused = isFocused;\n        setFocused(isFocused);\n        updateState();\n    }, [\n        updateState\n    ]);\n    (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__.useFocusVisibleListener)((isFocusVisible)=>{\n        state.current.isFocusVisible = isFocusVisible;\n        updateState();\n    }, [], {\n        isTextInput: isTextInput\n    });\n    let { focusProps: focusProps } = (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__.useFocus)({\n        isDisabled: within,\n        onFocusChange: onFocusChange\n    });\n    let { focusWithinProps: focusWithinProps } = (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__.useFocusWithin)({\n        isDisabled: !within,\n        onFocusWithinChange: onFocusChange\n    });\n    return {\n        isFocused: isFocused,\n        isFocusVisible: isFocusVisibleState,\n        focusProps: within ? focusWithinProps : focusProps\n    };\n}\nfunction $907718708eab68af$export$1a38b4ad7f578e1d(props) {\n    let { children: children, focusClass: focusClass, focusRingClass: focusRingClass } = props;\n    let { isFocused: isFocused, isFocusVisible: isFocusVisible, focusProps: focusProps } = (0, $f7dceffc5ad7768b$export$4e328f61c538687f)(props);\n    let child = (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.only(children);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).cloneElement(child, (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.mergeProps)(child.props, {\n        ...focusProps,\n        className: (0, clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n            [focusClass || \"\"]: isFocused,\n            [focusRingClass || \"\"]: isFocusVisible\n        })\n    }));\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $e6afbd83fe6ebbd2$var$FocusableContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext(null);\nfunction $e6afbd83fe6ebbd2$var$useFocusableContext(ref) {\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($e6afbd83fe6ebbd2$var$FocusableContext) || {};\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useSyncRef)(context, ref);\n    // eslint-disable-next-line\n    let { ref: _, ...otherProps } = context;\n    return otherProps;\n}\n/**\n * Provides DOM props to the nearest focusable child.\n */ function $e6afbd83fe6ebbd2$var$FocusableProvider(props, ref) {\n    let { children: children, ...otherProps } = props;\n    let objRef = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useObjectRef)(ref);\n    let context = {\n        ...otherProps,\n        ref: objRef\n    };\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($e6afbd83fe6ebbd2$var$FocusableContext.Provider, {\n        value: context\n    }, children);\n}\nlet $e6afbd83fe6ebbd2$export$13f3202a3e5ddd5 = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).forwardRef($e6afbd83fe6ebbd2$var$FocusableProvider);\nfunction $e6afbd83fe6ebbd2$export$4c014de7c8940b4c(props, domRef) {\n    let { focusProps: focusProps } = (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__.useFocus)(props);\n    let { keyboardProps: keyboardProps } = (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__.useKeyboard)(props);\n    let interactions = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.mergeProps)(focusProps, keyboardProps);\n    let domProps = $e6afbd83fe6ebbd2$var$useFocusableContext(domRef);\n    let interactionProps = props.isDisabled ? {} : domProps;\n    let autoFocusRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(props.autoFocus);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (autoFocusRef.current && domRef.current) (0, $6a99195332edec8b$export$80f3e147d781571c)(domRef.current);\n        autoFocusRef.current = false;\n    }, [\n        domRef\n    ]);\n    return {\n        focusableProps: (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.mergeProps)({\n            ...interactions,\n            tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined\n        }, interactionProps)\n    };\n}\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $83013635b024ae3d$export$eac1895992b9f3d6(ref, options) {\n    let isDisabled = options === null || options === void 0 ? void 0 : options.isDisabled;\n    let [hasTabbableChild, setHasTabbableChild] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(()=>{\n        if ((ref === null || ref === void 0 ? void 0 : ref.current) && !isDisabled) {\n            let update = ()=>{\n                if (ref.current) {\n                    let walker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(ref.current, {\n                        tabbable: true\n                    });\n                    setHasTabbableChild(!!walker.nextNode());\n                }\n            };\n            update();\n            // Update when new elements are inserted, or the tabIndex/disabled attribute updates.\n            let observer = new MutationObserver(update);\n            observer.observe(ref.current, {\n                subtree: true,\n                childList: true,\n                attributes: true,\n                attributeFilter: [\n                    \"tabIndex\",\n                    \"disabled\"\n                ]\n            });\n            return ()=>{\n                // Disconnect mutation observer when a React update occurs on the top-level component\n                // so we update synchronously after re-rendering. Otherwise React will emit act warnings\n                // in tests since mutation observers fire asynchronously. The mutation observer is necessary\n                // so we also update if a child component re-renders and adds/removes something tabbable.\n                observer.disconnect();\n            };\n        }\n    });\n    return isDisabled ? false : hasTabbableChild;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvZm9jdXMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1TjtBQUNvRTtBQUNtQjtBQUMvUTtBQUUvQjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FFRCxTQUFTc0MsMENBQTBDQyxPQUFPO0lBQ3RELDZFQUE2RTtJQUM3RSw0RUFBNEU7SUFDNUUsMkVBQTJFO0lBQzNFLCtFQUErRTtJQUMvRSx1QkFBdUI7SUFDdkIsSUFBSSxDQUFDLEdBQUdiLDRFQUE0QixRQUFTLFdBQVc7UUFDcEQsSUFBSWMscUJBQXFCQyxTQUFTQyxhQUFhO1FBQzlDLElBQUcxQixpRUFBd0IsRUFBRztZQUMzQiw0RUFBNEU7WUFDNUUsSUFBSXlCLFNBQVNDLGFBQWEsS0FBS0Ysc0JBQXNCQyxTQUFTRSxRQUFRLENBQUNKLFVBQVUsQ0FBQyxHQUFHckIsb0VBQTJCLEVBQUdxQjtRQUN2SDtJQUNKLE9BQU8sQ0FBQyxHQUFHckIsb0VBQTJCLEVBQUdxQjtBQUM3QztBQUdBOzs7Ozs7Ozs7O0NBVUMsR0FBRyxTQUFTSyxxQ0FBcUNMLE9BQU87SUFDckQsSUFBSSxDQUFFQSxDQUFBQSxtQkFBbUJNLFdBQVUsS0FBTSxDQUFFTixDQUFBQSxtQkFBbUJPLFVBQVMsR0FBSSxPQUFPO0lBQ2xGLElBQUksRUFBRUMsU0FBU0EsT0FBTyxFQUFFQyxZQUFZQSxVQUFVLEVBQUUsR0FBR1QsUUFBUVUsS0FBSztJQUNoRSxJQUFJQyxZQUFZSCxZQUFZLFVBQVVDLGVBQWUsWUFBWUEsZUFBZTtJQUNoRixJQUFJRSxXQUFXO1FBQ1gsTUFBTSxFQUFFQyxrQkFBa0JBLGdCQUFnQixFQUFFLEdBQUdaLFFBQVFhLGFBQWEsQ0FBQ0MsV0FBVztRQUNoRixJQUFJLEVBQUVOLFNBQVNPLGVBQWUsRUFBRU4sWUFBWU8sa0JBQWtCLEVBQUUsR0FBR0osaUJBQWlCWjtR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WUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRN0IsVUFBVTtJQUNyRixJQUFJLENBQUM4QixrQkFBa0JDLG9CQUFvQixHQUFHLENBQUMsR0FBR3pQLDJDQUFjLEVBQUc7SUFDbEUsSUFBR0ksOERBQXFCLEVBQUc7UUFDeEIsSUFBSSxDQUFDOEYsUUFBUSxRQUFRQSxRQUFRLEtBQUssSUFBSSxLQUFLLElBQUlBLElBQUl0QixPQUFPLEtBQUssQ0FBQzhJLFlBQVk7WUFDeEUsSUFBSWdDLFNBQVM7Z0JBQ1QsSUFBSXhKLElBQUl0QixPQUFPLEVBQUU7b0JBQ2IsSUFBSW1DLFNBQVMsQ0FBQyxHQUFHQyx5Q0FBd0MsRUFBR2QsSUFBSXRCLE9BQU8sRUFBRTt3QkFDckU0QixVQUFVO29CQUNkO29CQUNBaUosb0JBQW9CLENBQUMsQ0FBQzFJLE9BQU9HLFFBQVE7Z0JBQ3pDO1lBQ0o7WUFDQXdJO1lBQ0EscUZBQXFGO1lBQ3JGLElBQUlDLFdBQVcsSUFBSUMsaUJBQWlCRjtZQUNwQ0MsU0FBU0UsT0FBTyxDQUFDM0osSUFBSXRCLE9BQU8sRUFBRTtnQkFDMUJrTCxTQUFTO2dCQUNUQyxXQUFXO2dCQUNYQyxZQUFZO2dCQUNaQyxpQkFBaUI7b0JBQ2I7b0JBQ0E7aUJBQ0g7WUFDTDtZQUNBLE9BQU87Z0JBQ0gscUZBQXFGO2dCQUNyRix3RkFBd0Y7Z0JBQ3hGLDRGQUE0RjtnQkFDNUYseUZBQXlGO2dCQUN6Rk4sU0FBU08sVUFBVTtZQUN2QjtRQUNKO0lBQ0o7SUFDQSxPQUFPeEMsYUFBYSxRQUFROEI7QUFDaEM7QUFLeXJCLENBQ3pyQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmljZWZldGNoLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL2ZvY3VzL2Rpc3QvaW1wb3J0Lm1qcz84ZDgzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAkNm5mRkMkcmVhY3QsIHt1c2VSZWYgYXMgJDZuZkZDJHVzZVJlZiwgdXNlQ29udGV4dCBhcyAkNm5mRkMkdXNlQ29udGV4dCwgdXNlTWVtbyBhcyAkNm5mRkMkdXNlTWVtbywgdXNlRWZmZWN0IGFzICQ2bmZGQyR1c2VFZmZlY3QsIHVzZVN0YXRlIGFzICQ2bmZGQyR1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgYXMgJDZuZkZDJHVzZUNhbGxiYWNrfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlTGF5b3V0RWZmZWN0IGFzICQ2bmZGQyR1c2VMYXlvdXRFZmZlY3QsIHJ1bkFmdGVyVHJhbnNpdGlvbiBhcyAkNm5mRkMkcnVuQWZ0ZXJUcmFuc2l0aW9uLCBmb2N1c1dpdGhvdXRTY3JvbGxpbmcgYXMgJDZuZkZDJGZvY3VzV2l0aG91dFNjcm9sbGluZywgbWVyZ2VQcm9wcyBhcyAkNm5mRkMkbWVyZ2VQcm9wcywgdXNlU3luY1JlZiBhcyAkNm5mRkMkdXNlU3luY1JlZiwgdXNlT2JqZWN0UmVmIGFzICQ2bmZGQyR1c2VPYmplY3RSZWZ9IGZyb20gXCJAcmVhY3QtYXJpYS91dGlsc1wiO1xuaW1wb3J0IHtnZXRJbnRlcmFjdGlvbk1vZGFsaXR5IGFzICQ2bmZGQyRnZXRJbnRlcmFjdGlvbk1vZGFsaXR5LCBpc0ZvY3VzVmlzaWJsZSBhcyAkNm5mRkMkaXNGb2N1c1Zpc2libGUsIHVzZUZvY3VzVmlzaWJsZUxpc3RlbmVyIGFzICQ2bmZGQyR1c2VGb2N1c1Zpc2libGVMaXN0ZW5lciwgdXNlRm9jdXMgYXMgJDZuZkZDJHVzZUZvY3VzLCB1c2VGb2N1c1dpdGhpbiBhcyAkNm5mRkMkdXNlRm9jdXNXaXRoaW4sIHVzZUtleWJvYXJkIGFzICQ2bmZGQyR1c2VLZXlib2FyZH0gZnJvbSBcIkByZWFjdC1hcmlhL2ludGVyYWN0aW9uc1wiO1xuaW1wb3J0ICQ2bmZGQyRjbHN4IGZyb20gXCJjbHN4XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmZ1bmN0aW9uICQ2YTk5MTk1MzMyZWRlYzhiJGV4cG9ydCQ4MGYzZTE0N2Q3ODE1NzFjKGVsZW1lbnQpIHtcbiAgICAvLyBJZiB0aGUgdXNlciBpcyBpbnRlcmFjdGluZyB3aXRoIGEgdmlydHVhbCBjdXJzb3IsIGUuZy4gc2NyZWVuIHJlYWRlciwgdGhlblxuICAgIC8vIHdhaXQgdW50aWwgYWZ0ZXIgYW55IGFuaW1hdGVkIHRyYW5zaXRpb25zIHRoYXQgYXJlIGN1cnJlbnRseSBvY2N1cnJpbmcgb25cbiAgICAvLyB0aGUgcGFnZSBiZWZvcmUgc2hpZnRpbmcgZm9jdXMuIFRoaXMgYXZvaWRzIGlzc3VlcyB3aXRoIFZvaWNlT3ZlciBvbiBpT1NcbiAgICAvLyBjYXVzaW5nIHRoZSBwYWdlIHRvIHNjcm9sbCB3aGVuIG1vdmluZyBmb2N1cyBpZiB0aGUgZWxlbWVudCBpcyB0cmFuc2l0aW9uaW5nXG4gICAgLy8gZnJvbSBvZmYgdGhlIHNjcmVlbi5cbiAgICBpZiAoKDAsICQ2bmZGQyRnZXRJbnRlcmFjdGlvbk1vZGFsaXR5KSgpID09PSBcInZpcnR1YWxcIikge1xuICAgICAgICBsZXQgbGFzdEZvY3VzZWRFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgKDAsICQ2bmZGQyRydW5BZnRlclRyYW5zaXRpb24pKCgpPT57XG4gICAgICAgICAgICAvLyBJZiBmb2N1cyBkaWQgbm90IG1vdmUgYW5kIHRoZSBlbGVtZW50IGlzIHN0aWxsIGluIHRoZSBkb2N1bWVudCwgZm9jdXMgaXQuXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gbGFzdEZvY3VzZWRFbGVtZW50ICYmIGRvY3VtZW50LmNvbnRhaW5zKGVsZW1lbnQpKSAoMCwgJDZuZkZDJGZvY3VzV2l0aG91dFNjcm9sbGluZykoZWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSAoMCwgJDZuZkZDJGZvY3VzV2l0aG91dFNjcm9sbGluZykoZWxlbWVudCk7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIxIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICQ2NDVmMmU2N2I4NWEyNGM5JHZhciRpc1N0eWxlVmlzaWJsZShlbGVtZW50KSB7XG4gICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSAmJiAhKGVsZW1lbnQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSkgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IGRpc3BsYXk6IGRpc3BsYXksIHZpc2liaWxpdHk6IHZpc2liaWxpdHkgfSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgbGV0IGlzVmlzaWJsZSA9IGRpc3BsYXkgIT09IFwibm9uZVwiICYmIHZpc2liaWxpdHkgIT09IFwiaGlkZGVuXCIgJiYgdmlzaWJpbGl0eSAhPT0gXCJjb2xsYXBzZVwiO1xuICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgICAgY29uc3QgeyBnZXRDb21wdXRlZFN0eWxlOiBnZXRDb21wdXRlZFN0eWxlIH0gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICAgIGxldCB7IGRpc3BsYXk6IGNvbXB1dGVkRGlzcGxheSwgdmlzaWJpbGl0eTogY29tcHV0ZWRWaXNpYmlsaXR5IH0gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgICBpc1Zpc2libGUgPSBjb21wdXRlZERpc3BsYXkgIT09IFwibm9uZVwiICYmIGNvbXB1dGVkVmlzaWJpbGl0eSAhPT0gXCJoaWRkZW5cIiAmJiBjb21wdXRlZFZpc2liaWxpdHkgIT09IFwiY29sbGFwc2VcIjtcbiAgICB9XG4gICAgcmV0dXJuIGlzVmlzaWJsZTtcbn1cbmZ1bmN0aW9uICQ2NDVmMmU2N2I4NWEyNGM5JHZhciRpc0F0dHJpYnV0ZVZpc2libGUoZWxlbWVudCwgY2hpbGRFbGVtZW50KSB7XG4gICAgcmV0dXJuICFlbGVtZW50Lmhhc0F0dHJpYnV0ZShcImhpZGRlblwiKSAmJiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gXCJERVRBSUxTXCIgJiYgY2hpbGRFbGVtZW50ICYmIGNoaWxkRWxlbWVudC5ub2RlTmFtZSAhPT0gXCJTVU1NQVJZXCIgPyBlbGVtZW50Lmhhc0F0dHJpYnV0ZShcIm9wZW5cIikgOiB0cnVlKTtcbn1cbmZ1bmN0aW9uICQ2NDVmMmU2N2I4NWEyNGM5JGV4cG9ydCRlOTg5YzBmZmZhYTZiMjdhKGVsZW1lbnQsIGNoaWxkRWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50Lm5vZGVOYW1lICE9PSBcIiNjb21tZW50XCIgJiYgJDY0NWYyZTY3Yjg1YTI0YzkkdmFyJGlzU3R5bGVWaXNpYmxlKGVsZW1lbnQpICYmICQ2NDVmMmU2N2I4NWEyNGM5JHZhciRpc0F0dHJpYnV0ZVZpc2libGUoZWxlbWVudCwgY2hpbGRFbGVtZW50KSAmJiAoIWVsZW1lbnQucGFyZW50RWxlbWVudCB8fCAkNjQ1ZjJlNjdiODVhMjRjOSRleHBvcnQkZTk4OWMwZmZmYWE2YjI3YShlbGVtZW50LnBhcmVudEVsZW1lbnQsIGVsZW1lbnQpKTtcbn1cblxuXG5cblxuY29uc3QgJDliZjcxZWEyODc5M2U3MzgkdmFyJEZvY3VzQ29udGV4dCA9IC8qI19fUFVSRV9fKi8gKDAsICQ2bmZGQyRyZWFjdCkuY3JlYXRlQ29udGV4dChudWxsKTtcbmxldCAkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUgPSBudWxsO1xuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDIwZTQwMjg5NjQxZmJiYjYocHJvcHMpIHtcbiAgICBsZXQgeyBjaGlsZHJlbjogY2hpbGRyZW4sIGNvbnRhaW46IGNvbnRhaW4sIHJlc3RvcmVGb2N1czogcmVzdG9yZUZvY3VzLCBhdXRvRm9jdXM6IGF1dG9Gb2N1cyB9ID0gcHJvcHM7XG4gICAgbGV0IHN0YXJ0UmVmID0gKDAsICQ2bmZGQyR1c2VSZWYpKG51bGwpO1xuICAgIGxldCBlbmRSZWYgPSAoMCwgJDZuZkZDJHVzZVJlZikobnVsbCk7XG4gICAgbGV0IHNjb3BlUmVmID0gKDAsICQ2bmZGQyR1c2VSZWYpKFtdKTtcbiAgICBsZXQgeyBwYXJlbnROb2RlOiBwYXJlbnROb2RlIH0gPSAoMCwgJDZuZkZDJHVzZUNvbnRleHQpKCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRGb2N1c0NvbnRleHQpIHx8IHt9O1xuICAgIC8vIENyZWF0ZSBhIHRyZWUgbm9kZSBoZXJlIHNvIHdlIGNhbiBhZGQgY2hpbGRyZW4gdG8gaXQgZXZlbiBiZWZvcmUgaXQgaXMgYWRkZWQgdG8gdGhlIHRyZWUuXG4gICAgbGV0IG5vZGUgPSAoMCwgJDZuZkZDJHVzZU1lbW8pKCgpPT5uZXcgJDliZjcxZWEyODc5M2U3MzgkdmFyJFRyZWVOb2RlKHtcbiAgICAgICAgICAgIHNjb3BlUmVmOiBzY29wZVJlZlxuICAgICAgICB9KSwgW1xuICAgICAgICBzY29wZVJlZlxuICAgIF0pO1xuICAgICgwLCAkNm5mRkMkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICAvLyBJZiBhIG5ldyBzY29wZSBtb3VudHMgb3V0c2lkZSB0aGUgYWN0aXZlIHNjb3BlLCAoZS5nLiBEaWFsb2dDb250YWluZXIgbGF1bmNoZWQgZnJvbSBhIG1lbnUpLFxuICAgICAgICAvLyB1c2UgdGhlIGFjdGl2ZSBzY29wZSBhcyB0aGUgcGFyZW50IGluc3RlYWQgb2YgdGhlIHBhcmVudCBmcm9tIGNvbnRleHQuIExheW91dCBlZmZlY3RzIHJ1biBib3R0b21cbiAgICAgICAgLy8gdXAsIHNvIGlmIHRoZSBwYXJlbnQgaXMgbm90IHlldCBhZGRlZCB0byB0aGUgdHJlZSwgZG9uJ3QgZG8gdGhpcy4gT25seSB0aGUgb3V0ZXItbW9zdCBGb2N1c1Njb3BlXG4gICAgICAgIC8vIHRoYXQgaXMgYmVpbmcgYWRkZWQgc2hvdWxkIGdldCB0aGUgYWN0aXZlU2NvcGUgYXMgaXRzIHBhcmVudC5cbiAgICAgICAgbGV0IHBhcmVudCA9IHBhcmVudE5vZGUgfHwgJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUucm9vdDtcbiAgICAgICAgaWYgKCQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLmdldFRyZWVOb2RlKHBhcmVudC5zY29wZVJlZikgJiYgJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlICYmICEkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNBbmNlc3RvclNjb3BlKCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSwgcGFyZW50LnNjb3BlUmVmKSkge1xuICAgICAgICAgICAgbGV0IGFjdGl2ZU5vZGUgPSAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZS5nZXRUcmVlTm9kZSgkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUpO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZU5vZGUpIHBhcmVudCA9IGFjdGl2ZU5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBub2RlIHRvIHRoZSBwYXJlbnQsIGFuZCB0byB0aGUgdHJlZS5cbiAgICAgICAgcGFyZW50LmFkZENoaWxkKG5vZGUpO1xuICAgICAgICAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZS5hZGROb2RlKG5vZGUpO1xuICAgIH0sIFtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgcGFyZW50Tm9kZVxuICAgIF0pO1xuICAgICgwLCAkNm5mRkMkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICBsZXQgbm9kZSA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLmdldFRyZWVOb2RlKHNjb3BlUmVmKTtcbiAgICAgICAgaWYgKG5vZGUpIG5vZGUuY29udGFpbiA9ICEhY29udGFpbjtcbiAgICB9LCBbXG4gICAgICAgIGNvbnRhaW5cbiAgICBdKTtcbiAgICAoMCwgJDZuZkZDJHVzZUxheW91dEVmZmVjdCkoKCk9PntcbiAgICAgICAgdmFyIF9zdGFydFJlZl9jdXJyZW50O1xuICAgICAgICAvLyBGaW5kIGFsbCByZW5kZXJlZCBub2RlcyBiZXR3ZWVuIHRoZSBzZW50aW5lbHMgYW5kIGFkZCB0aGVtIHRvIHRoZSBzY29wZS5cbiAgICAgICAgbGV0IG5vZGUgPSAoX3N0YXJ0UmVmX2N1cnJlbnQgPSBzdGFydFJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfc3RhcnRSZWZfY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXJ0UmVmX2N1cnJlbnQubmV4dFNpYmxpbmc7XG4gICAgICAgIGxldCBub2RlcyA9IFtdO1xuICAgICAgICB3aGlsZShub2RlICYmIG5vZGUgIT09IGVuZFJlZi5jdXJyZW50KXtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBzY29wZVJlZi5jdXJyZW50ID0gbm9kZXM7XG4gICAgfSwgW1xuICAgICAgICBjaGlsZHJlblxuICAgIF0pO1xuICAgICQ5YmY3MWVhMjg3OTNlNzM4JHZhciR1c2VBY3RpdmVTY29wZVRyYWNrZXIoc2NvcGVSZWYsIHJlc3RvcmVGb2N1cywgY29udGFpbik7XG4gICAgJDliZjcxZWEyODc5M2U3MzgkdmFyJHVzZUZvY3VzQ29udGFpbm1lbnQoc2NvcGVSZWYsIGNvbnRhaW4pO1xuICAgICQ5YmY3MWVhMjg3OTNlNzM4JHZhciR1c2VSZXN0b3JlRm9jdXMoc2NvcGVSZWYsIHJlc3RvcmVGb2N1cywgY29udGFpbik7XG4gICAgJDliZjcxZWEyODc5M2U3MzgkdmFyJHVzZUF1dG9Gb2N1cyhzY29wZVJlZiwgYXV0b0ZvY3VzKTtcbiAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGFuIGVmZmVjdCBzbyB0aGF0IGFjdGl2ZVNjb3BlIGlzIHVwZGF0ZWQgYWZ0ZXIgdGhlIEZvY3VzU2NvcGUgdHJlZSBpcyBjb21wbGV0ZS5cbiAgICAvLyBJdCBjYW5ub3QgYmUgYSB1c2VMYXlvdXRFZmZlY3QgYmVjYXVzZSB0aGUgcGFyZW50IG9mIHRoaXMgbm9kZSBoYXNuJ3QgYmVlbiBhdHRhY2hlZCBpbiB0aGUgdHJlZSB5ZXQuXG4gICAgKDAsICQ2bmZGQyR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGxldCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgbGV0IHNjb3BlID0gbnVsbDtcbiAgICAgICAgaWYgKCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJblNjb3BlKGFjdGl2ZUVsZW1lbnQsIHNjb3BlUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHRyYXZlcnNlIHRoZSBmb2N1c1Njb3BlIHRyZWUgYW5kIGZpbmQgdGhlIGJvdHRvbSBtb3N0IHNjb3BlIHRoYXRcbiAgICAgICAgICAgIC8vIGNvbnRhaW5zIHRoZSBhY3RpdmUgZWxlbWVudCBhbmQgc2V0IHRoYXQgYXMgdGhlIGFjdGl2ZVNjb3BlLlxuICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZS50cmF2ZXJzZSgpKWlmIChub2RlLnNjb3BlUmVmICYmICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJblNjb3BlKGFjdGl2ZUVsZW1lbnQsIG5vZGUuc2NvcGVSZWYuY3VycmVudCkpIHNjb3BlID0gbm9kZTtcbiAgICAgICAgICAgIGlmIChzY29wZSA9PT0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUuZ2V0VHJlZU5vZGUoc2NvcGVSZWYpKSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUgPSBzY29wZS5zY29wZVJlZjtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgc2NvcGVSZWZcbiAgICBdKTtcbiAgICAvLyBUaGlzIGxheW91dCBlZmZlY3QgY2xlYW51cCBpcyBzbyB0aGF0IHRoZSB0cmVlIG5vZGUgaXMgcmVtb3ZlZCBzeW5jaHJvbm91c2x5IHdpdGggcmVhY3QgYmVmb3JlIHRoZSBSQUZcbiAgICAvLyBpbiB1c2VSZXN0b3JlRm9jdXMgY2xlYW51cCBydW5zLlxuICAgICgwLCAkNm5mRkMkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHZhciBfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGVfcGFyZW50LCBfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGU7XG4gICAgICAgICAgICB2YXIgX2ZvY3VzU2NvcGVUcmVlX2dldFRyZWVOb2RlX3BhcmVudF9zY29wZVJlZjtcbiAgICAgICAgICAgIC8vIFNjb3BlIG1heSBoYXZlIGJlZW4gcmUtcGFyZW50ZWQuXG4gICAgICAgICAgICBsZXQgcGFyZW50U2NvcGUgPSAoX2ZvY3VzU2NvcGVUcmVlX2dldFRyZWVOb2RlX3BhcmVudF9zY29wZVJlZiA9IChfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGUgPSAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZS5nZXRUcmVlTm9kZShzY29wZVJlZikpID09PSBudWxsIHx8IF9mb2N1c1Njb3BlVHJlZV9nZXRUcmVlTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9mb2N1c1Njb3BlVHJlZV9nZXRUcmVlTm9kZV9wYXJlbnQgPSBfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGUucGFyZW50KSA9PT0gbnVsbCB8fCBfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGVfcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGVfcGFyZW50LnNjb3BlUmVmKSAhPT0gbnVsbCAmJiBfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGVfcGFyZW50X3Njb3BlUmVmICE9PSB2b2lkIDAgPyBfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGVfcGFyZW50X3Njb3BlUmVmIDogbnVsbDtcbiAgICAgICAgICAgIGlmICgoc2NvcGVSZWYgPT09ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSB8fCAkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNBbmNlc3RvclNjb3BlKHNjb3BlUmVmLCAkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUpKSAmJiAoIXBhcmVudFNjb3BlIHx8ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLmdldFRyZWVOb2RlKHBhcmVudFNjb3BlKSkpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSA9IHBhcmVudFNjb3BlO1xuICAgICAgICAgICAgJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUucmVtb3ZlVHJlZU5vZGUoc2NvcGVSZWYpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgc2NvcGVSZWZcbiAgICBdKTtcbiAgICBsZXQgZm9jdXNNYW5hZ2VyID0gKDAsICQ2bmZGQyR1c2VNZW1vKSgoKT0+JDliZjcxZWEyODc5M2U3MzgkdmFyJGNyZWF0ZUZvY3VzTWFuYWdlckZvclNjb3BlKHNjb3BlUmVmKSwgW10pO1xuICAgIGxldCB2YWx1ZSA9ICgwLCAkNm5mRkMkdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICBmb2N1c01hbmFnZXI6IGZvY3VzTWFuYWdlcixcbiAgICAgICAgICAgIHBhcmVudE5vZGU6IG5vZGVcbiAgICAgICAgfSksIFtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgZm9jdXNNYW5hZ2VyXG4gICAgXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsICQ2bmZGQyRyZWFjdCkuY3JlYXRlRWxlbWVudCgkOWJmNzFlYTI4NzkzZTczOCR2YXIkRm9jdXNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0sIC8qI19fUFVSRV9fKi8gKDAsICQ2bmZGQyRyZWFjdCkuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBcImRhdGEtZm9jdXMtc2NvcGUtc3RhcnRcIjogdHJ1ZSxcbiAgICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgICByZWY6IHN0YXJ0UmVmXG4gICAgfSksIGNoaWxkcmVuLCAvKiNfX1BVUkVfXyovICgwLCAkNm5mRkMkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgXCJkYXRhLWZvY3VzLXNjb3BlLWVuZFwiOiB0cnVlLFxuICAgICAgICBoaWRkZW46IHRydWUsXG4gICAgICAgIHJlZjogZW5kUmVmXG4gICAgfSkpO1xufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDEwYzUxNjk3NTVjZTdiZDcoKSB7XG4gICAgdmFyIF91c2VDb250ZXh0O1xuICAgIHJldHVybiAoX3VzZUNvbnRleHQgPSAoMCwgJDZuZkZDJHVzZUNvbnRleHQpKCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRGb2N1c0NvbnRleHQpKSA9PT0gbnVsbCB8fCBfdXNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3VzZUNvbnRleHQuZm9jdXNNYW5hZ2VyO1xufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkdmFyJGNyZWF0ZUZvY3VzTWFuYWdlckZvclNjb3BlKHNjb3BlUmVmKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZm9jdXNOZXh0IChvcHRzID0ge30pIHtcbiAgICAgICAgICAgIGxldCBzY29wZSA9IHNjb3BlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBsZXQgeyBmcm9tOiBmcm9tLCB0YWJiYWJsZTogdGFiYmFibGUsIHdyYXA6IHdyYXAsIGFjY2VwdDogYWNjZXB0IH0gPSBvcHRzO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBmcm9tIHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBsZXQgc2VudGluZWwgPSBzY29wZVswXS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgbGV0IHNjb3BlUm9vdCA9ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRnZXRTY29wZVJvb3Qoc2NvcGUpO1xuICAgICAgICAgICAgbGV0IHdhbGtlciA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhKHNjb3BlUm9vdCwge1xuICAgICAgICAgICAgICAgIHRhYmJhYmxlOiB0YWJiYWJsZSxcbiAgICAgICAgICAgICAgICBhY2NlcHQ6IGFjY2VwdFxuICAgICAgICAgICAgfSwgc2NvcGUpO1xuICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUobm9kZSwgc2NvcGUpID8gbm9kZSA6IHNlbnRpbmVsO1xuICAgICAgICAgICAgbGV0IG5leHROb2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICBpZiAoIW5leHROb2RlICYmIHdyYXApIHtcbiAgICAgICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBzZW50aW5lbDtcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHROb2RlKSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNFbGVtZW50KG5leHROb2RlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0Tm9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXNQcmV2aW91cyAob3B0cyA9IHt9KSB7XG4gICAgICAgICAgICBsZXQgc2NvcGUgPSBzY29wZVJlZi5jdXJyZW50O1xuICAgICAgICAgICAgbGV0IHsgZnJvbTogZnJvbSwgdGFiYmFibGU6IHRhYmJhYmxlLCB3cmFwOiB3cmFwLCBhY2NlcHQ6IGFjY2VwdCB9ID0gb3B0cztcbiAgICAgICAgICAgIGxldCBub2RlID0gZnJvbSB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgbGV0IHNlbnRpbmVsID0gc2NvcGVbc2NvcGUubGVuZ3RoIC0gMV0ubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgbGV0IHNjb3BlUm9vdCA9ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRnZXRTY29wZVJvb3Qoc2NvcGUpO1xuICAgICAgICAgICAgbGV0IHdhbGtlciA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhKHNjb3BlUm9vdCwge1xuICAgICAgICAgICAgICAgIHRhYmJhYmxlOiB0YWJiYWJsZSxcbiAgICAgICAgICAgICAgICBhY2NlcHQ6IGFjY2VwdFxuICAgICAgICAgICAgfSwgc2NvcGUpO1xuICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUobm9kZSwgc2NvcGUpID8gbm9kZSA6IHNlbnRpbmVsO1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzTm9kZSA9IHdhbGtlci5wcmV2aW91c05vZGUoKTtcbiAgICAgICAgICAgIGlmICghcHJldmlvdXNOb2RlICYmIHdyYXApIHtcbiAgICAgICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBzZW50aW5lbDtcbiAgICAgICAgICAgICAgICBwcmV2aW91c05vZGUgPSB3YWxrZXIucHJldmlvdXNOb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldmlvdXNOb2RlKSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNFbGVtZW50KHByZXZpb3VzTm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNOb2RlO1xuICAgICAgICB9LFxuICAgICAgICBmb2N1c0ZpcnN0IChvcHRzID0ge30pIHtcbiAgICAgICAgICAgIGxldCBzY29wZSA9IHNjb3BlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBsZXQgeyB0YWJiYWJsZTogdGFiYmFibGUsIGFjY2VwdDogYWNjZXB0IH0gPSBvcHRzO1xuICAgICAgICAgICAgbGV0IHNjb3BlUm9vdCA9ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRnZXRTY29wZVJvb3Qoc2NvcGUpO1xuICAgICAgICAgICAgbGV0IHdhbGtlciA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhKHNjb3BlUm9vdCwge1xuICAgICAgICAgICAgICAgIHRhYmJhYmxlOiB0YWJiYWJsZSxcbiAgICAgICAgICAgICAgICBhY2NlcHQ6IGFjY2VwdFxuICAgICAgICAgICAgfSwgc2NvcGUpO1xuICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gc2NvcGVbMF0ucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICAgICAgICAgIGxldCBuZXh0Tm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgICAgICAgaWYgKG5leHROb2RlKSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNFbGVtZW50KG5leHROb2RlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0Tm9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXNMYXN0IChvcHRzID0ge30pIHtcbiAgICAgICAgICAgIGxldCBzY29wZSA9IHNjb3BlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBsZXQgeyB0YWJiYWJsZTogdGFiYmFibGUsIGFjY2VwdDogYWNjZXB0IH0gPSBvcHRzO1xuICAgICAgICAgICAgbGV0IHNjb3BlUm9vdCA9ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRnZXRTY29wZVJvb3Qoc2NvcGUpO1xuICAgICAgICAgICAgbGV0IHdhbGtlciA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhKHNjb3BlUm9vdCwge1xuICAgICAgICAgICAgICAgIHRhYmJhYmxlOiB0YWJiYWJsZSxcbiAgICAgICAgICAgICAgICBhY2NlcHQ6IGFjY2VwdFxuICAgICAgICAgICAgfSwgc2NvcGUpO1xuICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gc2NvcGVbc2NvcGUubGVuZ3RoIC0gMV0ubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzTm9kZSA9IHdhbGtlci5wcmV2aW91c05vZGUoKTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c05vZGUpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0VsZW1lbnQocHJldmlvdXNOb2RlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c05vZGU7XG4gICAgICAgIH1cbiAgICB9O1xufVxuY29uc3QgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzYWJsZUVsZW1lbnRzID0gW1xuICAgIFwiaW5wdXQ6bm90KFtkaXNhYmxlZF0pOm5vdChbdHlwZT1oaWRkZW5dKVwiLFxuICAgIFwic2VsZWN0Om5vdChbZGlzYWJsZWRdKVwiLFxuICAgIFwidGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pXCIsXG4gICAgXCJidXR0b246bm90KFtkaXNhYmxlZF0pXCIsXG4gICAgXCJhW2hyZWZdXCIsXG4gICAgXCJhcmVhW2hyZWZdXCIsXG4gICAgXCJzdW1tYXJ5XCIsXG4gICAgXCJpZnJhbWVcIixcbiAgICBcIm9iamVjdFwiLFxuICAgIFwiZW1iZWRcIixcbiAgICBcImF1ZGlvW2NvbnRyb2xzXVwiLFxuICAgIFwidmlkZW9bY29udHJvbHNdXCIsXG4gICAgXCJbY29udGVudGVkaXRhYmxlXVwiXG5dO1xuY29uc3QgJDliZjcxZWEyODc5M2U3MzgkdmFyJEZPQ1VTQUJMRV9FTEVNRU5UX1NFTEVDVE9SID0gJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzYWJsZUVsZW1lbnRzLmpvaW4oXCI6bm90KFtoaWRkZW5dKSxcIikgKyBcIixbdGFiaW5kZXhdOm5vdChbZGlzYWJsZWRdKTpub3QoW2hpZGRlbl0pXCI7XG4kOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNhYmxlRWxlbWVudHMucHVzaCgnW3RhYmluZGV4XTpub3QoW3RhYmluZGV4PVwiLTFcIl0pOm5vdChbZGlzYWJsZWRdKScpO1xuY29uc3QgJDliZjcxZWEyODc5M2U3MzgkdmFyJFRBQkJBQkxFX0VMRU1FTlRfU0VMRUNUT1IgPSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNhYmxlRWxlbWVudHMuam9pbignOm5vdChbaGlkZGVuXSk6bm90KFt0YWJpbmRleD1cIi0xXCJdKSwnKTtcbmZ1bmN0aW9uICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRnZXRTY29wZVJvb3Qoc2NvcGUpIHtcbiAgICByZXR1cm4gc2NvcGVbMF0ucGFyZW50RWxlbWVudDtcbn1cbmZ1bmN0aW9uICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRzaG91bGRDb250YWluRm9jdXMoc2NvcGVSZWYpIHtcbiAgICBsZXQgc2NvcGUgPSAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZS5nZXRUcmVlTm9kZSgkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUpO1xuICAgIHdoaWxlKHNjb3BlICYmIHNjb3BlLnNjb3BlUmVmICE9PSBzY29wZVJlZil7XG4gICAgICAgIGlmIChzY29wZS5jb250YWluKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHNjb3BlID0gc2NvcGUucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uICQ5YmY3MWVhMjg3OTNlNzM4JHZhciR1c2VGb2N1c0NvbnRhaW5tZW50KHNjb3BlUmVmLCBjb250YWluKSB7XG4gICAgbGV0IGZvY3VzZWROb2RlID0gKDAsICQ2bmZGQyR1c2VSZWYpKCk7XG4gICAgbGV0IHJhZiA9ICgwLCAkNm5mRkMkdXNlUmVmKSgpO1xuICAgICgwLCAkNm5mRkMkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICBsZXQgc2NvcGUgPSBzY29wZVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWNvbnRhaW4pIHtcbiAgICAgICAgICAgIC8vIGlmIGNvbnRhaW4gd2FzIGNoYW5nZWQsIHRoZW4gd2Ugc2hvdWxkIGNhbmNlbCBhbnkgb25nb2luZyB3YWl0cyB0byBwdWxsIGZvY3VzIGJhY2sgaW50byBjb250YWlubWVudFxuICAgICAgICAgICAgaWYgKHJhZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIHJhZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgVGFiIGtleSB0byBjb250YWluIGZvY3VzIHdpdGhpbiB0aGUgc2NvcGVcbiAgICAgICAgbGV0IG9uS2V5RG93biA9IChlKT0+e1xuICAgICAgICAgICAgaWYgKGUua2V5ICE9PSBcIlRhYlwiIHx8IGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgISQ5YmY3MWVhMjg3OTNlNzM4JHZhciRzaG91bGRDb250YWluRm9jdXMoc2NvcGVSZWYpKSByZXR1cm47XG4gICAgICAgICAgICBsZXQgZm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgbGV0IHNjb3BlID0gc2NvcGVSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmICghc2NvcGUgfHwgISQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJblNjb3BlKGZvY3VzZWRFbGVtZW50LCBzY29wZSkpIHJldHVybjtcbiAgICAgICAgICAgIGxldCBzY29wZVJvb3QgPSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZ2V0U2NvcGVSb290KHNjb3BlKTtcbiAgICAgICAgICAgIGxldCB3YWxrZXIgPSAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkMmQ2ZWM4ZmMzNzVjZWFmYShzY29wZVJvb3QsIHtcbiAgICAgICAgICAgICAgICB0YWJiYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSwgc2NvcGUpO1xuICAgICAgICAgICAgaWYgKCFmb2N1c2VkRWxlbWVudCkgcmV0dXJuO1xuICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gZm9jdXNlZEVsZW1lbnQ7XG4gICAgICAgICAgICBsZXQgbmV4dEVsZW1lbnQgPSBlLnNoaWZ0S2V5ID8gd2Fsa2VyLnByZXZpb3VzTm9kZSgpIDogd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICBpZiAoIW5leHRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gZS5zaGlmdEtleSA/IHNjb3BlW3Njb3BlLmxlbmd0aCAtIDFdLm5leHRFbGVtZW50U2libGluZyA6IHNjb3BlWzBdLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgbmV4dEVsZW1lbnQgPSBlLnNoaWZ0S2V5ID8gd2Fsa2VyLnByZXZpb3VzTm9kZSgpIDogd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAobmV4dEVsZW1lbnQpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0VsZW1lbnQobmV4dEVsZW1lbnQsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgb25Gb2N1cyA9IChlKT0+e1xuICAgICAgICAgICAgLy8gSWYgZm9jdXNpbmcgYW4gZWxlbWVudCBpbiBhIGNoaWxkIHNjb3BlIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHNjb3BlLCB0aGUgY2hpbGQgYmVjb21lcyBhY3RpdmUuXG4gICAgICAgICAgICAvLyBNb3Zpbmcgb3V0IG9mIHRoZSBhY3RpdmUgc2NvcGUgdG8gYW4gYW5jZXN0b3IgaXMgbm90IGFsbG93ZWQuXG4gICAgICAgICAgICBpZiAoKCEkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUgfHwgJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzQW5jZXN0b3JTY29wZSgkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUsIHNjb3BlUmVmKSkgJiYgJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUoZS50YXJnZXQsIHNjb3BlUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlID0gc2NvcGVSZWY7XG4gICAgICAgICAgICAgICAgZm9jdXNlZE5vZGUuY3VycmVudCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkOWJmNzFlYTI4NzkzZTczOCR2YXIkc2hvdWxkQ29udGFpbkZvY3VzKHNjb3BlUmVmKSAmJiAhJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluQ2hpbGRTY29wZShlLnRhcmdldCwgc2NvcGVSZWYpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBmb2N1cyBldmVudCBvY2N1cnMgb3V0c2lkZSB0aGUgYWN0aXZlIHNjb3BlIChlLmcuIHVzZXIgdGFicyBmcm9tIGJyb3dzZXIgbG9jYXRpb24gYmFyKSxcbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIGZvY3VzIHRvIHRoZSBwcmV2aW91c2x5IGZvY3VzZWQgbm9kZSBvciB0aGUgZmlyc3QgdGFiYmFibGUgZWxlbWVudCBpbiB0aGUgYWN0aXZlIHNjb3BlLlxuICAgICAgICAgICAgICAgIGlmIChmb2N1c2VkTm9kZS5jdXJyZW50KSBmb2N1c2VkTm9kZS5jdXJyZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlICYmICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZS5jdXJyZW50KSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNGaXJzdEluU2NvcGUoJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlLmN1cnJlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkOWJmNzFlYTI4NzkzZTczOCR2YXIkc2hvdWxkQ29udGFpbkZvY3VzKHNjb3BlUmVmKSkgZm9jdXNlZE5vZGUuY3VycmVudCA9IGUudGFyZ2V0O1xuICAgICAgICB9O1xuICAgICAgICBsZXQgb25CbHVyID0gKGUpPT57XG4gICAgICAgICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc2hpZnQgZm9jdXMgYmFjayB0byB0aGUgRGlhbG9nIHByb3Blcmx5IHdpdGhvdXQgdGhpc1xuICAgICAgICAgICAgaWYgKHJhZi5jdXJyZW50KSBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYuY3VycmVudCk7XG4gICAgICAgICAgICByYWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xuICAgICAgICAgICAgICAgIC8vIFVzZSBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluc3RlYWQgb2YgZS5yZWxhdGVkVGFyZ2V0IHNvIHdlIGNhbiB0ZWxsIGlmIHVzZXIgY2xpY2tlZCBpbnRvIGlmcmFtZVxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRzaG91bGRDb250YWluRm9jdXMoc2NvcGVSZWYpICYmICEkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5DaGlsZFNjb3BlKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQsIHNjb3BlUmVmKSkge1xuICAgICAgICAgICAgICAgICAgICAkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUgPSBzY29wZVJlZjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2ZvY3VzZWROb2RlX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c2VkTm9kZS5jdXJyZW50ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2ZvY3VzZWROb2RlX2N1cnJlbnQgPSBmb2N1c2VkTm9kZS5jdXJyZW50KSA9PT0gbnVsbCB8fCBfZm9jdXNlZE5vZGVfY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZvY3VzZWROb2RlX2N1cnJlbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkOWJmNzFlYTI4NzkzZTczOCR2YXIkYWN0aXZlU2NvcGUuY3VycmVudCkgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRmlyc3RJblNjb3BlKCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZS5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duLCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIG9uRm9jdXMsIGZhbHNlKTtcbiAgICAgICAgc2NvcGUgPT09IG51bGwgfHwgc2NvcGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjb3BlLmZvckVhY2goKGVsZW1lbnQpPT5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIG9uRm9jdXMsIGZhbHNlKSk7XG4gICAgICAgIHNjb3BlID09PSBudWxsIHx8IHNjb3BlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY29wZS5mb3JFYWNoKChlbGVtZW50KT0+ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgb25CbHVyLCBmYWxzZSkpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93biwgZmFsc2UpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgb25Gb2N1cywgZmFsc2UpO1xuICAgICAgICAgICAgc2NvcGUgPT09IG51bGwgfHwgc2NvcGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjb3BlLmZvckVhY2goKGVsZW1lbnQpPT5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIG9uRm9jdXMsIGZhbHNlKSk7XG4gICAgICAgICAgICBzY29wZSA9PT0gbnVsbCB8fCBzY29wZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NvcGUuZm9yRWFjaCgoZWxlbWVudCk9PmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIG9uQmx1ciwgZmFsc2UpKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHNjb3BlUmVmLFxuICAgICAgICBjb250YWluXG4gICAgXSk7XG4gICAgLy8gVGhpcyBpcyBhIHVzZUxheW91dEVmZmVjdCBzbyBpdCBpcyBndWFyYW50ZWVkIHRvIHJ1biBiZWZvcmUgb3VyIGFzeW5jIHN5bnRoZXRpYyBibHVyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycm93LWJvZHktc3R5bGVcbiAgICAoMCwgJDZuZkZDJHVzZUxheW91dEVmZmVjdCkoKCk9PntcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAocmFmLmN1cnJlbnQpIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZi5jdXJyZW50KTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHJhZlxuICAgIF0pO1xufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluQW55U2NvcGUoZWxlbWVudCkge1xuICAgIHJldHVybiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5DaGlsZFNjb3BlKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUoZWxlbWVudCwgc2NvcGUpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXNjb3BlKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHNjb3BlLnNvbWUoKG5vZGUpPT5ub2RlLmNvbnRhaW5zKGVsZW1lbnQpKTtcbn1cbmZ1bmN0aW9uICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJbkNoaWxkU2NvcGUoZWxlbWVudCwgc2NvcGUgPSBudWxsKSB7XG4gICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgd2l0aGluIGEgdG9wIGxheWVyIGVsZW1lbnQgKGUuZy4gdG9hc3RzKSwgYWx3YXlzIGFsbG93IG1vdmluZyBmb2N1cyB0aGVyZS5cbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgZWxlbWVudC5jbG9zZXN0KFwiW2RhdGEtcmVhY3QtYXJpYS10b3AtbGF5ZXJdXCIpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub2RlLmNvbnRhaW5zIGluIGlzRWxlbWVudEluU2NvcGUgY292ZXJzIGNoaWxkIHNjb3BlcyB0aGF0IGFyZSBhbHNvIERPTSBjaGlsZHJlbixcbiAgICAvLyBidXQgZG9lcyBub3QgY292ZXIgY2hpbGQgc2NvcGVzIGluIHBvcnRhbHMuXG4gICAgZm9yIChsZXQgeyBzY29wZVJlZjogcyB9IG9mICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLnRyYXZlcnNlKCQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLmdldFRyZWVOb2RlKHNjb3BlKSkpe1xuICAgICAgICBpZiAocyAmJiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5TY29wZShlbGVtZW50LCBzLmN1cnJlbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDEyNTgzOTVmOTliZjljYmYoZWxlbWVudCkge1xuICAgIHJldHVybiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5DaGlsZFNjb3BlKGVsZW1lbnQsICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSk7XG59XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNBbmNlc3RvclNjb3BlKGFuY2VzdG9yLCBzY29wZSkge1xuICAgIHZhciBfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGU7XG4gICAgbGV0IHBhcmVudCA9IChfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGUgPSAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZS5nZXRUcmVlTm9kZShzY29wZSkpID09PSBudWxsIHx8IF9mb2N1c1Njb3BlVHJlZV9nZXRUcmVlTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZvY3VzU2NvcGVUcmVlX2dldFRyZWVOb2RlLnBhcmVudDtcbiAgICB3aGlsZShwYXJlbnQpe1xuICAgICAgICBpZiAocGFyZW50LnNjb3BlUmVmID09PSBhbmNlc3RvcikgcmV0dXJuIHRydWU7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0VsZW1lbnQoZWxlbWVudCwgc2Nyb2xsID0gZmFsc2UpIHtcbiAgICBpZiAoZWxlbWVudCAhPSBudWxsICYmICFzY3JvbGwpIHRyeSB7XG4gICAgICAgICgwLCAkNmE5OTE5NTMzMmVkZWM4YiRleHBvcnQkODBmM2UxNDdkNzgxNTcxYykoZWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gaWdub3JlXG4gICAgfVxuICAgIGVsc2UgaWYgKGVsZW1lbnQgIT0gbnVsbCkgdHJ5IHtcbiAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIGlnbm9yZVxuICAgIH1cbn1cbmZ1bmN0aW9uICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0ZpcnN0SW5TY29wZShzY29wZSwgdGFiYmFibGUgPSB0cnVlKSB7XG4gICAgbGV0IHNlbnRpbmVsID0gc2NvcGVbMF0ucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICBsZXQgc2NvcGVSb290ID0gJDliZjcxZWEyODc5M2U3MzgkdmFyJGdldFNjb3BlUm9vdChzY29wZSk7XG4gICAgbGV0IHdhbGtlciA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhKHNjb3BlUm9vdCwge1xuICAgICAgICB0YWJiYWJsZTogdGFiYmFibGVcbiAgICB9LCBzY29wZSk7XG4gICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gc2VudGluZWw7XG4gICAgbGV0IG5leHROb2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgLy8gSWYgdGhlIHNjb3BlIGRvZXMgbm90IGNvbnRhaW4gYSB0YWJiYWJsZSBlbGVtZW50LCB1c2UgdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50LlxuICAgIGlmICh0YWJiYWJsZSAmJiAhbmV4dE5vZGUpIHtcbiAgICAgICAgc2NvcGVSb290ID0gJDliZjcxZWEyODc5M2U3MzgkdmFyJGdldFNjb3BlUm9vdChzY29wZSk7XG4gICAgICAgIHdhbGtlciA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhKHNjb3BlUm9vdCwge1xuICAgICAgICAgICAgdGFiYmFibGU6IGZhbHNlXG4gICAgICAgIH0sIHNjb3BlKTtcbiAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gc2VudGluZWw7XG4gICAgICAgIG5leHROb2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgfVxuICAgICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0VsZW1lbnQobmV4dE5vZGUpO1xufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkdmFyJHVzZUF1dG9Gb2N1cyhzY29wZVJlZiwgYXV0b0ZvY3VzKSB7XG4gICAgY29uc3QgYXV0b0ZvY3VzUmVmID0gKDAsICQ2bmZGQyRyZWFjdCkudXNlUmVmKGF1dG9Gb2N1cyk7XG4gICAgKDAsICQ2bmZGQyR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChhdXRvRm9jdXNSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlID0gc2NvcGVSZWY7XG4gICAgICAgICAgICBpZiAoISQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJblNjb3BlKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQsICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZS5jdXJyZW50KSAmJiBzY29wZVJlZi5jdXJyZW50KSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNGaXJzdEluU2NvcGUoc2NvcGVSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgYXV0b0ZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LCBbXG4gICAgICAgIHNjb3BlUmVmXG4gICAgXSk7XG59XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkdXNlQWN0aXZlU2NvcGVUcmFja2VyKHNjb3BlUmVmLCByZXN0b3JlLCBjb250YWluKSB7XG4gICAgLy8gdHJhY2tzIHRoZSBhY3RpdmUgc2NvcGUsIGluIGNhc2UgcmVzdG9yZSBhbmQgY29udGFpbiBhcmUgYm90aCBmYWxzZS5cbiAgICAvLyBpZiBlaXRoZXIgYXJlIHRydWUsIHRoaXMgaXMgdHJhY2tlZCBpbiB1c2VSZXN0b3JlRm9jdXMgb3IgdXNlRm9jdXNDb250YWlubWVudC5cbiAgICAoMCwgJDZuZkZDJHVzZUxheW91dEVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKHJlc3RvcmUgfHwgY29udGFpbikgcmV0dXJuO1xuICAgICAgICBsZXQgc2NvcGUgPSBzY29wZVJlZi5jdXJyZW50O1xuICAgICAgICBsZXQgb25Gb2N1cyA9IChlKT0+e1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJblNjb3BlKHRhcmdldCwgc2NvcGVSZWYuY3VycmVudCkpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSA9IHNjb3BlUmVmO1xuICAgICAgICAgICAgZWxzZSBpZiAoISQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0VsZW1lbnRJbkFueVNjb3BlKHRhcmdldCkpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIG9uRm9jdXMsIGZhbHNlKTtcbiAgICAgICAgc2NvcGUgPT09IG51bGwgfHwgc2NvcGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjb3BlLmZvckVhY2goKGVsZW1lbnQpPT5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIG9uRm9jdXMsIGZhbHNlKSk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgb25Gb2N1cywgZmFsc2UpO1xuICAgICAgICAgICAgc2NvcGUgPT09IG51bGwgfHwgc2NvcGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjb3BlLmZvckVhY2goKGVsZW1lbnQpPT5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIG9uRm9jdXMsIGZhbHNlKSk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBzY29wZVJlZixcbiAgICAgICAgcmVzdG9yZSxcbiAgICAgICAgY29udGFpblxuICAgIF0pO1xufVxuZnVuY3Rpb24gJDliZjcxZWEyODc5M2U3MzgkdmFyJHNob3VsZFJlc3RvcmVGb2N1cyhzY29wZVJlZikge1xuICAgIGxldCBzY29wZSA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLmdldFRyZWVOb2RlKCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSk7XG4gICAgd2hpbGUoc2NvcGUgJiYgc2NvcGUuc2NvcGVSZWYgIT09IHNjb3BlUmVmKXtcbiAgICAgICAgaWYgKHNjb3BlLm5vZGVUb1Jlc3RvcmUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgc2NvcGUgPSBzY29wZS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiAoc2NvcGUgPT09IG51bGwgfHwgc2NvcGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjb3BlLnNjb3BlUmVmKSA9PT0gc2NvcGVSZWY7XG59XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkdXNlUmVzdG9yZUZvY3VzKHNjb3BlUmVmLCByZXN0b3JlRm9jdXMsIGNvbnRhaW4pIHtcbiAgICAvLyBjcmVhdGUgYSByZWYgZHVyaW5nIHJlbmRlciBpbnN0ZWFkIG9mIHVzZUxheW91dEVmZmVjdCBzbyB0aGUgYWN0aXZlIGVsZW1lbnQgaXMgc2F2ZWQgYmVmb3JlIGEgY2hpbGQgd2l0aCBhdXRvRm9jdXM9dHJ1ZSBtb3VudHMuXG4gICAgY29uc3Qgbm9kZVRvUmVzdG9yZVJlZiA9ICgwLCAkNm5mRkMkdXNlUmVmKSh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IDogbnVsbCk7XG4gICAgLy8gcmVzdG9yaW5nIHNjb3BlcyBzaG91bGQgYWxsIHRyYWNrIGlmIHRoZXkgYXJlIGFjdGl2ZSByZWdhcmRsZXNzIG9mIGNvbnRhaW4sIGJ1dCBjb250YWluIGFscmVhZHkgdHJhY2tzIGl0IHBsdXMgbG9naWMgdG8gY29udGFpbiB0aGUgZm9jdXNcbiAgICAvLyByZXN0b3Jpbmctbm9uLWNvbnRhaW5pbmcgc2NvcGVzIHNob3VsZCBvbmx5IGNhcmUgaWYgdGhleSBiZWNvbWUgYWN0aXZlIHNvIHRoZXkgY2FuIHBlcmZvcm0gdGhlIHJlc3RvcmVcbiAgICAoMCwgJDZuZkZDJHVzZUxheW91dEVmZmVjdCkoKCk9PntcbiAgICAgICAgbGV0IHNjb3BlID0gc2NvcGVSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFyZXN0b3JlRm9jdXMgfHwgY29udGFpbikgcmV0dXJuO1xuICAgICAgICBsZXQgb25Gb2N1cyA9ICgpPT57XG4gICAgICAgICAgICAvLyBJZiBmb2N1c2luZyBhbiBlbGVtZW50IGluIGEgY2hpbGQgc2NvcGUgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2NvcGUsIHRoZSBjaGlsZCBiZWNvbWVzIGFjdGl2ZS5cbiAgICAgICAgICAgIC8vIE1vdmluZyBvdXQgb2YgdGhlIGFjdGl2ZSBzY29wZSB0byBhbiBhbmNlc3RvciBpcyBub3QgYWxsb3dlZC5cbiAgICAgICAgICAgIGlmICgoISQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSB8fCAkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNBbmNlc3RvclNjb3BlKCQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSwgc2NvcGVSZWYpKSAmJiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5TY29wZShkb2N1bWVudC5hY3RpdmVFbGVtZW50LCBzY29wZVJlZi5jdXJyZW50KSkgJDliZjcxZWEyODc5M2U3MzgkdmFyJGFjdGl2ZVNjb3BlID0gc2NvcGVSZWY7XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIG9uRm9jdXMsIGZhbHNlKTtcbiAgICAgICAgc2NvcGUgPT09IG51bGwgfHwgc2NvcGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjb3BlLmZvckVhY2goKGVsZW1lbnQpPT5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIG9uRm9jdXMsIGZhbHNlKSk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgb25Gb2N1cywgZmFsc2UpO1xuICAgICAgICAgICAgc2NvcGUgPT09IG51bGwgfHwgc2NvcGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjb3BlLmZvckVhY2goKGVsZW1lbnQpPT5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIG9uRm9jdXMsIGZhbHNlKSk7XG4gICAgICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtcbiAgICAgICAgc2NvcGVSZWYsXG4gICAgICAgIGNvbnRhaW5cbiAgICBdKTtcbiAgICAoMCwgJDZuZkZDJHVzZUxheW91dEVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKCFyZXN0b3JlRm9jdXMpIHJldHVybjtcbiAgICAgICAgLy8gSGFuZGxlIHRoZSBUYWIga2V5IHNvIHRoYXQgdGFiYmluZyBvdXQgb2YgdGhlIHNjb3BlIGdvZXMgdG8gdGhlIG5leHQgZWxlbWVudFxuICAgICAgICAvLyBhZnRlciB0aGUgbm9kZSB0aGF0IGhhZCBmb2N1cyB3aGVuIHRoZSBzY29wZSBtb3VudGVkLiBUaGlzIGlzIGltcG9ydGFudCB3aGVuXG4gICAgICAgIC8vIHVzaW5nIHBvcnRhbHMgZm9yIG92ZXJsYXlzLCBzbyB0aGF0IGZvY3VzIGdvZXMgdG8gdGhlIGV4cGVjdGVkIGVsZW1lbnQgd2hlblxuICAgICAgICAvLyB0YWJiaW5nIG91dCBvZiB0aGUgb3ZlcmxheS5cbiAgICAgICAgbGV0IG9uS2V5RG93biA9IChlKT0+e1xuICAgICAgICAgICAgaWYgKGUua2V5ICE9PSBcIlRhYlwiIHx8IGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgISQ5YmY3MWVhMjg3OTNlNzM4JHZhciRzaG91bGRDb250YWluRm9jdXMoc2NvcGVSZWYpKSByZXR1cm47XG4gICAgICAgICAgICBsZXQgZm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKCEkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5TY29wZShmb2N1c2VkRWxlbWVudCwgc2NvcGVSZWYuY3VycmVudCkpIHJldHVybjtcbiAgICAgICAgICAgIGxldCB0cmVlTm9kZSA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLmdldFRyZWVOb2RlKHNjb3BlUmVmKTtcbiAgICAgICAgICAgIGlmICghdHJlZU5vZGUpIHJldHVybjtcbiAgICAgICAgICAgIGxldCBub2RlVG9SZXN0b3JlID0gdHJlZU5vZGUubm9kZVRvUmVzdG9yZTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIERPTSB0cmVlIHdhbGtlciB0aGF0IG1hdGNoZXMgYWxsIHRhYmJhYmxlIGVsZW1lbnRzXG4gICAgICAgICAgICBsZXQgd2Fsa2VyID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDJkNmVjOGZjMzc1Y2VhZmEoZG9jdW1lbnQuYm9keSwge1xuICAgICAgICAgICAgICAgIHRhYmJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIG5leHQgdGFiYmFibGUgZWxlbWVudCBhZnRlciB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudFxuICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gZm9jdXNlZEVsZW1lbnQ7XG4gICAgICAgICAgICBsZXQgbmV4dEVsZW1lbnQgPSBlLnNoaWZ0S2V5ID8gd2Fsa2VyLnByZXZpb3VzTm9kZSgpIDogd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICBpZiAoIW5vZGVUb1Jlc3RvcmUgfHwgIWRvY3VtZW50LmJvZHkuY29udGFpbnMobm9kZVRvUmVzdG9yZSkgfHwgbm9kZVRvUmVzdG9yZSA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgIG5vZGVUb1Jlc3RvcmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdHJlZU5vZGUubm9kZVRvUmVzdG9yZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG5leHQgZWxlbWVudCwgb3IgaXQgaXMgb3V0c2lkZSB0aGUgY3VycmVudCBzY29wZSwgbW92ZSBmb2N1cyB0byB0aGVcbiAgICAgICAgICAgIC8vIG5leHQgZWxlbWVudCBhZnRlciB0aGUgbm9kZSB0byByZXN0b3JlIHRvIGluc3RlYWQuXG4gICAgICAgICAgICBpZiAoKCFuZXh0RWxlbWVudCB8fCAhJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUobmV4dEVsZW1lbnQsIHNjb3BlUmVmLmN1cnJlbnQpKSAmJiBub2RlVG9SZXN0b3JlKSB7XG4gICAgICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gbm9kZVRvUmVzdG9yZTtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIG92ZXIgZWxlbWVudHMgd2l0aGluIHRoZSBzY29wZSwgaW4gY2FzZSB0aGUgc2NvcGUgaW1tZWRpYXRlbHkgZm9sbG93cyB0aGUgbm9kZSB0byByZXN0b3JlLlxuICAgICAgICAgICAgICAgIGRvIG5leHRFbGVtZW50ID0gZS5zaGlmdEtleSA/IHdhbGtlci5wcmV2aW91c05vZGUoKSA6IHdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgICAgICAgICAgIHdoaWxlICgkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5TY29wZShuZXh0RWxlbWVudCwgc2NvcGVSZWYuY3VycmVudCkpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0RWxlbWVudCkgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRWxlbWVudChuZXh0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSAvLyBJZiB0aGVyZSBpcyBubyBuZXh0IGVsZW1lbnQgYW5kIHRoZSBub2RlVG9SZXN0b3JlIGlzbid0IHdpdGhpbiBhIEZvY3VzU2NvcGUgKGkuZS4gd2UgYXJlIGxlYXZpbmcgdGhlIHRvcCBsZXZlbCBmb2N1cyBzY29wZSlcbiAgICAgICAgICAgICAgICAvLyB0aGVuIG1vdmUgZm9jdXMgdG8gdGhlIGJvZHkuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHJlc3RvcmUgZm9jdXMgdG8gdGhlIG5vZGVUb1Jlc3RvcmUgKGUuZyBtZW51IHdpdGhpbiBhIHBvcG92ZXIgLT4gdGFiYmluZyB0byBjbG9zZSB0aGUgbWVudSBzaG91bGQgbW92ZSBmb2N1cyB0byBtZW51IHRyaWdnZXIpXG4gICAgICAgICAgICAgICAgaWYgKCEkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5BbnlTY29wZShub2RlVG9SZXN0b3JlKSkgZm9jdXNlZEVsZW1lbnQuYmx1cigpO1xuICAgICAgICAgICAgICAgIGVsc2UgJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRWxlbWVudChub2RlVG9SZXN0b3JlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFjb250YWluKSBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24sIHRydWUpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGlmICghY29udGFpbikgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHNjb3BlUmVmLFxuICAgICAgICByZXN0b3JlRm9jdXMsXG4gICAgICAgIGNvbnRhaW5cbiAgICBdKTtcbiAgICAvLyB1c2VMYXlvdXRFZmZlY3QgaW5zdGVhZCBvZiB1c2VFZmZlY3Qgc28gdGhlIGFjdGl2ZSBlbGVtZW50IGlzIHNhdmVkIHN5bmNocm9ub3VzbHkgaW5zdGVhZCBvZiBhc3luY2hyb25vdXNseS5cbiAgICAoMCwgJDZuZkZDJHVzZUxheW91dEVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKCFyZXN0b3JlRm9jdXMpIHJldHVybjtcbiAgICAgICAgbGV0IHRyZWVOb2RlID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUuZ2V0VHJlZU5vZGUoc2NvcGVSZWYpO1xuICAgICAgICBpZiAoIXRyZWVOb2RlKSByZXR1cm47XG4gICAgICAgIHZhciBfbm9kZVRvUmVzdG9yZVJlZl9jdXJyZW50O1xuICAgICAgICB0cmVlTm9kZS5ub2RlVG9SZXN0b3JlID0gKF9ub2RlVG9SZXN0b3JlUmVmX2N1cnJlbnQgPSBub2RlVG9SZXN0b3JlUmVmLmN1cnJlbnQpICE9PSBudWxsICYmIF9ub2RlVG9SZXN0b3JlUmVmX2N1cnJlbnQgIT09IHZvaWQgMCA/IF9ub2RlVG9SZXN0b3JlUmVmX2N1cnJlbnQgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgbGV0IHRyZWVOb2RlID0gJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGQwNmZhZTJlZTY4YjEwMWUuZ2V0VHJlZU5vZGUoc2NvcGVSZWYpO1xuICAgICAgICAgICAgaWYgKCF0cmVlTm9kZSkgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IG5vZGVUb1Jlc3RvcmUgPSB0cmVlTm9kZS5ub2RlVG9SZXN0b3JlO1xuICAgICAgICAgICAgLy8gaWYgd2UgYWxyZWFkeSBsb3N0IGZvY3VzIHRvIHRoZSBib2R5IGFuZCB0aGlzIHdhcyB0aGUgYWN0aXZlIHNjb3BlLCB0aGVuIHdlIHNob3VsZCBhdHRlbXB0IHRvIHJlc3RvcmVcbiAgICAgICAgICAgIGlmIChyZXN0b3JlRm9jdXMgJiYgbm9kZVRvUmVzdG9yZSAmJiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICAgICAgICAoJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCwgc2NvcGVSZWYuY3VycmVudCkgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSAmJiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkc2hvdWxkUmVzdG9yZUZvY3VzKHNjb3BlUmVmKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBmcmVlemUgdGhlIGZvY3VzU2NvcGVUcmVlIHNvIGl0IHBlcnNpc3RzIGFmdGVyIHRoZSByYWYsIG90aGVyd2lzZSBkdXJpbmcgdW5tb3VudCBub2RlcyBhcmUgcmVtb3ZlZCBmcm9tIGl0XG4gICAgICAgICAgICAgICAgbGV0IGNsb25lZFRyZWUgPSAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHJlc3RvcmUgZm9jdXMgaWYgd2UndmUgbG9zdCBmb2N1cyB0byB0aGUgYm9keSwgdGhlIGFsdGVybmF0aXZlIGlzIHRoYXQgZm9jdXMgaGFzIGJlZW4gcHVycG9zZWZ1bGx5IG1vdmVkIGVsc2V3aGVyZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9vayB1cCB0aGUgdHJlZSBzdGFydGluZyB3aXRoIG91ciBzY29wZSB0byBmaW5kIGEgbm9kZVRvUmVzdG9yZSBzdGlsbCBpbiB0aGUgRE9NXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHJlZU5vZGUgPSBjbG9uZWRUcmVlLmdldFRyZWVOb2RlKHNjb3BlUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKHRyZWVOb2RlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJlZU5vZGUubm9kZVRvUmVzdG9yZSAmJiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRyZWVOb2RlLm5vZGVUb1Jlc3RvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0VsZW1lbnQodHJlZU5vZGUubm9kZVRvUmVzdG9yZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZU5vZGUgPSB0cmVlTm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBub2RlVG9SZXN0b3JlIHdhcyBmb3VuZCwgZm9jdXMgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIG5lYXJlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuY2VzdG9yIHNjb3BlIHRoYXQgaXMgc3RpbGwgaW4gdGhlIHRyZWUuXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlTm9kZSA9IGNsb25lZFRyZWUuZ2V0VHJlZU5vZGUoc2NvcGVSZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUodHJlZU5vZGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmVlTm9kZS5zY29wZVJlZiAmJiB0cmVlTm9kZS5zY29wZVJlZi5jdXJyZW50ICYmICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlLmdldFRyZWVOb2RlKHRyZWVOb2RlLnNjb3BlUmVmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNGaXJzdEluU2NvcGUodHJlZU5vZGUuc2NvcGVSZWYuY3VycmVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZU5vZGUgPSB0cmVlTm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHNjb3BlUmVmLFxuICAgICAgICByZXN0b3JlRm9jdXNcbiAgICBdKTtcbn1cbmZ1bmN0aW9uICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhKHJvb3QsIG9wdHMsIHNjb3BlKSB7XG4gICAgbGV0IHNlbGVjdG9yID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy50YWJiYWJsZSkgPyAkOWJmNzFlYTI4NzkzZTczOCR2YXIkVEFCQkFCTEVfRUxFTUVOVF9TRUxFQ1RPUiA6ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRGT0NVU0FCTEVfRUxFTUVOVF9TRUxFQ1RPUjtcbiAgICBsZXQgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihyb290LCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCwge1xuICAgICAgICBhY2NlcHROb2RlIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgX29wdHNfZnJvbTtcbiAgICAgICAgICAgIC8vIFNraXAgbm9kZXMgaW5zaWRlIHRoZSBzdGFydGluZyBub2RlLlxuICAgICAgICAgICAgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9vcHRzX2Zyb20gPSBvcHRzLmZyb20pID09PSBudWxsIHx8IF9vcHRzX2Zyb20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRzX2Zyb20uY29udGFpbnMobm9kZSkpIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1Q7XG4gICAgICAgICAgICBpZiAobm9kZS5tYXRjaGVzKHNlbGVjdG9yKSAmJiAoMCwgJDY0NWYyZTY3Yjg1YTI0YzkkZXhwb3J0JGU5ODljMGZmZmFhNmIyN2EpKG5vZGUpICYmICghc2NvcGUgfHwgJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUobm9kZSwgc2NvcGUpKSAmJiAoIShvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuYWNjZXB0KSB8fCBvcHRzLmFjY2VwdChub2RlKSkpIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7XG4gICAgICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuZnJvbSkgd2Fsa2VyLmN1cnJlbnROb2RlID0gb3B0cy5mcm9tO1xuICAgIHJldHVybiB3YWxrZXI7XG59XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkYzUyNTFiOWUxMjRiZjI5KHJlZiwgZGVmYXVsdE9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvY3VzTmV4dCAob3B0cyA9IHt9KSB7XG4gICAgICAgICAgICBsZXQgcm9vdCA9IHJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKCFyb290KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCB7IGZyb206IGZyb20sIHRhYmJhYmxlOiB0YWJiYWJsZSA9IGRlZmF1bHRPcHRpb25zLnRhYmJhYmxlLCB3cmFwOiB3cmFwID0gZGVmYXVsdE9wdGlvbnMud3JhcCwgYWNjZXB0OiBhY2NlcHQgPSBkZWZhdWx0T3B0aW9ucy5hY2NlcHQgfSA9IG9wdHM7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGZyb20gfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGxldCB3YWxrZXIgPSAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkMmQ2ZWM4ZmMzNzVjZWFmYShyb290LCB7XG4gICAgICAgICAgICAgICAgdGFiYmFibGU6IHRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGFjY2VwdDogYWNjZXB0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyb290LmNvbnRhaW5zKG5vZGUpKSB3YWxrZXIuY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgbGV0IG5leHROb2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICBpZiAoIW5leHROb2RlICYmIHdyYXApIHtcbiAgICAgICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSByb290O1xuICAgICAgICAgICAgICAgIG5leHROb2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dE5vZGUpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0VsZW1lbnQobmV4dE5vZGUsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5leHROb2RlO1xuICAgICAgICB9LFxuICAgICAgICBmb2N1c1ByZXZpb3VzIChvcHRzID0gZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCByb290ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoIXJvb3QpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IHsgZnJvbTogZnJvbSwgdGFiYmFibGU6IHRhYmJhYmxlID0gZGVmYXVsdE9wdGlvbnMudGFiYmFibGUsIHdyYXA6IHdyYXAgPSBkZWZhdWx0T3B0aW9ucy53cmFwLCBhY2NlcHQ6IGFjY2VwdCA9IGRlZmF1bHRPcHRpb25zLmFjY2VwdCB9ID0gb3B0cztcbiAgICAgICAgICAgIGxldCBub2RlID0gZnJvbSB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgbGV0IHdhbGtlciA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhKHJvb3QsIHtcbiAgICAgICAgICAgICAgICB0YWJiYWJsZTogdGFiYmFibGUsXG4gICAgICAgICAgICAgICAgYWNjZXB0OiBhY2NlcHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJvb3QuY29udGFpbnMobm9kZSkpIHdhbGtlci5jdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRsYXN0KHdhbGtlcik7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0VsZW1lbnQobmV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQgIT09IG51bGwgJiYgbmV4dCAhPT0gdm9pZCAwID8gbmV4dCA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNOb2RlID0gd2Fsa2VyLnByZXZpb3VzTm9kZSgpO1xuICAgICAgICAgICAgaWYgKCFwcmV2aW91c05vZGUgJiYgd3JhcCkge1xuICAgICAgICAgICAgICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3ROb2RlID0gJDliZjcxZWEyODc5M2U3MzgkdmFyJGxhc3Qod2Fsa2VyKTtcbiAgICAgICAgICAgICAgICBpZiAoIWxhc3ROb2RlKSAvLyBjb3VsZG4ndCB3cmFwXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gbGFzdE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldmlvdXNOb2RlKSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNFbGVtZW50KHByZXZpb3VzTm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNOb2RlICE9PSBudWxsICYmIHByZXZpb3VzTm9kZSAhPT0gdm9pZCAwID8gcHJldmlvdXNOb2RlIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXNGaXJzdCAob3B0cyA9IGRlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgICAgICBsZXQgcm9vdCA9IHJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKCFyb290KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCB7IHRhYmJhYmxlOiB0YWJiYWJsZSA9IGRlZmF1bHRPcHRpb25zLnRhYmJhYmxlLCBhY2NlcHQ6IGFjY2VwdCA9IGRlZmF1bHRPcHRpb25zLmFjY2VwdCB9ID0gb3B0cztcbiAgICAgICAgICAgIGxldCB3YWxrZXIgPSAkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkMmQ2ZWM4ZmMzNzVjZWFmYShyb290LCB7XG4gICAgICAgICAgICAgICAgdGFiYmFibGU6IHRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGFjY2VwdDogYWNjZXB0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBuZXh0Tm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgICAgICAgaWYgKG5leHROb2RlKSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkZm9jdXNFbGVtZW50KG5leHROb2RlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0Tm9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXNMYXN0IChvcHRzID0gZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCByb290ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoIXJvb3QpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IHsgdGFiYmFibGU6IHRhYmJhYmxlID0gZGVmYXVsdE9wdGlvbnMudGFiYmFibGUsIGFjY2VwdDogYWNjZXB0ID0gZGVmYXVsdE9wdGlvbnMuYWNjZXB0IH0gPSBvcHRzO1xuICAgICAgICAgICAgbGV0IHdhbGtlciA9ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhKHJvb3QsIHtcbiAgICAgICAgICAgICAgICB0YWJiYWJsZTogdGFiYmFibGUsXG4gICAgICAgICAgICAgICAgYWNjZXB0OiBhY2NlcHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IG5leHQgPSAkOWJmNzFlYTI4NzkzZTczOCR2YXIkbGFzdCh3YWxrZXIpO1xuICAgICAgICAgICAgaWYgKG5leHQpICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0VsZW1lbnQobmV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCAhPT0gbnVsbCAmJiBuZXh0ICE9PSB2b2lkIDAgPyBuZXh0IDogbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkbGFzdCh3YWxrZXIpIHtcbiAgICBsZXQgbmV4dCA9IHVuZGVmaW5lZDtcbiAgICBsZXQgbGFzdDtcbiAgICBkbyB7XG4gICAgICAgIGxhc3QgPSB3YWxrZXIubGFzdENoaWxkKCk7XG4gICAgICAgIGlmIChsYXN0KSBuZXh0ID0gbGFzdDtcbiAgICB9d2hpbGUgKGxhc3QpO1xuICAgIHJldHVybiBuZXh0O1xufVxuY2xhc3MgJDliZjcxZWEyODc5M2U3MzgkdmFyJFRyZWUge1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mYXN0TWFwLnNpemU7XG4gICAgfVxuICAgIGdldFRyZWVOb2RlKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFzdE1hcC5nZXQoZGF0YSk7XG4gICAgfVxuICAgIGFkZFRyZWVOb2RlKHNjb3BlUmVmLCBwYXJlbnQsIG5vZGVUb1Jlc3RvcmUpIHtcbiAgICAgICAgbGV0IHBhcmVudE5vZGUgPSB0aGlzLmZhc3RNYXAuZ2V0KHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQgIT09IHZvaWQgMCA/IHBhcmVudCA6IG51bGwpO1xuICAgICAgICBpZiAoIXBhcmVudE5vZGUpIHJldHVybjtcbiAgICAgICAgbGV0IG5vZGUgPSBuZXcgJDliZjcxZWEyODc5M2U3MzgkdmFyJFRyZWVOb2RlKHtcbiAgICAgICAgICAgIHNjb3BlUmVmOiBzY29wZVJlZlxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50Tm9kZS5hZGRDaGlsZChub2RlKTtcbiAgICAgICAgbm9kZS5wYXJlbnQgPSBwYXJlbnROb2RlO1xuICAgICAgICB0aGlzLmZhc3RNYXAuc2V0KHNjb3BlUmVmLCBub2RlKTtcbiAgICAgICAgaWYgKG5vZGVUb1Jlc3RvcmUpIG5vZGUubm9kZVRvUmVzdG9yZSA9IG5vZGVUb1Jlc3RvcmU7XG4gICAgfVxuICAgIGFkZE5vZGUobm9kZSkge1xuICAgICAgICB0aGlzLmZhc3RNYXAuc2V0KG5vZGUuc2NvcGVSZWYsIG5vZGUpO1xuICAgIH1cbiAgICByZW1vdmVUcmVlTm9kZShzY29wZVJlZikge1xuICAgICAgICAvLyBuZXZlciByZW1vdmUgdGhlIHJvb3RcbiAgICAgICAgaWYgKHNjb3BlUmVmID09PSBudWxsKSByZXR1cm47XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5mYXN0TWFwLmdldChzY29wZVJlZik7XG4gICAgICAgIGlmICghbm9kZSkgcmV0dXJuO1xuICAgICAgICBsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICAvLyB3aGVuIHdlIHJlbW92ZSBhIHNjb3BlLCBjaGVjayBpZiBhbnkgc2libGluZyBzY29wZXMgYXJlIHRyeWluZyB0byByZXN0b3JlIGZvY3VzIHRvIHNvbWV0aGluZyBpbnNpZGUgdGhlIHNjb3BlIHdlJ3JlIHJlbW92aW5nXG4gICAgICAgIC8vIGlmIHdlIGFyZSwgdGhlbiByZXBsYWNlIHRoZSBzaWJsaW5ncyByZXN0b3JlIHdpdGggdGhlIHJlc3RvcmUgZnJvbSB0aGUgc2NvcGUgd2UncmUgcmVtb3ZpbmdcbiAgICAgICAgZm9yIChsZXQgY3VycmVudCBvZiB0aGlzLnRyYXZlcnNlKCkpaWYgKGN1cnJlbnQgIT09IG5vZGUgJiYgbm9kZS5ub2RlVG9SZXN0b3JlICYmIGN1cnJlbnQubm9kZVRvUmVzdG9yZSAmJiBub2RlLnNjb3BlUmVmICYmIG5vZGUuc2NvcGVSZWYuY3VycmVudCAmJiAkOWJmNzFlYTI4NzkzZTczOCR2YXIkaXNFbGVtZW50SW5TY29wZShjdXJyZW50Lm5vZGVUb1Jlc3RvcmUsIG5vZGUuc2NvcGVSZWYuY3VycmVudCkpIGN1cnJlbnQubm9kZVRvUmVzdG9yZSA9IG5vZGUubm9kZVRvUmVzdG9yZTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4uc2l6ZSA+IDApIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKT0+cGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmFkZENoaWxkKGNoaWxkKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mYXN0TWFwLmRlbGV0ZShub2RlLnNjb3BlUmVmKTtcbiAgICB9XG4gICAgLy8gUHJlIE9yZGVyIERlcHRoIEZpcnN0XG4gICAgKnRyYXZlcnNlKG5vZGUgPSB0aGlzLnJvb3QpIHtcbiAgICAgICAgaWYgKG5vZGUuc2NvcGVSZWYgIT0gbnVsbCkgeWllbGQgbm9kZTtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4uc2l6ZSA+IDApIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4peWllbGQqIHRoaXMudHJhdmVyc2UoY2hpbGQpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgdmFyIF9ub2RlX3BhcmVudDtcbiAgICAgICAgbGV0IG5ld1RyZWUgPSBuZXcgJDliZjcxZWEyODc5M2U3MzgkdmFyJFRyZWUoKTtcbiAgICAgICAgdmFyIF9ub2RlX3BhcmVudF9zY29wZVJlZjtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiB0aGlzLnRyYXZlcnNlKCkpbmV3VHJlZS5hZGRUcmVlTm9kZShub2RlLnNjb3BlUmVmLCAoX25vZGVfcGFyZW50X3Njb3BlUmVmID0gKF9ub2RlX3BhcmVudCA9IG5vZGUucGFyZW50KSA9PT0gbnVsbCB8fCBfbm9kZV9wYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlX3BhcmVudC5zY29wZVJlZikgIT09IG51bGwgJiYgX25vZGVfcGFyZW50X3Njb3BlUmVmICE9PSB2b2lkIDAgPyBfbm9kZV9wYXJlbnRfc2NvcGVSZWYgOiBudWxsLCBub2RlLm5vZGVUb1Jlc3RvcmUpO1xuICAgICAgICByZXR1cm4gbmV3VHJlZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5mYXN0TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJvb3QgPSBuZXcgJDliZjcxZWEyODc5M2U3MzgkdmFyJFRyZWVOb2RlKHtcbiAgICAgICAgICAgIHNjb3BlUmVmOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZhc3RNYXAuc2V0KG51bGwsIHRoaXMucm9vdCk7XG4gICAgfVxufVxuY2xhc3MgJDliZjcxZWEyODc5M2U3MzgkdmFyJFRyZWVOb2RlIHtcbiAgICBhZGRDaGlsZChub2RlKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uYWRkKG5vZGUpO1xuICAgICAgICBub2RlLnBhcmVudCA9IHRoaXM7XG4gICAgfVxuICAgIHJlbW92ZUNoaWxkKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5kZWxldGUobm9kZSk7XG4gICAgICAgIG5vZGUucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcyl7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuY29udGFpbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNjb3BlUmVmID0gcHJvcHMuc2NvcGVSZWY7XG4gICAgfVxufVxubGV0ICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCRkMDZmYWUyZWU2OGIxMDFlID0gbmV3ICQ5YmY3MWVhMjg3OTNlNzM4JHZhciRUcmVlKCk7XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cblxuXG5mdW5jdGlvbiAkZjdkY2VmZmM1YWQ3NzY4YiRleHBvcnQkNGUzMjhmNjFjNTM4Njg3Zihwcm9wcyA9IHt9KSB7XG4gICAgbGV0IHsgYXV0b0ZvY3VzOiBhdXRvRm9jdXMgPSBmYWxzZSwgaXNUZXh0SW5wdXQ6IGlzVGV4dElucHV0LCB3aXRoaW46IHdpdGhpbiB9ID0gcHJvcHM7XG4gICAgbGV0IHN0YXRlID0gKDAsICQ2bmZGQyR1c2VSZWYpKHtcbiAgICAgICAgaXNGb2N1c2VkOiBmYWxzZSxcbiAgICAgICAgaXNGb2N1c1Zpc2libGU6IGF1dG9Gb2N1cyB8fCAoMCwgJDZuZkZDJGlzRm9jdXNWaXNpYmxlKSgpXG4gICAgfSk7XG4gICAgbGV0IFtpc0ZvY3VzZWQsIHNldEZvY3VzZWRdID0gKDAsICQ2bmZGQyR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGxldCBbaXNGb2N1c1Zpc2libGVTdGF0ZSwgc2V0Rm9jdXNWaXNpYmxlXSA9ICgwLCAkNm5mRkMkdXNlU3RhdGUpKCgpPT5zdGF0ZS5jdXJyZW50LmlzRm9jdXNlZCAmJiBzdGF0ZS5jdXJyZW50LmlzRm9jdXNWaXNpYmxlKTtcbiAgICBsZXQgdXBkYXRlU3RhdGUgPSAoMCwgJDZuZkZDJHVzZUNhbGxiYWNrKSgoKT0+c2V0Rm9jdXNWaXNpYmxlKHN0YXRlLmN1cnJlbnQuaXNGb2N1c2VkICYmIHN0YXRlLmN1cnJlbnQuaXNGb2N1c1Zpc2libGUpLCBbXSk7XG4gICAgbGV0IG9uRm9jdXNDaGFuZ2UgPSAoMCwgJDZuZkZDJHVzZUNhbGxiYWNrKSgoaXNGb2N1c2VkKT0+e1xuICAgICAgICBzdGF0ZS5jdXJyZW50LmlzRm9jdXNlZCA9IGlzRm9jdXNlZDtcbiAgICAgICAgc2V0Rm9jdXNlZChpc0ZvY3VzZWQpO1xuICAgICAgICB1cGRhdGVTdGF0ZSgpO1xuICAgIH0sIFtcbiAgICAgICAgdXBkYXRlU3RhdGVcbiAgICBdKTtcbiAgICAoMCwgJDZuZkZDJHVzZUZvY3VzVmlzaWJsZUxpc3RlbmVyKSgoaXNGb2N1c1Zpc2libGUpPT57XG4gICAgICAgIHN0YXRlLmN1cnJlbnQuaXNGb2N1c1Zpc2libGUgPSBpc0ZvY3VzVmlzaWJsZTtcbiAgICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICB9LCBbXSwge1xuICAgICAgICBpc1RleHRJbnB1dDogaXNUZXh0SW5wdXRcbiAgICB9KTtcbiAgICBsZXQgeyBmb2N1c1Byb3BzOiBmb2N1c1Byb3BzIH0gPSAoMCwgJDZuZkZDJHVzZUZvY3VzKSh7XG4gICAgICAgIGlzRGlzYWJsZWQ6IHdpdGhpbixcbiAgICAgICAgb25Gb2N1c0NoYW5nZTogb25Gb2N1c0NoYW5nZVxuICAgIH0pO1xuICAgIGxldCB7IGZvY3VzV2l0aGluUHJvcHM6IGZvY3VzV2l0aGluUHJvcHMgfSA9ICgwLCAkNm5mRkMkdXNlRm9jdXNXaXRoaW4pKHtcbiAgICAgICAgaXNEaXNhYmxlZDogIXdpdGhpbixcbiAgICAgICAgb25Gb2N1c1dpdGhpbkNoYW5nZTogb25Gb2N1c0NoYW5nZVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzRm9jdXNlZDogaXNGb2N1c2VkLFxuICAgICAgICBpc0ZvY3VzVmlzaWJsZTogaXNGb2N1c1Zpc2libGVTdGF0ZSxcbiAgICAgICAgZm9jdXNQcm9wczogd2l0aGluID8gZm9jdXNXaXRoaW5Qcm9wcyA6IGZvY3VzUHJvcHNcbiAgICB9O1xufVxuXG5cbmZ1bmN0aW9uICQ5MDc3MTg3MDhlYWI2OGFmJGV4cG9ydCQxYTM4YjRhZDdmNTc4ZTFkKHByb3BzKSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCBmb2N1c0NsYXNzOiBmb2N1c0NsYXNzLCBmb2N1c1JpbmdDbGFzczogZm9jdXNSaW5nQ2xhc3MgfSA9IHByb3BzO1xuICAgIGxldCB7IGlzRm9jdXNlZDogaXNGb2N1c2VkLCBpc0ZvY3VzVmlzaWJsZTogaXNGb2N1c1Zpc2libGUsIGZvY3VzUHJvcHM6IGZvY3VzUHJvcHMgfSA9ICgwLCAkZjdkY2VmZmM1YWQ3NzY4YiRleHBvcnQkNGUzMjhmNjFjNTM4Njg3ZikocHJvcHMpO1xuICAgIGxldCBjaGlsZCA9ICgwLCAkNm5mRkMkcmVhY3QpLkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkNm5mRkMkcmVhY3QpLmNsb25lRWxlbWVudChjaGlsZCwgKDAsICQ2bmZGQyRtZXJnZVByb3BzKShjaGlsZC5wcm9wcywge1xuICAgICAgICAuLi5mb2N1c1Byb3BzLFxuICAgICAgICBjbGFzc05hbWU6ICgwLCAkNm5mRkMkY2xzeCkoe1xuICAgICAgICAgICAgW2ZvY3VzQ2xhc3MgfHwgXCJcIl06IGlzRm9jdXNlZCxcbiAgICAgICAgICAgIFtmb2N1c1JpbmdDbGFzcyB8fCBcIlwiXTogaXNGb2N1c1Zpc2libGVcbiAgICAgICAgfSlcbiAgICB9KSk7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cblxubGV0ICRlNmFmYmQ4M2ZlNmViYmQyJHZhciRGb2N1c2FibGVDb250ZXh0ID0gLyojX19QVVJFX18qLyAoMCwgJDZuZkZDJHJlYWN0KS5jcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gJGU2YWZiZDgzZmU2ZWJiZDIkdmFyJHVzZUZvY3VzYWJsZUNvbnRleHQocmVmKSB7XG4gICAgbGV0IGNvbnRleHQgPSAoMCwgJDZuZkZDJHVzZUNvbnRleHQpKCRlNmFmYmQ4M2ZlNmViYmQyJHZhciRGb2N1c2FibGVDb250ZXh0KSB8fCB7fTtcbiAgICAoMCwgJDZuZkZDJHVzZVN5bmNSZWYpKGNvbnRleHQsIHJlZik7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgbGV0IHsgcmVmOiBfLCAuLi5vdGhlclByb3BzIH0gPSBjb250ZXh0O1xuICAgIHJldHVybiBvdGhlclByb3BzO1xufVxuLyoqXG4gKiBQcm92aWRlcyBET00gcHJvcHMgdG8gdGhlIG5lYXJlc3QgZm9jdXNhYmxlIGNoaWxkLlxuICovIGZ1bmN0aW9uICRlNmFmYmQ4M2ZlNmViYmQyJHZhciRGb2N1c2FibGVQcm92aWRlcihwcm9wcywgcmVmKSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCAuLi5vdGhlclByb3BzIH0gPSBwcm9wcztcbiAgICBsZXQgb2JqUmVmID0gKDAsICQ2bmZGQyR1c2VPYmplY3RSZWYpKHJlZik7XG4gICAgbGV0IGNvbnRleHQgPSB7XG4gICAgICAgIC4uLm90aGVyUHJvcHMsXG4gICAgICAgIHJlZjogb2JqUmVmXG4gICAgfTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgJDZuZkZDJHJlYWN0KS5jcmVhdGVFbGVtZW50KCRlNmFmYmQ4M2ZlNmViYmQyJHZhciRGb2N1c2FibGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBjb250ZXh0XG4gICAgfSwgY2hpbGRyZW4pO1xufVxubGV0ICRlNmFmYmQ4M2ZlNmViYmQyJGV4cG9ydCQxM2YzMjAyYTNlNWRkZDUgPSAvKiNfX1BVUkVfXyovICgwLCAkNm5mRkMkcmVhY3QpLmZvcndhcmRSZWYoJGU2YWZiZDgzZmU2ZWJiZDIkdmFyJEZvY3VzYWJsZVByb3ZpZGVyKTtcbmZ1bmN0aW9uICRlNmFmYmQ4M2ZlNmViYmQyJGV4cG9ydCQ0YzAxNGRlN2M4OTQwYjRjKHByb3BzLCBkb21SZWYpIHtcbiAgICBsZXQgeyBmb2N1c1Byb3BzOiBmb2N1c1Byb3BzIH0gPSAoMCwgJDZuZkZDJHVzZUZvY3VzKShwcm9wcyk7XG4gICAgbGV0IHsga2V5Ym9hcmRQcm9wczoga2V5Ym9hcmRQcm9wcyB9ID0gKDAsICQ2bmZGQyR1c2VLZXlib2FyZCkocHJvcHMpO1xuICAgIGxldCBpbnRlcmFjdGlvbnMgPSAoMCwgJDZuZkZDJG1lcmdlUHJvcHMpKGZvY3VzUHJvcHMsIGtleWJvYXJkUHJvcHMpO1xuICAgIGxldCBkb21Qcm9wcyA9ICRlNmFmYmQ4M2ZlNmViYmQyJHZhciR1c2VGb2N1c2FibGVDb250ZXh0KGRvbVJlZik7XG4gICAgbGV0IGludGVyYWN0aW9uUHJvcHMgPSBwcm9wcy5pc0Rpc2FibGVkID8ge30gOiBkb21Qcm9wcztcbiAgICBsZXQgYXV0b0ZvY3VzUmVmID0gKDAsICQ2bmZGQyR1c2VSZWYpKHByb3BzLmF1dG9Gb2N1cyk7XG4gICAgKDAsICQ2bmZGQyR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChhdXRvRm9jdXNSZWYuY3VycmVudCAmJiBkb21SZWYuY3VycmVudCkgKDAsICQ2YTk5MTk1MzMyZWRlYzhiJGV4cG9ydCQ4MGYzZTE0N2Q3ODE1NzFjKShkb21SZWYuY3VycmVudCk7XG4gICAgICAgIGF1dG9Gb2N1c1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfSwgW1xuICAgICAgICBkb21SZWZcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmb2N1c2FibGVQcm9wczogKDAsICQ2bmZGQyRtZXJnZVByb3BzKSh7XG4gICAgICAgICAgICAuLi5pbnRlcmFjdGlvbnMsXG4gICAgICAgICAgICB0YWJJbmRleDogcHJvcHMuZXhjbHVkZUZyb21UYWJPcmRlciAmJiAhcHJvcHMuaXNEaXNhYmxlZCA/IC0xIDogdW5kZWZpbmVkXG4gICAgICAgIH0sIGludGVyYWN0aW9uUHJvcHMpXG4gICAgfTtcbn1cblxuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIyIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cbmZ1bmN0aW9uICQ4MzAxMzYzNWIwMjRhZTNkJGV4cG9ydCRlYWMxODk1OTkyYjlmM2Q2KHJlZiwgb3B0aW9ucykge1xuICAgIGxldCBpc0Rpc2FibGVkID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlzRGlzYWJsZWQ7XG4gICAgbGV0IFtoYXNUYWJiYWJsZUNoaWxkLCBzZXRIYXNUYWJiYWJsZUNoaWxkXSA9ICgwLCAkNm5mRkMkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICAoMCwgJDZuZkZDJHVzZUxheW91dEVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKChyZWYgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuY3VycmVudCkgJiYgIWlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGxldCB1cGRhdGUgPSAoKT0+e1xuICAgICAgICAgICAgICAgIGlmIChyZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgd2Fsa2VyID0gKDAsICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhKShyZWYuY3VycmVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFiYmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNldEhhc1RhYmJhYmxlQ2hpbGQoISF3YWxrZXIubmV4dE5vZGUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHdoZW4gbmV3IGVsZW1lbnRzIGFyZSBpbnNlcnRlZCwgb3IgdGhlIHRhYkluZGV4L2Rpc2FibGVkIGF0dHJpYnV0ZSB1cGRhdGVzLlxuICAgICAgICAgICAgbGV0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodXBkYXRlKTtcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUocmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1xuICAgICAgICAgICAgICAgICAgICBcInRhYkluZGV4XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAgICAgLy8gRGlzY29ubmVjdCBtdXRhdGlvbiBvYnNlcnZlciB3aGVuIGEgUmVhY3QgdXBkYXRlIG9jY3VycyBvbiB0aGUgdG9wLWxldmVsIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIHVwZGF0ZSBzeW5jaHJvbm91c2x5IGFmdGVyIHJlLXJlbmRlcmluZy4gT3RoZXJ3aXNlIFJlYWN0IHdpbGwgZW1pdCBhY3Qgd2FybmluZ3NcbiAgICAgICAgICAgICAgICAvLyBpbiB0ZXN0cyBzaW5jZSBtdXRhdGlvbiBvYnNlcnZlcnMgZmlyZSBhc3luY2hyb25vdXNseS4gVGhlIG11dGF0aW9uIG9ic2VydmVyIGlzIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIGFsc28gdXBkYXRlIGlmIGEgY2hpbGQgY29tcG9uZW50IHJlLXJlbmRlcnMgYW5kIGFkZHMvcmVtb3ZlcyBzb21ldGhpbmcgdGFiYmFibGUuXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpc0Rpc2FibGVkID8gZmFsc2UgOiBoYXNUYWJiYWJsZUNoaWxkO1xufVxuXG5cblxuXG5leHBvcnQgeyQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyMGU0MDI4OTY0MWZiYmI2IGFzIEZvY3VzU2NvcGUsICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQxMGM1MTY5NzU1Y2U3YmQ3IGFzIHVzZUZvY3VzTWFuYWdlciwgJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDJkNmVjOGZjMzc1Y2VhZmEgYXMgZ2V0Rm9jdXNhYmxlVHJlZVdhbGtlciwgJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JGM1MjUxYjllMTI0YmYyOSBhcyBjcmVhdGVGb2N1c01hbmFnZXIsICQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQxMjU4Mzk1Zjk5YmY5Y2JmIGFzIGlzRWxlbWVudEluQ2hpbGRPZkFjdGl2ZVNjb3BlLCAkOTA3NzE4NzA4ZWFiNjhhZiRleHBvcnQkMWEzOGI0YWQ3ZjU3OGUxZCBhcyBGb2N1c1JpbmcsICRlNmFmYmQ4M2ZlNmViYmQyJGV4cG9ydCQxM2YzMjAyYTNlNWRkZDUgYXMgRm9jdXNhYmxlUHJvdmlkZXIsICRlNmFmYmQ4M2ZlNmViYmQyJGV4cG9ydCQ0YzAxNGRlN2M4OTQwYjRjIGFzIHVzZUZvY3VzYWJsZSwgJGY3ZGNlZmZjNWFkNzc2OGIkZXhwb3J0JDRlMzI4ZjYxYzUzODY4N2YgYXMgdXNlRm9jdXNSaW5nLCAkNmE5OTE5NTMzMmVkZWM4YiRleHBvcnQkODBmM2UxNDdkNzgxNTcxYyBhcyBmb2N1c1NhZmVseSwgJDgzMDEzNjM1YjAyNGFlM2QkZXhwb3J0JGVhYzE4OTU5OTJiOWYzZDYgYXMgdXNlSGFzVGFiYmFibGVDaGlsZH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsiJDZuZkZDJHJlYWN0IiwidXNlUmVmIiwiJDZuZkZDJHVzZVJlZiIsInVzZUNvbnRleHQiLCIkNm5mRkMkdXNlQ29udGV4dCIsInVzZU1lbW8iLCIkNm5mRkMkdXNlTWVtbyIsInVzZUVmZmVjdCIsIiQ2bmZGQyR1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIiQ2bmZGQyR1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiJDZuZkZDJHVzZUNhbGxiYWNrIiwidXNlTGF5b3V0RWZmZWN0IiwiJDZuZkZDJHVzZUxheW91dEVmZmVjdCIsInJ1bkFmdGVyVHJhbnNpdGlvbiIsIiQ2bmZGQyRydW5BZnRlclRyYW5zaXRpb24iLCJmb2N1c1dpdGhvdXRTY3JvbGxpbmciLCIkNm5mRkMkZm9jdXNXaXRob3V0U2Nyb2xsaW5nIiwibWVyZ2VQcm9wcyIsIiQ2bmZGQyRtZXJnZVByb3BzIiwidXNlU3luY1JlZiIsIiQ2bmZGQyR1c2VTeW5jUmVmIiwidXNlT2JqZWN0UmVmIiwiJDZuZkZDJHVzZU9iamVjdFJlZiIsImdldEludGVyYWN0aW9uTW9kYWxpdHkiLCIkNm5mRkMkZ2V0SW50ZXJhY3Rpb25Nb2RhbGl0eSIsImlzRm9jdXNWaXNpYmxlIiwiJDZuZkZDJGlzRm9jdXNWaXNpYmxlIiwidXNlRm9jdXNWaXNpYmxlTGlzdGVuZXIiLCIkNm5mRkMkdXNlRm9jdXNWaXNpYmxlTGlzdGVuZXIiLCJ1c2VGb2N1cyIsIiQ2bmZGQyR1c2VGb2N1cyIsInVzZUZvY3VzV2l0aGluIiwiJDZuZkZDJHVzZUZvY3VzV2l0aGluIiwidXNlS2V5Ym9hcmQiLCIkNm5mRkMkdXNlS2V5Ym9hcmQiLCIkNm5mRkMkY2xzeCIsIiQ2YTk5MTk1MzMyZWRlYzhiJGV4cG9ydCQ4MGYzZTE0N2Q3ODE1NzFjIiwiZWxlbWVudCIsImxhc3RGb2N1c2VkRWxlbWVudCIsImRvY3VtZW50IiwiYWN0aXZlRWxlbWVudCIsImNvbnRhaW5zIiwiJDY0NWYyZTY3Yjg1YTI0YzkkdmFyJGlzU3R5bGVWaXNpYmxlIiwiSFRNTEVsZW1lbnQiLCJTVkdFbGVtZW50IiwiZGlzcGxheSIsInZpc2liaWxpdHkiLCJzdHlsZSIsImlzVmlzaWJsZSIsImdldENvbXB1dGVkU3R5bGUiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJjb21wdXRlZERpc3BsYXkiLCJjb21wdXRlZFZpc2liaWxpdHkiLCIkNjQ1ZjJlNjdiODVhMjRjOSR2YXIkaXNBdHRyaWJ1dGVWaXNpYmxlIiwiY2hpbGRFbGVtZW50IiwiaGFzQXR0cmlidXRlIiwibm9kZU5hbWUiLCIkNjQ1ZjJlNjdiODVhMjRjOSRleHBvcnQkZTk4OWMwZmZmYWE2YjI3YSIsInBhcmVudEVsZW1lbnQiLCIkOWJmNzFlYTI4NzkzZTczOCR2YXIkRm9jdXNDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsIiQ5YmY3MWVhMjg3OTNlNzM4JHZhciRhY3RpdmVTY29wZSIsIiQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyMGU0MDI4OTY0MWZiYmI2IiwicHJvcHMiLCJjaGlsZHJlbiIsImNvbnRhaW4iLCJyZXN0b3JlRm9jdXMiLCJhdXRvRm9jdXMiLCJzdGFydFJlZiIsImVuZFJlZiIsInNjb3BlUmVmIiwicGFyZW50Tm9kZSIsIm5vZGUiLCIkOWJmNzFlYTI4NzkzZTczOCR2YXIkVHJlZU5vZGUiLCJwYXJlbnQiLCIkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkZDA2ZmFlMmVlNjhiMTAxZSIsInJvb3QiLCJnZXRUcmVlTm9kZSIsIiQ5YmY3MWVhMjg3OTNlNzM4JHZhciRpc0FuY2VzdG9yU2NvcGUiLCJhY3RpdmVOb2RlIiwiYWRkQ2hpbGQiLCJhZGROb2RlIiwiX3N0YXJ0UmVmX2N1cnJlbnQiLCJjdXJyZW50IiwibmV4dFNpYmxpbmciLCJub2RlcyIsInB1c2giLCIkOWJmNzFlYTI4NzkzZTczOCR2YXIkdXNlQWN0aXZlU2NvcGVUcmFja2VyIiwiJDliZjcxZWEyODc5M2U3MzgkdmFyJHVzZUZvY3VzQ29udGFpbm1lbnQiLCIkOWJmNzFlYTI4NzkzZTczOCR2YXIkdXNlUmVzdG9yZUZvY3VzIiwiJDliZjcxZWEyODc5M2U3MzgkdmFyJHVzZUF1dG9Gb2N1cyIsInNjb3BlIiwiJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluU2NvcGUiLCJ0cmF2ZXJzZSIsIl9mb2N1c1Njb3BlVHJlZV9nZXRUcmVlTm9kZV9wYXJlbnQiLCJfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGUiLCJfZm9jdXNTY29wZVRyZWVfZ2V0VHJlZU5vZGVfcGFyZW50X3Njb3BlUmVmIiwicGFyZW50U2NvcGUiLCJyZW1vdmVUcmVlTm9kZSIsImZvY3VzTWFuYWdlciIsIiQ5YmY3MWVhMjg3OTNlNzM4JHZhciRjcmVhdGVGb2N1c01hbmFnZXJGb3JTY29wZSIsInZhbHVlIiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwiaGlkZGVuIiwicmVmIiwiJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDEwYzUxNjk3NTVjZTdiZDciLCJfdXNlQ29udGV4dCIsImZvY3VzTmV4dCIsIm9wdHMiLCJmcm9tIiwidGFiYmFibGUiLCJ3cmFwIiwiYWNjZXB0Iiwic2VudGluZWwiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwic2NvcGVSb290IiwiJDliZjcxZWEyODc5M2U3MzgkdmFyJGdldFNjb3BlUm9vdCIsIndhbGtlciIsIiQ5YmY3MWVhMjg3OTNlNzM4JGV4cG9ydCQyZDZlYzhmYzM3NWNlYWZhIiwiY3VycmVudE5vZGUiLCJuZXh0Tm9kZSIsIiQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c0VsZW1lbnQiLCJmb2N1c1ByZXZpb3VzIiwibGVuZ3RoIiwibmV4dEVsZW1lbnRTaWJsaW5nIiwicHJldmlvdXNOb2RlIiwiZm9jdXNGaXJzdCIsImZvY3VzTGFzdCIsIiQ5YmY3MWVhMjg3OTNlNzM4JHZhciRmb2N1c2FibGVFbGVtZW50cyIsIiQ5YmY3MWVhMjg3OTNlNzM4JHZhciRGT0NVU0FCTEVfRUxFTUVOVF9TRUxFQ1RPUiIsImpvaW4iLCIkOWJmNzFlYTI4NzkzZTczOCR2YXIkVEFCQkFCTEVfRUxFTUVOVF9TRUxFQ1RPUiIsIiQ5YmY3MWVhMjg3OTNlNzM4JHZhciRzaG91bGRDb250YWluRm9jdXMiLCJmb2N1c2VkTm9kZSIsInJhZiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwidW5kZWZpbmVkIiwib25LZXlEb3duIiwiZSIsImtleSIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5IiwiZm9jdXNlZEVsZW1lbnQiLCJuZXh0RWxlbWVudCIsInNoaWZ0S2V5IiwicHJldmVudERlZmF1bHQiLCJvbkZvY3VzIiwidGFyZ2V0IiwiJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluQ2hpbGRTY29wZSIsImZvY3VzIiwiJDliZjcxZWEyODc5M2U3MzgkdmFyJGZvY3VzRmlyc3RJblNjb3BlIiwib25CbHVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYm9keSIsIl9mb2N1c2VkTm9kZV9jdXJyZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImZvckVhY2giLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiJDliZjcxZWEyODc5M2U3MzgkdmFyJGlzRWxlbWVudEluQW55U2NvcGUiLCJzb21lIiwiRWxlbWVudCIsImNsb3Nlc3QiLCJzIiwiJDliZjcxZWEyODc5M2U3MzgkZXhwb3J0JDEyNTgzOTVmOTliZjljYmYiLCJhbmNlc3RvciIsInNjcm9sbCIsImVyciIsImF1dG9Gb2N1c1JlZiIsInJlc3RvcmUiLCIkOWJmNzFlYTI4NzkzZTczOCR2YXIkc2hvdWxkUmVzdG9yZUZvY3VzIiwibm9kZVRvUmVzdG9yZSIsIm5vZGVUb1Jlc3RvcmVSZWYiLCJ0cmVlTm9kZSIsInN0b3BQcm9wYWdhdGlvbiIsImJsdXIiLCJfbm9kZVRvUmVzdG9yZVJlZl9jdXJyZW50IiwiY2xvbmVkVHJlZSIsImNsb25lIiwic2VsZWN0b3IiLCJjcmVhdGVUcmVlV2Fsa2VyIiwiTm9kZUZpbHRlciIsIlNIT1dfRUxFTUVOVCIsImFjY2VwdE5vZGUiLCJfb3B0c19mcm9tIiwiRklMVEVSX1JFSkVDVCIsIm1hdGNoZXMiLCJGSUxURVJfQUNDRVBUIiwiRklMVEVSX1NLSVAiLCIkOWJmNzFlYTI4NzkzZTczOCRleHBvcnQkYzUyNTFiOWUxMjRiZjI5IiwiZGVmYXVsdE9wdGlvbnMiLCJuZXh0IiwiJDliZjcxZWEyODc5M2U3MzgkdmFyJGxhc3QiLCJsYXN0Tm9kZSIsImxhc3QiLCJsYXN0Q2hpbGQiLCIkOWJmNzFlYTI4NzkzZTczOCR2YXIkVHJlZSIsInNpemUiLCJmYXN0TWFwIiwiZGF0YSIsImdldCIsImFkZFRyZWVOb2RlIiwic2V0IiwicmVtb3ZlQ2hpbGQiLCJjaGlsZCIsImRlbGV0ZSIsIl9ub2RlX3BhcmVudCIsIm5ld1RyZWUiLCJfbm9kZV9wYXJlbnRfc2NvcGVSZWYiLCJjb25zdHJ1Y3RvciIsIk1hcCIsImFkZCIsIlNldCIsIiRmN2RjZWZmYzVhZDc3NjhiJGV4cG9ydCQ0ZTMyOGY2MWM1Mzg2ODdmIiwiaXNUZXh0SW5wdXQiLCJ3aXRoaW4iLCJzdGF0ZSIsImlzRm9jdXNlZCIsInNldEZvY3VzZWQiLCJpc0ZvY3VzVmlzaWJsZVN0YXRlIiwic2V0Rm9jdXNWaXNpYmxlIiwidXBkYXRlU3RhdGUiLCJvbkZvY3VzQ2hhbmdlIiwiZm9jdXNQcm9wcyIsImlzRGlzYWJsZWQiLCJmb2N1c1dpdGhpblByb3BzIiwib25Gb2N1c1dpdGhpbkNoYW5nZSIsIiQ5MDc3MTg3MDhlYWI2OGFmJGV4cG9ydCQxYTM4YjRhZDdmNTc4ZTFkIiwiZm9jdXNDbGFzcyIsImZvY3VzUmluZ0NsYXNzIiwiQ2hpbGRyZW4iLCJvbmx5IiwiY2xvbmVFbGVtZW50IiwiY2xhc3NOYW1lIiwiJGU2YWZiZDgzZmU2ZWJiZDIkdmFyJEZvY3VzYWJsZUNvbnRleHQiLCIkZTZhZmJkODNmZTZlYmJkMiR2YXIkdXNlRm9jdXNhYmxlQ29udGV4dCIsImNvbnRleHQiLCJfIiwib3RoZXJQcm9wcyIsIiRlNmFmYmQ4M2ZlNmViYmQyJHZhciRGb2N1c2FibGVQcm92aWRlciIsIm9ialJlZiIsIiRlNmFmYmQ4M2ZlNmViYmQyJGV4cG9ydCQxM2YzMjAyYTNlNWRkZDUiLCJmb3J3YXJkUmVmIiwiJGU2YWZiZDgzZmU2ZWJiZDIkZXhwb3J0JDRjMDE0ZGU3Yzg5NDBiNGMiLCJkb21SZWYiLCJrZXlib2FyZFByb3BzIiwiaW50ZXJhY3Rpb25zIiwiZG9tUHJvcHMiLCJpbnRlcmFjdGlvblByb3BzIiwiZm9jdXNhYmxlUHJvcHMiLCJ0YWJJbmRleCIsImV4Y2x1ZGVGcm9tVGFiT3JkZXIiLCIkODMwMTM2MzViMDI0YWUzZCRleHBvcnQkZWFjMTg5NTk5MmI5ZjNkNiIsIm9wdGlvbnMiLCJoYXNUYWJiYWJsZUNoaWxkIiwic2V0SGFzVGFiYmFibGVDaGlsZCIsInVwZGF0ZSIsIm9ic2VydmVyIiwiTXV0YXRpb25PYnNlcnZlciIsIm9ic2VydmUiLCJzdWJ0cmVlIiwiY2hpbGRMaXN0IiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZUZpbHRlciIsImRpc2Nvbm5lY3QiLCJGb2N1c1Njb3BlIiwidXNlRm9jdXNNYW5hZ2VyIiwiZ2V0Rm9jdXNhYmxlVHJlZVdhbGtlciIsImNyZWF0ZUZvY3VzTWFuYWdlciIsImlzRWxlbWVudEluQ2hpbGRPZkFjdGl2ZVNjb3BlIiwiRm9jdXNSaW5nIiwiRm9jdXNhYmxlUHJvdmlkZXIiLCJ1c2VGb2N1c2FibGUiLCJ1c2VGb2N1c1JpbmciLCJmb2N1c1NhZmVseSIsInVzZUhhc1RhYmJhYmxlQ2hpbGQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-aria/focus/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-aria/form/dist/import.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@react-aria/form/dist/import.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFormValidation: () => (/* binding */ $e93e671b31057976$export$b8473d3665f3a75a)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/interactions */ \"(ssr)/./node_modules/@react-aria/interactions/dist/import.mjs\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/./node_modules/@react-aria/utils/dist/import.mjs\");\n\n\n\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $e93e671b31057976$export$b8473d3665f3a75a(props, state, ref) {\n    let { validationBehavior: validationBehavior, focus: focus } = props;\n    // This is a useLayoutEffect so that it runs before the useEffect in useFormValidationState, which commits the validation change.\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{\n        if (validationBehavior === \"native\" && (ref === null || ref === void 0 ? void 0 : ref.current)) {\n            let errorMessage = state.realtimeValidation.isInvalid ? state.realtimeValidation.validationErrors.join(\" \") || \"Invalid value.\" : \"\";\n            ref.current.setCustomValidity(errorMessage);\n            // Prevent default tooltip for validation message.\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=605277\n            if (!ref.current.hasAttribute(\"title\")) ref.current.title = \"\";\n            if (!state.realtimeValidation.isInvalid) state.updateValidation($e93e671b31057976$var$getNativeValidity(ref.current));\n        }\n    });\n    let onReset = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)(()=>{\n        state.resetValidation();\n    });\n    let onInvalid = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        var _ref_current;\n        // Only commit validation if we are not already displaying one.\n        // This avoids clearing server errors that the user didn't actually fix.\n        if (!state.displayValidation.isInvalid) state.commitValidation();\n        // Auto focus the first invalid input in a form, unless the error already had its default prevented.\n        let form = ref === null || ref === void 0 ? void 0 : (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.form;\n        if (!e.defaultPrevented && ref && form && $e93e671b31057976$var$getFirstInvalidInput(form) === ref.current) {\n            var _ref_current1;\n            if (focus) focus();\n            else (_ref_current1 = ref.current) === null || _ref_current1 === void 0 ? void 0 : _ref_current1.focus();\n            // Always show focus ring.\n            (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__.setInteractionModality)(\"keyboard\");\n        }\n        // Prevent default browser error UI from appearing.\n        e.preventDefault();\n    });\n    let onChange = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)(()=>{\n        state.commitValidation();\n    });\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let input = ref === null || ref === void 0 ? void 0 : ref.current;\n        if (!input) return;\n        let form = input.form;\n        input.addEventListener(\"invalid\", onInvalid);\n        input.addEventListener(\"change\", onChange);\n        form === null || form === void 0 ? void 0 : form.addEventListener(\"reset\", onReset);\n        return ()=>{\n            input.removeEventListener(\"invalid\", onInvalid);\n            input.removeEventListener(\"change\", onChange);\n            form === null || form === void 0 ? void 0 : form.removeEventListener(\"reset\", onReset);\n        };\n    }, [\n        ref,\n        onInvalid,\n        onChange,\n        onReset,\n        validationBehavior\n    ]);\n}\nfunction $e93e671b31057976$var$getValidity(input) {\n    // The native ValidityState object is live, meaning each property is a getter that returns the current state.\n    // We need to create a snapshot of the validity state at the time this function is called to avoid unpredictable React renders.\n    let validity = input.validity;\n    return {\n        badInput: validity.badInput,\n        customError: validity.customError,\n        patternMismatch: validity.patternMismatch,\n        rangeOverflow: validity.rangeOverflow,\n        rangeUnderflow: validity.rangeUnderflow,\n        stepMismatch: validity.stepMismatch,\n        tooLong: validity.tooLong,\n        tooShort: validity.tooShort,\n        typeMismatch: validity.typeMismatch,\n        valueMissing: validity.valueMissing,\n        valid: validity.valid\n    };\n}\nfunction $e93e671b31057976$var$getNativeValidity(input) {\n    return {\n        isInvalid: !input.validity.valid,\n        validationDetails: $e93e671b31057976$var$getValidity(input),\n        validationErrors: input.validationMessage ? [\n            input.validationMessage\n        ] : []\n    };\n}\nfunction $e93e671b31057976$var$getFirstInvalidInput(form) {\n    for(let i = 0; i < form.elements.length; i++){\n        let element = form.elements[i];\n        if (!element.validity.valid) return element;\n    }\n    return null;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvZm9ybS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvRDtBQUM2QztBQUNvQjtBQUVySDs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUdELFNBQVNRLDBDQUEwQ0MsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLEdBQUc7SUFDaEUsSUFBSSxFQUFFQyxvQkFBb0JBLGtCQUFrQixFQUFFQyxPQUFPQSxLQUFLLEVBQUUsR0FBR0o7SUFDL0QsaUlBQWlJO0lBQ2hJLElBQUdKLDhEQUFxQixFQUFHO1FBQ3hCLElBQUlPLHVCQUF1QixZQUFhRCxDQUFBQSxRQUFRLFFBQVFBLFFBQVEsS0FBSyxJQUFJLEtBQUssSUFBSUEsSUFBSUcsT0FBTyxHQUFHO1lBQzVGLElBQUlDLGVBQWVMLE1BQU1NLGtCQUFrQixDQUFDQyxTQUFTLEdBQUdQLE1BQU1NLGtCQUFrQixDQUFDRSxnQkFBZ0IsQ0FBQ0MsSUFBSSxDQUFDLFFBQVEsbUJBQW1CO1lBQ2xJUixJQUFJRyxPQUFPLENBQUNNLGlCQUFpQixDQUFDTDtZQUM5QixrREFBa0Q7WUFDbEQsc0RBQXNEO1lBQ3RELElBQUksQ0FBQ0osSUFBSUcsT0FBTyxDQUFDTyxZQUFZLENBQUMsVUFBVVYsSUFBSUcsT0FBTyxDQUFDUSxLQUFLLEdBQUc7WUFDNUQsSUFBSSxDQUFDWixNQUFNTSxrQkFBa0IsQ0FBQ0MsU0FBUyxFQUFFUCxNQUFNYSxnQkFBZ0IsQ0FBQ0Msd0NBQXdDYixJQUFJRyxPQUFPO1FBQ3ZIO0lBQ0o7SUFDQSxJQUFJVyxVQUFVLENBQUMsR0FBR2xCLDZEQUFvQixFQUFHO1FBQ3JDRyxNQUFNZ0IsZUFBZTtJQUN6QjtJQUNBLElBQUlDLFlBQVksQ0FBQyxHQUFHcEIsNkRBQW9CLEVBQUcsQ0FBQ3FCO1FBQ3hDLElBQUlDO1FBQ0osK0RBQStEO1FBQy9ELHdFQUF3RTtRQUN4RSxJQUFJLENBQUNuQixNQUFNb0IsaUJBQWlCLENB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Li9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvZm9ybS9kaXN0L2ltcG9ydC5tanM/MjY1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZUVmZmVjdCBhcyAkMnRXdU0kdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7c2V0SW50ZXJhY3Rpb25Nb2RhbGl0eSBhcyAkMnRXdU0kc2V0SW50ZXJhY3Rpb25Nb2RhbGl0eX0gZnJvbSBcIkByZWFjdC1hcmlhL2ludGVyYWN0aW9uc1wiO1xuaW1wb3J0IHt1c2VMYXlvdXRFZmZlY3QgYXMgJDJ0V3VNJHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0RXZlbnQgYXMgJDJ0V3VNJHVzZUVmZmVjdEV2ZW50fSBmcm9tIFwiQHJlYWN0LWFyaWEvdXRpbHNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIzIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMyBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5mdW5jdGlvbiAkZTkzZTY3MWIzMTA1Nzk3NiRleHBvcnQkYjg0NzNkMzY2NWYzYTc1YShwcm9wcywgc3RhdGUsIHJlZikge1xuICAgIGxldCB7IHZhbGlkYXRpb25CZWhhdmlvcjogdmFsaWRhdGlvbkJlaGF2aW9yLCBmb2N1czogZm9jdXMgfSA9IHByb3BzO1xuICAgIC8vIFRoaXMgaXMgYSB1c2VMYXlvdXRFZmZlY3Qgc28gdGhhdCBpdCBydW5zIGJlZm9yZSB0aGUgdXNlRWZmZWN0IGluIHVzZUZvcm1WYWxpZGF0aW9uU3RhdGUsIHdoaWNoIGNvbW1pdHMgdGhlIHZhbGlkYXRpb24gY2hhbmdlLlxuICAgICgwLCAkMnRXdU0kdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAodmFsaWRhdGlvbkJlaGF2aW9yID09PSBcIm5hdGl2ZVwiICYmIChyZWYgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuY3VycmVudCkpIHtcbiAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBzdGF0ZS5yZWFsdGltZVZhbGlkYXRpb24uaXNJbnZhbGlkID8gc3RhdGUucmVhbHRpbWVWYWxpZGF0aW9uLnZhbGlkYXRpb25FcnJvcnMuam9pbihcIiBcIikgfHwgXCJJbnZhbGlkIHZhbHVlLlwiIDogXCJcIjtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50LnNldEN1c3RvbVZhbGlkaXR5KGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgdG9vbHRpcCBmb3IgdmFsaWRhdGlvbiBtZXNzYWdlLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjA1Mjc3XG4gICAgICAgICAgICBpZiAoIXJlZi5jdXJyZW50Lmhhc0F0dHJpYnV0ZShcInRpdGxlXCIpKSByZWYuY3VycmVudC50aXRsZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoIXN0YXRlLnJlYWx0aW1lVmFsaWRhdGlvbi5pc0ludmFsaWQpIHN0YXRlLnVwZGF0ZVZhbGlkYXRpb24oJGU5M2U2NzFiMzEwNTc5NzYkdmFyJGdldE5hdGl2ZVZhbGlkaXR5KHJlZi5jdXJyZW50KSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgb25SZXNldCA9ICgwLCAkMnRXdU0kdXNlRWZmZWN0RXZlbnQpKCgpPT57XG4gICAgICAgIHN0YXRlLnJlc2V0VmFsaWRhdGlvbigpO1xuICAgIH0pO1xuICAgIGxldCBvbkludmFsaWQgPSAoMCwgJDJ0V3VNJHVzZUVmZmVjdEV2ZW50KSgoZSk9PntcbiAgICAgICAgdmFyIF9yZWZfY3VycmVudDtcbiAgICAgICAgLy8gT25seSBjb21taXQgdmFsaWRhdGlvbiBpZiB3ZSBhcmUgbm90IGFscmVhZHkgZGlzcGxheWluZyBvbmUuXG4gICAgICAgIC8vIFRoaXMgYXZvaWRzIGNsZWFyaW5nIHNlcnZlciBlcnJvcnMgdGhhdCB0aGUgdXNlciBkaWRuJ3QgYWN0dWFsbHkgZml4LlxuICAgICAgICBpZiAoIXN0YXRlLmRpc3BsYXlWYWxpZGF0aW9uLmlzSW52YWxpZCkgc3RhdGUuY29tbWl0VmFsaWRhdGlvbigpO1xuICAgICAgICAvLyBBdXRvIGZvY3VzIHRoZSBmaXJzdCBpbnZhbGlkIGlucHV0IGluIGEgZm9ybSwgdW5sZXNzIHRoZSBlcnJvciBhbHJlYWR5IGhhZCBpdHMgZGVmYXVsdCBwcmV2ZW50ZWQuXG4gICAgICAgIGxldCBmb3JtID0gcmVmID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9yZWZfY3VycmVudCA9IHJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfcmVmX2N1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZWZfY3VycmVudC5mb3JtO1xuICAgICAgICBpZiAoIWUuZGVmYXVsdFByZXZlbnRlZCAmJiByZWYgJiYgZm9ybSAmJiAkZTkzZTY3MWIzMTA1Nzk3NiR2YXIkZ2V0Rmlyc3RJbnZhbGlkSW5wdXQoZm9ybSkgPT09IHJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgX3JlZl9jdXJyZW50MTtcbiAgICAgICAgICAgIGlmIChmb2N1cykgZm9jdXMoKTtcbiAgICAgICAgICAgIGVsc2UgKF9yZWZfY3VycmVudDEgPSByZWYuY3VycmVudCkgPT09IG51bGwgfHwgX3JlZl9jdXJyZW50MSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlZl9jdXJyZW50MS5mb2N1cygpO1xuICAgICAgICAgICAgLy8gQWx3YXlzIHNob3cgZm9jdXMgcmluZy5cbiAgICAgICAgICAgICgwLCAkMnRXdU0kc2V0SW50ZXJhY3Rpb25Nb2RhbGl0eSkoXCJrZXlib2FyZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYnJvd3NlciBlcnJvciBVSSBmcm9tIGFwcGVhcmluZy5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuICAgIGxldCBvbkNoYW5nZSA9ICgwLCAkMnRXdU0kdXNlRWZmZWN0RXZlbnQpKCgpPT57XG4gICAgICAgIHN0YXRlLmNvbW1pdFZhbGlkYXRpb24oKTtcbiAgICB9KTtcbiAgICAoMCwgJDJ0V3VNJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgbGV0IGlucHV0ID0gcmVmID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghaW5wdXQpIHJldHVybjtcbiAgICAgICAgbGV0IGZvcm0gPSBpbnB1dC5mb3JtO1xuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiaW52YWxpZFwiLCBvbkludmFsaWQpO1xuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIG9uQ2hhbmdlKTtcbiAgICAgICAgZm9ybSA9PT0gbnVsbCB8fCBmb3JtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldFwiLCBvblJlc2V0KTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW52YWxpZFwiLCBvbkludmFsaWQpO1xuICAgICAgICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBvbkNoYW5nZSk7XG4gICAgICAgICAgICBmb3JtID09PSBudWxsIHx8IGZvcm0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2V0XCIsIG9uUmVzZXQpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgcmVmLFxuICAgICAgICBvbkludmFsaWQsXG4gICAgICAgIG9uQ2hhbmdlLFxuICAgICAgICBvblJlc2V0LFxuICAgICAgICB2YWxpZGF0aW9uQmVoYXZpb3JcbiAgICBdKTtcbn1cbmZ1bmN0aW9uICRlOTNlNjcxYjMxMDU3OTc2JHZhciRnZXRWYWxpZGl0eShpbnB1dCkge1xuICAgIC8vIFRoZSBuYXRpdmUgVmFsaWRpdHlTdGF0ZSBvYmplY3QgaXMgbGl2ZSwgbWVhbmluZyBlYWNoIHByb3BlcnR5IGlzIGEgZ2V0dGVyIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhIHNuYXBzaG90IG9mIHRoZSB2YWxpZGl0eSBzdGF0ZSBhdCB0aGUgdGltZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0byBhdm9pZCB1bnByZWRpY3RhYmxlIFJlYWN0IHJlbmRlcnMuXG4gICAgbGV0IHZhbGlkaXR5ID0gaW5wdXQudmFsaWRpdHk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFkSW5wdXQ6IHZhbGlkaXR5LmJhZElucHV0LFxuICAgICAgICBjdXN0b21FcnJvcjogdmFsaWRpdHkuY3VzdG9tRXJyb3IsXG4gICAgICAgIHBhdHRlcm5NaXNtYXRjaDogdmFsaWRpdHkucGF0dGVybk1pc21hdGNoLFxuICAgICAgICByYW5nZU92ZXJmbG93OiB2YWxpZGl0eS5yYW5nZU92ZXJmbG93LFxuICAgICAgICByYW5nZVVuZGVyZmxvdzogdmFsaWRpdHkucmFuZ2VVbmRlcmZsb3csXG4gICAgICAgIHN0ZXBNaXNtYXRjaDogdmFsaWRpdHkuc3RlcE1pc21hdGNoLFxuICAgICAgICB0b29Mb25nOiB2YWxpZGl0eS50b29Mb25nLFxuICAgICAgICB0b29TaG9ydDogdmFsaWRpdHkudG9vU2hvcnQsXG4gICAgICAgIHR5cGVNaXNtYXRjaDogdmFsaWRpdHkudHlwZU1pc21hdGNoLFxuICAgICAgICB2YWx1ZU1pc3Npbmc6IHZhbGlkaXR5LnZhbHVlTWlzc2luZyxcbiAgICAgICAgdmFsaWQ6IHZhbGlkaXR5LnZhbGlkXG4gICAgfTtcbn1cbmZ1bmN0aW9uICRlOTNlNjcxYjMxMDU3OTc2JHZhciRnZXROYXRpdmVWYWxpZGl0eShpbnB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzSW52YWxpZDogIWlucHV0LnZhbGlkaXR5LnZhbGlkLFxuICAgICAgICB2YWxpZGF0aW9uRGV0YWlsczogJGU5M2U2NzFiMzEwNTc5NzYkdmFyJGdldFZhbGlkaXR5KGlucHV0KSxcbiAgICAgICAgdmFsaWRhdGlvbkVycm9yczogaW5wdXQudmFsaWRhdGlvbk1lc3NhZ2UgPyBbXG4gICAgICAgICAgICBpbnB1dC52YWxpZGF0aW9uTWVzc2FnZVxuICAgICAgICBdIDogW11cbiAgICB9O1xufVxuZnVuY3Rpb24gJGU5M2U2NzFiMzEwNTc5NzYkdmFyJGdldEZpcnN0SW52YWxpZElucHV0KGZvcm0pIHtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZm9ybS5lbGVtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGxldCBlbGVtZW50ID0gZm9ybS5lbGVtZW50c1tpXTtcbiAgICAgICAgaWYgKCFlbGVtZW50LnZhbGlkaXR5LnZhbGlkKSByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cblxuXG5cbmV4cG9ydCB7JGU5M2U2NzFiMzEwNTc5NzYkZXhwb3J0JGI4NDczZDM2NjVmM2E3NWEgYXMgdXNlRm9ybVZhbGlkYXRpb259O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsIiQydFd1TSR1c2VFZmZlY3QiLCJzZXRJbnRlcmFjdGlvbk1vZGFsaXR5IiwiJDJ0V3VNJHNldEludGVyYWN0aW9uTW9kYWxpdHkiLCJ1c2VMYXlvdXRFZmZlY3QiLCIkMnRXdU0kdXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0RXZlbnQiLCIkMnRXdU0kdXNlRWZmZWN0RXZlbnQiLCIkZTkzZTY3MWIzMTA1Nzk3NiRleHBvcnQkYjg0NzNkMzY2NWYzYTc1YSIsInByb3BzIiwic3RhdGUiLCJyZWYiLCJ2YWxpZGF0aW9uQmVoYXZpb3IiLCJmb2N1cyIsImN1cnJlbnQiLCJlcnJvck1lc3NhZ2UiLCJyZWFsdGltZVZhbGlkYXRpb24iLCJpc0ludmFsaWQiLCJ2YWxpZGF0aW9uRXJyb3JzIiwiam9pbiIsInNldEN1c3RvbVZhbGlkaXR5IiwiaGFzQXR0cmlidXRlIiwidGl0bGUiLCJ1cGRhdGVWYWxpZGF0aW9uIiwiJGU5M2U2NzFiMzEwNTc5NzYkdmFyJGdldE5hdGl2ZVZhbGlkaXR5Iiwib25SZXNldCIsInJlc2V0VmFsaWRhdGlvbiIsIm9uSW52YWxpZCIsImUiLCJfcmVmX2N1cnJlbnQiLCJkaXNwbGF5VmFsaWRhdGlvbiIsImNvbW1pdFZhbGlkYXRpb24iLCJmb3JtIiwiZGVmYXVsdFByZXZlbnRlZCIsIiRlOTNlNjcxYjMxMDU3OTc2JHZhciRnZXRGaXJzdEludmFsaWRJbnB1dCIsIl9yZWZfY3VycmVudDEiLCJwcmV2ZW50RGVmYXVsdCIsIm9uQ2hhbmdlIiwiaW5wdXQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIiRlOTNlNjcxYjMxMDU3OTc2JHZhciRnZXRWYWxpZGl0eSIsInZhbGlkaXR5IiwiYmFkSW5wdXQiLCJjdXN0b21FcnJvciIsInBhdHRlcm5NaXNtYXRjaCIsInJhbmdlT3ZlcmZsb3ciLCJyYW5nZVVuZGVyZmxvdyIsInN0ZXBNaXNtYXRjaCIsInRvb0xvbmciLCJ0b29TaG9ydCIsInR5cGVNaXNtYXRjaCIsInZhbHVlTWlzc2luZyIsInZhbGlkIiwidmFsaWRhdGlvbkRldGFpbHMiLCJ2YWxpZGF0aW9uTWVzc2FnZSIsImkiLCJlbGVtZW50cyIsImxlbmd0aCIsImVsZW1lbnQiLCJ1c2VGb3JtVmFsaWRhdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-aria/form/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-aria/interactions/dist/import.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@react-aria/interactions/dist/import.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClearPressResponder: () => (/* binding */ $f1ab8c75478c6f73$export$cf75428e0b9ed1ea),\n/* harmony export */   PressResponder: () => (/* binding */ $f1ab8c75478c6f73$export$3351871ee4b288b8),\n/* harmony export */   Pressable: () => (/* binding */ $3b117e43dc0ca95d$export$27c701ed9e449e99),\n/* harmony export */   getInteractionModality: () => (/* binding */ $507fabe10e71c6fb$export$630ff653c5ada6a9),\n/* harmony export */   isFocusVisible: () => (/* binding */ $507fabe10e71c6fb$export$b9b3dfddab17db27),\n/* harmony export */   setInteractionModality: () => (/* binding */ $507fabe10e71c6fb$export$8397ddfc504fdb9a),\n/* harmony export */   useFocus: () => (/* binding */ $a1ea59d68270f0dd$export$f8168d8dd8fd66e6),\n/* harmony export */   useFocusVisible: () => (/* binding */ $507fabe10e71c6fb$export$ffd9e5021c1fb2d6),\n/* harmony export */   useFocusVisibleListener: () => (/* binding */ $507fabe10e71c6fb$export$ec71b4b83ac08ec3),\n/* harmony export */   useFocusWithin: () => (/* binding */ $9ab94262bd0047c7$export$420e68273165f4ec),\n/* harmony export */   useHover: () => (/* binding */ $6179b936705e76d3$export$ae780daf29e6d456),\n/* harmony export */   useInteractOutside: () => (/* binding */ $e0b6e0b68ec7f50f$export$872b660ac5a1ff98),\n/* harmony export */   useInteractionModality: () => (/* binding */ $507fabe10e71c6fb$export$98e20ec92f614cfe),\n/* harmony export */   useKeyboard: () => (/* binding */ $46d819fcbaf35654$export$8f71654801c2f7cd),\n/* harmony export */   useLongPress: () => (/* binding */ $8a26561d2877236e$export$c24ed0104d07eab9),\n/* harmony export */   useMove: () => (/* binding */ $e8a7022cf87cba2a$export$36da96379f79f245),\n/* harmony export */   usePress: () => (/* binding */ $f6c31cce2adf654f$export$45712eceda6fad21),\n/* harmony export */   useScrollWheel: () => (/* binding */ $7d0a636d7a4dcefd$export$2123ff2b87c81ca)\n/* harmony export */ });\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/./node_modules/@react-aria/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_get */ \"(ssr)/./node_modules/@swc/helpers/esm/_class_private_field_get.js\");\n/* harmony import */ var _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_init */ \"(ssr)/./node_modules/@swc/helpers/esm/_class_private_field_init.js\");\n/* harmony import */ var _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_class_private_field_set */ \"(ssr)/./node_modules/@swc/helpers/esm/_class_private_field_set.js\");\n/* harmony import */ var _react_aria_ssr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-aria/ssr */ \"(ssr)/./node_modules/@react-aria/ssr/dist/import.mjs\");\n\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element\n// rather than at the document level so we just need to apply/remove user-select: none for each pressed element individually\nlet $14c0b72509d70225$var$state = \"default\";\nlet $14c0b72509d70225$var$savedUserSelect = \"\";\nlet $14c0b72509d70225$var$modifiedElementMap = new WeakMap();\nfunction $14c0b72509d70225$export$16a4697467175487(target) {\n    if ((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isIOS)()) {\n        if ($14c0b72509d70225$var$state === \"default\") {\n            // eslint-disable-next-line no-restricted-globals\n            const documentObject = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(target);\n            $14c0b72509d70225$var$savedUserSelect = documentObject.documentElement.style.webkitUserSelect;\n            documentObject.documentElement.style.webkitUserSelect = \"none\";\n        }\n        $14c0b72509d70225$var$state = \"disabled\";\n    } else if (target instanceof HTMLElement || target instanceof SVGElement) {\n        // If not iOS, store the target's original user-select and change to user-select: none\n        // Ignore state since it doesn't apply for non iOS\n        $14c0b72509d70225$var$modifiedElementMap.set(target, target.style.userSelect);\n        target.style.userSelect = \"none\";\n    }\n}\nfunction $14c0b72509d70225$export$b0d6fa1ab32e3295(target) {\n    if ((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isIOS)()) {\n        // If the state is already default, there's nothing to do.\n        // If it is restoring, then there's no need to queue a second restore.\n        if ($14c0b72509d70225$var$state !== \"disabled\") return;\n        $14c0b72509d70225$var$state = \"restoring\";\n        // There appears to be a delay on iOS where selection still might occur\n        // after pointer up, so wait a bit before removing user-select.\n        setTimeout(()=>{\n            // Wait for any CSS transitions to complete so we don't recompute style\n            // for the whole page in the middle of the animation and cause jank.\n            (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.runAfterTransition)(()=>{\n                // Avoid race conditions\n                if ($14c0b72509d70225$var$state === \"restoring\") {\n                    // eslint-disable-next-line no-restricted-globals\n                    const documentObject = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(target);\n                    if (documentObject.documentElement.style.webkitUserSelect === \"none\") documentObject.documentElement.style.webkitUserSelect = $14c0b72509d70225$var$savedUserSelect || \"\";\n                    $14c0b72509d70225$var$savedUserSelect = \"\";\n                    $14c0b72509d70225$var$state = \"default\";\n                }\n            });\n        }, 300);\n    } else if (target instanceof HTMLElement || target instanceof SVGElement) // Ignore state since it doesn't apply for non iOS\n    {\n        if (target && $14c0b72509d70225$var$modifiedElementMap.has(target)) {\n            let targetOldUserSelect = $14c0b72509d70225$var$modifiedElementMap.get(target);\n            if (target.style.userSelect === \"none\" && targetOldUserSelect) target.style.userSelect = targetOldUserSelect;\n            if (target.getAttribute(\"style\") === \"\") target.removeAttribute(\"style\");\n            $14c0b72509d70225$var$modifiedElementMap.delete(target);\n        }\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $ae1eeba8b9eafd08$export$5165eccb35aaadb5 = (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext({\n    register: ()=>{}\n});\n$ae1eeba8b9eafd08$export$5165eccb35aaadb5.displayName = \"PressResponderContext\";\nfunction $f6c31cce2adf654f$var$usePressResponderContext(props) {\n    // Consume context from <PressResponder> and merge with props.\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));\n    if (context) {\n        let { register: register, ...contextProps } = context;\n        props = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(contextProps, props);\n        register();\n    }\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useSyncRef)(context, props.ref);\n    return props;\n}\nvar $f6c31cce2adf654f$var$_shouldStopPropagation = /*#__PURE__*/ new WeakMap();\nclass $f6c31cce2adf654f$var$PressEvent {\n    continuePropagation() {\n        (0, _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, false);\n    }\n    get shouldStopPropagation() {\n        return (0, _swc_helpers_class_private_field_get__WEBPACK_IMPORTED_MODULE_3__._)(this, $f6c31cce2adf654f$var$_shouldStopPropagation);\n    }\n    constructor(type, pointerType, originalEvent){\n        (0, _swc_helpers_class_private_field_init__WEBPACK_IMPORTED_MODULE_4__._)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, {\n            writable: true,\n            value: void 0\n        });\n        (0, _swc_helpers_class_private_field_set__WEBPACK_IMPORTED_MODULE_2__._)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, true);\n        this.type = type;\n        this.pointerType = pointerType;\n        this.target = originalEvent.currentTarget;\n        this.shiftKey = originalEvent.shiftKey;\n        this.metaKey = originalEvent.metaKey;\n        this.ctrlKey = originalEvent.ctrlKey;\n        this.altKey = originalEvent.altKey;\n    }\n}\nconst $f6c31cce2adf654f$var$LINK_CLICKED = Symbol(\"linkClicked\");\nfunction $f6c31cce2adf654f$export$45712eceda6fad21(props) {\n    let { onPress: onPress, onPressChange: onPressChange, onPressStart: onPressStart, onPressEnd: onPressEnd, onPressUp: onPressUp, isDisabled: isDisabled, isPressed: isPressedProp, preventFocusOnPress: preventFocusOnPress, shouldCancelOnPointerExit: shouldCancelOnPointerExit, allowTextSelectionOnPress: allowTextSelectionOnPress, ref: _, ...domProps } = $f6c31cce2adf654f$var$usePressResponderContext(props);\n    let [isPressed, setPressed] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let ref = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isPressed: false,\n        ignoreEmulatedMouseEvents: false,\n        ignoreClickAfterPress: false,\n        didFirePressStart: false,\n        isTriggeringEvent: false,\n        activePointerId: null,\n        target: null,\n        isOverTarget: false,\n        pointerType: null\n    });\n    let { addGlobalListener: addGlobalListener, removeAllGlobalListeners: removeAllGlobalListeners } = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useGlobalListeners)();\n    let triggerPressStart = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType)=>{\n        let state = ref.current;\n        if (isDisabled || state.didFirePressStart) return false;\n        let shouldStopPropagation = true;\n        state.isTriggeringEvent = true;\n        if (onPressStart) {\n            let event = new $f6c31cce2adf654f$var$PressEvent(\"pressstart\", pointerType, originalEvent);\n            onPressStart(event);\n            shouldStopPropagation = event.shouldStopPropagation;\n        }\n        if (onPressChange) onPressChange(true);\n        state.isTriggeringEvent = false;\n        state.didFirePressStart = true;\n        setPressed(true);\n        return shouldStopPropagation;\n    });\n    let triggerPressEnd = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType, wasPressed = true)=>{\n        let state = ref.current;\n        if (!state.didFirePressStart) return false;\n        state.ignoreClickAfterPress = true;\n        state.didFirePressStart = false;\n        state.isTriggeringEvent = true;\n        let shouldStopPropagation = true;\n        if (onPressEnd) {\n            let event = new $f6c31cce2adf654f$var$PressEvent(\"pressend\", pointerType, originalEvent);\n            onPressEnd(event);\n            shouldStopPropagation = event.shouldStopPropagation;\n        }\n        if (onPressChange) onPressChange(false);\n        setPressed(false);\n        if (onPress && wasPressed && !isDisabled) {\n            let event = new $f6c31cce2adf654f$var$PressEvent(\"press\", pointerType, originalEvent);\n            onPress(event);\n            shouldStopPropagation && (shouldStopPropagation = event.shouldStopPropagation);\n        }\n        state.isTriggeringEvent = false;\n        return shouldStopPropagation;\n    });\n    let triggerPressUp = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType)=>{\n        let state = ref.current;\n        if (isDisabled) return false;\n        if (onPressUp) {\n            state.isTriggeringEvent = true;\n            let event = new $f6c31cce2adf654f$var$PressEvent(\"pressup\", pointerType, originalEvent);\n            onPressUp(event);\n            state.isTriggeringEvent = false;\n            return event.shouldStopPropagation;\n        }\n        return true;\n    });\n    let cancel = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        let state = ref.current;\n        if (state.isPressed && state.target) {\n            if (state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n            state.isPressed = false;\n            state.isOverTarget = false;\n            state.activePointerId = null;\n            state.pointerType = null;\n            removeAllGlobalListeners();\n            if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);\n        }\n    });\n    let cancelOnPointerExit = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        if (shouldCancelOnPointerExit) cancel(e);\n    });\n    let pressProps = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let state = ref.current;\n        let pressProps = {\n            onKeyDown (e) {\n                if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {\n                    var _state_metaKeyEvents;\n                    if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();\n                    // If the event is repeating, it may have started on a different element\n                    // after which focus moved to the current element. Ignore these events and\n                    // only handle the first key down event.\n                    let shouldStopPropagation = true;\n                    if (!state.isPressed && !e.repeat) {\n                        state.target = e.currentTarget;\n                        state.isPressed = true;\n                        shouldStopPropagation = triggerPressStart(e, \"keyboard\");\n                        // Focus may move before the key up event, so register the event on the document\n                        // instead of the same element where the key down event occurred.\n                        addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"keyup\", onKeyUp, false);\n                    }\n                    if (shouldStopPropagation) e.stopPropagation();\n                    // Keep track of the keydown events that occur while the Meta (e.g. Command) key is held.\n                    // macOS has a bug where keyup events are not fired while the Meta key is down.\n                    // When the Meta key itself is released we will get an event for that, and we'll act as if\n                    // all of these other keys were released as well.\n                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1393524\n                    // https://bugs.webkit.org/show_bug.cgi?id=55291\n                    // https://bugzilla.mozilla.org/show_bug.cgi?id=1299553\n                    if (e.metaKey && (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isMac)()) (_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.set(e.key, e.nativeEvent);\n                } else if (e.key === \"Meta\") state.metaKeyEvents = new Map();\n            },\n            onKeyUp (e) {\n                if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target) && state.target) triggerPressUp($f6c31cce2adf654f$var$createEvent(state.target, e), \"keyboard\");\n            },\n            onClick (e) {\n                if (e && !e.currentTarget.contains(e.target)) return;\n                if (e && e.button === 0 && !state.isTriggeringEvent && !(0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.openLink).isOpening) {\n                    let shouldStopPropagation = true;\n                    if (isDisabled) e.preventDefault();\n                    // If triggered from a screen reader or by using element.click(),\n                    // trigger as if it were a keyboard click.\n                    if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === \"virtual\" || (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isVirtualClick)(e.nativeEvent))) {\n                        // Ensure the element receives focus (VoiceOver on iOS does not do this)\n                        if (!isDisabled && !preventFocusOnPress) (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.focusWithoutScrolling)(e.currentTarget);\n                        let stopPressStart = triggerPressStart(e, \"virtual\");\n                        let stopPressUp = triggerPressUp(e, \"virtual\");\n                        let stopPressEnd = triggerPressEnd(e, \"virtual\");\n                        shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;\n                    }\n                    state.ignoreEmulatedMouseEvents = false;\n                    state.ignoreClickAfterPress = false;\n                    if (shouldStopPropagation) e.stopPropagation();\n                }\n            }\n        };\n        let onKeyUp = (e)=>{\n            var _state_metaKeyEvents;\n            if (state.isPressed && state.target && $f6c31cce2adf654f$var$isValidKeyboardEvent(e, state.target)) {\n                var _state_metaKeyEvents1;\n                if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();\n                let target = e.target;\n                let shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), \"keyboard\", state.target.contains(target));\n                removeAllGlobalListeners();\n                if (shouldStopPropagation) e.stopPropagation();\n                // If a link was triggered with a key other than Enter, open the URL ourselves.\n                // This means the link has a role override, and the default browser behavior\n                // only applies when using the Enter key.\n                if (e.key !== \"Enter\" && $f6c31cce2adf654f$var$isHTMLAnchorLink(state.target) && state.target.contains(target) && !e[$f6c31cce2adf654f$var$LINK_CLICKED]) {\n                    // Store a hidden property on the event so we only trigger link click once,\n                    // even if there are multiple usePress instances attached to the element.\n                    e[$f6c31cce2adf654f$var$LINK_CLICKED] = true;\n                    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.openLink)(state.target, e, false);\n                }\n                state.isPressed = false;\n                (_state_metaKeyEvents1 = state.metaKeyEvents) === null || _state_metaKeyEvents1 === void 0 ? void 0 : _state_metaKeyEvents1.delete(e.key);\n            } else if (e.key === \"Meta\" && ((_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.size)) {\n                var _state_target;\n                // If we recorded keydown events that occurred while the Meta key was pressed,\n                // and those haven't received keyup events already, fire keyup events ourselves.\n                // See comment above for more info about the macOS bug causing this.\n                let events = state.metaKeyEvents;\n                state.metaKeyEvents = undefined;\n                for (let event of events.values())(_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.dispatchEvent(new KeyboardEvent(\"keyup\", event));\n            }\n        };\n        if (typeof PointerEvent !== \"undefined\") {\n            pressProps.onPointerDown = (e)=>{\n                // Only handle left clicks, and ignore events that bubbled through portals.\n                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;\n                // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.\n                // Ignore and let the onClick handler take care of it instead.\n                // https://bugs.webkit.org/show_bug.cgi?id=222627\n                // https://bugs.webkit.org/show_bug.cgi?id=223202\n                if ((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isVirtualPointerEvent)(e.nativeEvent)) {\n                    state.pointerType = \"virtual\";\n                    return;\n                }\n                // Due to browser inconsistencies, especially on mobile browsers, we prevent\n                // default on pointer down and handle focusing the pressable element ourselves.\n                if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n                state.pointerType = e.pointerType;\n                let shouldStopPropagation = true;\n                if (!state.isPressed) {\n                    state.isPressed = true;\n                    state.isOverTarget = true;\n                    state.activePointerId = e.pointerId;\n                    state.target = e.currentTarget;\n                    if (!isDisabled && !preventFocusOnPress) (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.focusWithoutScrolling)(e.currentTarget);\n                    if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);\n                    shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                    addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"pointermove\", onPointerMove, false);\n                    addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"pointerup\", onPointerUp, false);\n                    addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"pointercancel\", onPointerCancel, false);\n                }\n                if (shouldStopPropagation) e.stopPropagation();\n            };\n            pressProps.onMouseDown = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                if (e.button === 0) {\n                    // Chrome and Firefox on touch Windows devices require mouse down events\n                    // to be canceled in addition to pointer events, or an extra asynchronous\n                    // focus event will be fired.\n                    if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n                    e.stopPropagation();\n                }\n            };\n            pressProps.onPointerUp = (e)=>{\n                // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.\n                if (!e.currentTarget.contains(e.target) || state.pointerType === \"virtual\") return;\n                // Only handle left clicks\n                // Safari on iOS sometimes fires pointerup events, even\n                // when the touch isn't over the target, so double check.\n                if (e.button === 0 && $f6c31cce2adf654f$var$isOverTarget(e, e.currentTarget)) triggerPressUp(e, state.pointerType || e.pointerType);\n            };\n            // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.\n            // Use pointer move events instead to implement our own hit testing.\n            // See https://bugs.webkit.org/show_bug.cgi?id=199803\n            let onPointerMove = (e)=>{\n                if (e.pointerId !== state.activePointerId) return;\n                if (state.target && $f6c31cce2adf654f$var$isOverTarget(e, state.target)) {\n                    if (!state.isOverTarget && state.pointerType != null) {\n                        state.isOverTarget = true;\n                        triggerPressStart($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);\n                    }\n                } else if (state.target && state.isOverTarget && state.pointerType != null) {\n                    state.isOverTarget = false;\n                    triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n                    cancelOnPointerExit(e);\n                }\n            };\n            let onPointerUp = (e)=>{\n                if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0 && state.target) {\n                    if ($f6c31cce2adf654f$var$isOverTarget(e, state.target) && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);\n                    else if (state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n                    state.isPressed = false;\n                    state.isOverTarget = false;\n                    state.activePointerId = null;\n                    state.pointerType = null;\n                    removeAllGlobalListeners();\n                    if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);\n                }\n            };\n            let onPointerCancel = (e)=>{\n                cancel(e);\n            };\n            pressProps.onDragStart = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.\n                cancel(e);\n            };\n        } else {\n            pressProps.onMouseDown = (e)=>{\n                // Only handle left clicks\n                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;\n                // Due to browser inconsistencies, especially on mobile browsers, we prevent\n                // default on mouse down and handle focusing the pressable element ourselves.\n                if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n                if (state.ignoreEmulatedMouseEvents) {\n                    e.stopPropagation();\n                    return;\n                }\n                state.isPressed = true;\n                state.isOverTarget = true;\n                state.target = e.currentTarget;\n                state.pointerType = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isVirtualClick)(e.nativeEvent) ? \"virtual\" : \"mouse\";\n                if (!isDisabled && !preventFocusOnPress) (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.focusWithoutScrolling)(e.currentTarget);\n                let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                if (shouldStopPropagation) e.stopPropagation();\n                addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(e.currentTarget), \"mouseup\", onMouseUp, false);\n            };\n            pressProps.onMouseEnter = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                let shouldStopPropagation = true;\n                if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n                    state.isOverTarget = true;\n                    shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                }\n                if (shouldStopPropagation) e.stopPropagation();\n            };\n            pressProps.onMouseLeave = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                let shouldStopPropagation = true;\n                if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n                    state.isOverTarget = false;\n                    shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n                    cancelOnPointerExit(e);\n                }\n                if (shouldStopPropagation) e.stopPropagation();\n            };\n            pressProps.onMouseUp = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                if (!state.ignoreEmulatedMouseEvents && e.button === 0) triggerPressUp(e, state.pointerType || \"mouse\");\n            };\n            let onMouseUp = (e)=>{\n                // Only handle left clicks\n                if (e.button !== 0) return;\n                state.isPressed = false;\n                removeAllGlobalListeners();\n                if (state.ignoreEmulatedMouseEvents) {\n                    state.ignoreEmulatedMouseEvents = false;\n                    return;\n                }\n                if (state.target && $f6c31cce2adf654f$var$isOverTarget(e, state.target) && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);\n                else if (state.target && state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n                state.isOverTarget = false;\n            };\n            pressProps.onTouchStart = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                let touch = $f6c31cce2adf654f$var$getTouchFromEvent(e.nativeEvent);\n                if (!touch) return;\n                state.activePointerId = touch.identifier;\n                state.ignoreEmulatedMouseEvents = true;\n                state.isOverTarget = true;\n                state.isPressed = true;\n                state.target = e.currentTarget;\n                state.pointerType = \"touch\";\n                // Due to browser inconsistencies, especially on mobile browsers, we prevent default\n                // on the emulated mouse event and handle focusing the pressable element ourselves.\n                if (!isDisabled && !preventFocusOnPress) (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.focusWithoutScrolling)(e.currentTarget);\n                if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);\n                let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                if (shouldStopPropagation) e.stopPropagation();\n                addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerWindow)(e.currentTarget), \"scroll\", onScroll, true);\n            };\n            pressProps.onTouchMove = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                if (!state.isPressed) {\n                    e.stopPropagation();\n                    return;\n                }\n                let touch = $f6c31cce2adf654f$var$getTouchById(e.nativeEvent, state.activePointerId);\n                let shouldStopPropagation = true;\n                if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e.currentTarget)) {\n                    if (!state.isOverTarget && state.pointerType != null) {\n                        state.isOverTarget = true;\n                        shouldStopPropagation = triggerPressStart(e, state.pointerType);\n                    }\n                } else if (state.isOverTarget && state.pointerType != null) {\n                    state.isOverTarget = false;\n                    shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n                    cancelOnPointerExit(e);\n                }\n                if (shouldStopPropagation) e.stopPropagation();\n            };\n            pressProps.onTouchEnd = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                if (!state.isPressed) {\n                    e.stopPropagation();\n                    return;\n                }\n                let touch = $f6c31cce2adf654f$var$getTouchById(e.nativeEvent, state.activePointerId);\n                let shouldStopPropagation = true;\n                if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e.currentTarget) && state.pointerType != null) {\n                    triggerPressUp(e, state.pointerType);\n                    shouldStopPropagation = triggerPressEnd(e, state.pointerType);\n                } else if (state.isOverTarget && state.pointerType != null) shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n                if (shouldStopPropagation) e.stopPropagation();\n                state.isPressed = false;\n                state.activePointerId = null;\n                state.isOverTarget = false;\n                state.ignoreEmulatedMouseEvents = true;\n                if (state.target && !allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);\n                removeAllGlobalListeners();\n            };\n            pressProps.onTouchCancel = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                e.stopPropagation();\n                if (state.isPressed) cancel(e);\n            };\n            let onScroll = (e)=>{\n                if (state.isPressed && e.target.contains(state.target)) cancel({\n                    currentTarget: state.target,\n                    shiftKey: false,\n                    ctrlKey: false,\n                    metaKey: false,\n                    altKey: false\n                });\n            };\n            pressProps.onDragStart = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                cancel(e);\n            };\n        }\n        return pressProps;\n    }, [\n        addGlobalListener,\n        isDisabled,\n        preventFocusOnPress,\n        removeAllGlobalListeners,\n        allowTextSelectionOnPress,\n        cancel,\n        cancelOnPointerExit,\n        triggerPressEnd,\n        triggerPressStart,\n        triggerPressUp\n    ]);\n    // Remove user-select: none in case component unmounts immediately after pressStart\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            var _ref_current_target;\n            if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)((_ref_current_target = ref.current.target) !== null && _ref_current_target !== void 0 ? _ref_current_target : undefined);\n        };\n    }, [\n        allowTextSelectionOnPress\n    ]);\n    return {\n        isPressed: isPressedProp || isPressed,\n        pressProps: (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(domProps, pressProps)\n    };\n}\nfunction $f6c31cce2adf654f$var$isHTMLAnchorLink(target) {\n    return target.tagName === \"A\" && target.hasAttribute(\"href\");\n}\nfunction $f6c31cce2adf654f$var$isValidKeyboardEvent(event, currentTarget) {\n    const { key: key, code: code } = event;\n    const element = currentTarget;\n    const role = element.getAttribute(\"role\");\n    // Accessibility for keyboards. Space and Enter only.\n    // \"Spacebar\" is for IE 11\n    return (key === \"Enter\" || key === \" \" || key === \"Spacebar\" || code === \"Space\") && !(element instanceof (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerWindow)(element).HTMLInputElement && !$f6c31cce2adf654f$var$isValidInputKey(element, key) || element instanceof (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerWindow)(element).HTMLTextAreaElement || element.isContentEditable) && // Links should only trigger with Enter key\n    !((role === \"link\" || !role && $f6c31cce2adf654f$var$isHTMLAnchorLink(element)) && key !== \"Enter\");\n}\nfunction $f6c31cce2adf654f$var$getTouchFromEvent(event) {\n    const { targetTouches: targetTouches } = event;\n    if (targetTouches.length > 0) return targetTouches[0];\n    return null;\n}\nfunction $f6c31cce2adf654f$var$getTouchById(event, pointerId) {\n    const changedTouches = event.changedTouches;\n    for(let i = 0; i < changedTouches.length; i++){\n        const touch = changedTouches[i];\n        if (touch.identifier === pointerId) return touch;\n    }\n    return null;\n}\nfunction $f6c31cce2adf654f$var$createEvent(target, e) {\n    return {\n        currentTarget: target,\n        shiftKey: e.shiftKey,\n        ctrlKey: e.ctrlKey,\n        metaKey: e.metaKey,\n        altKey: e.altKey\n    };\n}\nfunction $f6c31cce2adf654f$var$getPointClientRect(point) {\n    let offsetX = 0;\n    let offsetY = 0;\n    if (point.width !== undefined) offsetX = point.width / 2;\n    else if (point.radiusX !== undefined) offsetX = point.radiusX;\n    if (point.height !== undefined) offsetY = point.height / 2;\n    else if (point.radiusY !== undefined) offsetY = point.radiusY;\n    return {\n        top: point.clientY - offsetY,\n        right: point.clientX + offsetX,\n        bottom: point.clientY + offsetY,\n        left: point.clientX - offsetX\n    };\n}\nfunction $f6c31cce2adf654f$var$areRectanglesOverlapping(a, b) {\n    // check if they cannot overlap on x axis\n    if (a.left > b.right || b.left > a.right) return false;\n    // check if they cannot overlap on y axis\n    if (a.top > b.bottom || b.top > a.bottom) return false;\n    return true;\n}\nfunction $f6c31cce2adf654f$var$isOverTarget(point, target) {\n    let rect = target.getBoundingClientRect();\n    let pointRect = $f6c31cce2adf654f$var$getPointClientRect(point);\n    return $f6c31cce2adf654f$var$areRectanglesOverlapping(rect, pointRect);\n}\nfunction $f6c31cce2adf654f$var$shouldPreventDefault(target) {\n    // We cannot prevent default if the target is a draggable element.\n    return !(target instanceof HTMLElement) || !target.hasAttribute(\"draggable\");\n}\nfunction $f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(target, key) {\n    if (target instanceof HTMLInputElement) return !$f6c31cce2adf654f$var$isValidInputKey(target, key);\n    if (target instanceof HTMLButtonElement) return target.type !== \"submit\" && target.type !== \"reset\";\n    if ($f6c31cce2adf654f$var$isHTMLAnchorLink(target)) return false;\n    return true;\n}\nconst $f6c31cce2adf654f$var$nonTextInputTypes = new Set([\n    \"checkbox\",\n    \"radio\",\n    \"range\",\n    \"color\",\n    \"file\",\n    \"image\",\n    \"button\",\n    \"submit\",\n    \"reset\"\n]);\nfunction $f6c31cce2adf654f$var$isValidInputKey(target, key) {\n    // Only space should toggle checkboxes and radios, not enter.\n    return target.type === \"checkbox\" || target.type === \"radio\" ? key === \" \" : $f6c31cce2adf654f$var$nonTextInputTypes.has(target.type);\n}\nconst $3b117e43dc0ca95d$export$27c701ed9e449e99 = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).forwardRef(({ children: children, ...props }, ref)=>{\n    ref = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useObjectRef)(ref);\n    let { pressProps: pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({\n        ...props,\n        ref: ref\n    });\n    let child = (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.only(children);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).cloneElement(child, {\n        ref: ref,\n        ...(0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(child.props, pressProps)\n    });\n});\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $f1ab8c75478c6f73$export$3351871ee4b288b8 = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).forwardRef(({ children: children, ...props }, ref)=>{\n    let isRegistered = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let prevContext = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));\n    ref = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useObjectRef)(ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref));\n    let context = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(prevContext || {}, {\n        ...props,\n        ref: ref,\n        register () {\n            isRegistered.current = true;\n            if (prevContext) prevContext.register();\n        }\n    });\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useSyncRef)(prevContext, ref);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isRegistered.current) {\n            console.warn(\"A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.\");\n            isRegistered.current = true; // only warn once in strict mode.\n        }\n    }, []);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5).Provider, {\n        value: context\n    }, children);\n});\nfunction $f1ab8c75478c6f73$export$cf75428e0b9ed1ea({ children: children }) {\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            register: ()=>{}\n        }), []);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5).Provider, {\n        value: context\n    }, children);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $8a9cb279dc87e130$export$905e7fc544a71f36 {\n    isDefaultPrevented() {\n        return this.nativeEvent.defaultPrevented;\n    }\n    preventDefault() {\n        this.defaultPrevented = true;\n        this.nativeEvent.preventDefault();\n    }\n    stopPropagation() {\n        this.nativeEvent.stopPropagation();\n        this.isPropagationStopped = ()=>true;\n    }\n    isPropagationStopped() {\n        return false;\n    }\n    persist() {}\n    constructor(type, nativeEvent){\n        this.nativeEvent = nativeEvent;\n        this.target = nativeEvent.target;\n        this.currentTarget = nativeEvent.currentTarget;\n        this.relatedTarget = nativeEvent.relatedTarget;\n        this.bubbles = nativeEvent.bubbles;\n        this.cancelable = nativeEvent.cancelable;\n        this.defaultPrevented = nativeEvent.defaultPrevented;\n        this.eventPhase = nativeEvent.eventPhase;\n        this.isTrusted = nativeEvent.isTrusted;\n        this.timeStamp = nativeEvent.timeStamp;\n        this.type = type;\n    }\n}\nfunction $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {\n    let stateRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isFocused: false,\n        observer: null\n    });\n    // Clean up MutationObserver on unmount. See below.\n    // eslint-disable-next-line arrow-body-style\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{\n        const state = stateRef.current;\n        return ()=>{\n            if (state.observer) {\n                state.observer.disconnect();\n                state.observer = null;\n            }\n        };\n    }, []);\n    let dispatchBlur = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);\n    });\n    // This function is called during a React onFocus event.\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142\n        // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a\n        // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.\n        // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.\n        if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {\n            stateRef.current.isFocused = true;\n            let target = e.target;\n            let onBlurHandler = (e)=>{\n                stateRef.current.isFocused = false;\n                if (target.disabled) dispatchBlur(new $8a9cb279dc87e130$export$905e7fc544a71f36(\"blur\", e));\n                // We no longer need the MutationObserver once the target is blurred.\n                if (stateRef.current.observer) {\n                    stateRef.current.observer.disconnect();\n                    stateRef.current.observer = null;\n                }\n            };\n            target.addEventListener(\"focusout\", onBlurHandler, {\n                once: true\n            });\n            stateRef.current.observer = new MutationObserver(()=>{\n                if (stateRef.current.isFocused && target.disabled) {\n                    var _stateRef_current_observer;\n                    (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 ? void 0 : _stateRef_current_observer.disconnect();\n                    let relatedTargetEl = target === document.activeElement ? null : document.activeElement;\n                    target.dispatchEvent(new FocusEvent(\"blur\", {\n                        relatedTarget: relatedTargetEl\n                    }));\n                    target.dispatchEvent(new FocusEvent(\"focusout\", {\n                        bubbles: true,\n                        relatedTarget: relatedTargetEl\n                    }));\n                }\n            });\n            stateRef.current.observer.observe(target, {\n                attributes: true,\n                attributeFilter: [\n                    \"disabled\"\n                ]\n            });\n        }\n    }, [\n        dispatchBlur\n    ]);\n}\nfunction $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {\n    let { isDisabled: isDisabled, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange: onFocusChange } = props;\n    const onBlur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (e.target === e.currentTarget) {\n            if (onBlurProp) onBlurProp(e);\n            if (onFocusChange) onFocusChange(false);\n            return true;\n        }\n    }, [\n        onBlurProp,\n        onFocusChange\n    ]);\n    const onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);\n    const onFocus = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // Double check that document.activeElement actually matches e.target in case a previously chained\n        // focus handler already moved focus somewhere else.\n        if (e.target === e.currentTarget && document.activeElement === e.target) {\n            if (onFocusProp) onFocusProp(e);\n            if (onFocusChange) onFocusChange(true);\n            onSyntheticFocus(e);\n        }\n    }, [\n        onFocusChange,\n        onFocusProp,\n        onSyntheticFocus\n    ]);\n    return {\n        focusProps: {\n            onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : undefined,\n            onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : undefined\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\nlet $507fabe10e71c6fb$var$currentModality = null;\nlet $507fabe10e71c6fb$var$changeHandlers = new Set();\nlet $507fabe10e71c6fb$var$hasSetupGlobalListeners = false;\nlet $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\nlet $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;\n// Only Tab or Esc keys will make focus visible on text input elements\nconst $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {\n    Tab: true,\n    Escape: true\n};\nfunction $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e) {\n    for (let handler of $507fabe10e71c6fb$var$changeHandlers)handler(modality, e);\n}\n/**\n * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.\n */ function $507fabe10e71c6fb$var$isValidKey(e) {\n    // Control and Shift keys trigger when navigating back to the tab with keyboard.\n    return !(e.metaKey || !(0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isMac)() && e.altKey || e.ctrlKey || e.key === \"Control\" || e.key === \"Shift\" || e.key === \"Meta\");\n}\nfunction $507fabe10e71c6fb$var$handleKeyboardEvent(e) {\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n    if ($507fabe10e71c6fb$var$isValidKey(e)) {\n        $507fabe10e71c6fb$var$currentModality = \"keyboard\";\n        $507fabe10e71c6fb$var$triggerChangeHandlers(\"keyboard\", e);\n    }\n}\nfunction $507fabe10e71c6fb$var$handlePointerEvent(e) {\n    $507fabe10e71c6fb$var$currentModality = \"pointer\";\n    if (e.type === \"mousedown\" || e.type === \"pointerdown\") {\n        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n        $507fabe10e71c6fb$var$triggerChangeHandlers(\"pointer\", e);\n    }\n}\nfunction $507fabe10e71c6fb$var$handleClickEvent(e) {\n    if ((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isVirtualClick)(e)) {\n        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n        $507fabe10e71c6fb$var$currentModality = \"virtual\";\n    }\n}\nfunction $507fabe10e71c6fb$var$handleFocusEvent(e) {\n    // Firefox fires two extra focus events when the user first clicks into an iframe:\n    // first on the window, then on the document. We ignore these events so they don't\n    // cause keyboard focus rings to appear.\n    if (e.target === window || e.target === document) return;\n    // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.\n    // This occurs, for example, when navigating a form with the next/previous buttons on iOS.\n    if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {\n        $507fabe10e71c6fb$var$currentModality = \"virtual\";\n        $507fabe10e71c6fb$var$triggerChangeHandlers(\"virtual\", e);\n    }\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n    $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;\n}\nfunction $507fabe10e71c6fb$var$handleWindowBlur() {\n    // When the window is blurred, reset state. This is necessary when tabbing out of the window,\n    // for example, since a subsequent focus event won't be fired.\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n    $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;\n}\n/**\n * Setup global event listeners to control when keyboard focus style should be visible.\n */ function $507fabe10e71c6fb$var$setupGlobalFocusEvents() {\n    if (true) return;\n    // Programmatic focus() calls shouldn't affect the current input modality.\n    // However, we need to detect other cases when a focus event occurs without\n    // a preceding user event (e.g. screen reader focus). Overriding the focus\n    // method on HTMLElement.prototype is a bit hacky, but works.\n    let focus = HTMLElement.prototype.focus;\n    HTMLElement.prototype.focus = function() {\n        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n        focus.apply(this, arguments);\n    };\n    document.addEventListener(\"keydown\", $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n    document.addEventListener(\"keyup\", $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n    document.addEventListener(\"click\", $507fabe10e71c6fb$var$handleClickEvent, true);\n    // Register focus events on the window so they are sure to happen\n    // before React's event listeners (registered on the document).\n    window.addEventListener(\"focus\", $507fabe10e71c6fb$var$handleFocusEvent, true);\n    window.addEventListener(\"blur\", $507fabe10e71c6fb$var$handleWindowBlur, false);\n    if (typeof PointerEvent !== \"undefined\") {\n        document.addEventListener(\"pointerdown\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener(\"pointermove\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener(\"pointerup\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n    } else {\n        document.addEventListener(\"mousedown\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener(\"mousemove\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener(\"mouseup\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n    }\n    $507fabe10e71c6fb$var$hasSetupGlobalListeners = true;\n}\nif (typeof document !== \"undefined\") {\n    if (document.readyState !== \"loading\") $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n    else document.addEventListener(\"DOMContentLoaded\", $507fabe10e71c6fb$var$setupGlobalFocusEvents);\n}\nfunction $507fabe10e71c6fb$export$b9b3dfddab17db27() {\n    return $507fabe10e71c6fb$var$currentModality !== \"pointer\";\n}\nfunction $507fabe10e71c6fb$export$630ff653c5ada6a9() {\n    return $507fabe10e71c6fb$var$currentModality;\n}\nfunction $507fabe10e71c6fb$export$8397ddfc504fdb9a(modality) {\n    $507fabe10e71c6fb$var$currentModality = modality;\n    $507fabe10e71c6fb$var$triggerChangeHandlers(modality, null);\n}\nfunction $507fabe10e71c6fb$export$98e20ec92f614cfe() {\n    $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n    let [modality, setModality] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)($507fabe10e71c6fb$var$currentModality);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let handler = ()=>{\n            setModality($507fabe10e71c6fb$var$currentModality);\n        };\n        $507fabe10e71c6fb$var$changeHandlers.add(handler);\n        return ()=>{\n            $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n        };\n    }, []);\n    return (0, _react_aria_ssr__WEBPACK_IMPORTED_MODULE_5__.useIsSSR)() ? null : modality;\n}\nconst $507fabe10e71c6fb$var$nonTextInputTypes = new Set([\n    \"checkbox\",\n    \"radio\",\n    \"range\",\n    \"color\",\n    \"file\",\n    \"image\",\n    \"button\",\n    \"submit\",\n    \"reset\"\n]);\n/**\n * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that\n * focus visible style can be properly set.\n */ function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e) {\n    var _e_target;\n    isTextInput = isTextInput || (e === null || e === void 0 ? void 0 : e.target) instanceof HTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(e === null || e === void 0 ? void 0 : (_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.type) || (e === null || e === void 0 ? void 0 : e.target) instanceof HTMLTextAreaElement || (e === null || e === void 0 ? void 0 : e.target) instanceof HTMLElement && (e === null || e === void 0 ? void 0 : e.target.isContentEditable);\n    return !(isTextInput && modality === \"keyboard\" && e instanceof KeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);\n}\nfunction $507fabe10e71c6fb$export$ffd9e5021c1fb2d6(props = {}) {\n    let { isTextInput: isTextInput, autoFocus: autoFocus } = props;\n    let [isFocusVisibleState, setFocusVisible] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(autoFocus || $507fabe10e71c6fb$export$b9b3dfddab17db27());\n    $507fabe10e71c6fb$export$ec71b4b83ac08ec3((isFocusVisible)=>{\n        setFocusVisible(isFocusVisible);\n    }, [\n        isTextInput\n    ], {\n        isTextInput: isTextInput\n    });\n    return {\n        isFocusVisible: isFocusVisibleState\n    };\n}\nfunction $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {\n    $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let handler = (modality, e)=>{\n            if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e)) return;\n            fn($507fabe10e71c6fb$export$b9b3dfddab17db27());\n        };\n        $507fabe10e71c6fb$var$changeHandlers.add(handler);\n        return ()=>{\n            $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, deps);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\nfunction $9ab94262bd0047c7$export$420e68273165f4ec(props) {\n    let { isDisabled: isDisabled, onBlurWithin: onBlurWithin, onFocusWithin: onFocusWithin, onFocusWithinChange: onFocusWithinChange } = props;\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isFocusWithin: false\n    });\n    let onBlur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // We don't want to trigger onBlurWithin and then immediately onFocusWithin again\n        // when moving focus inside the element. Only trigger if the currentTarget doesn't\n        // include the relatedTarget (where focus is moving).\n        if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {\n            state.current.isFocusWithin = false;\n            if (onBlurWithin) onBlurWithin(e);\n            if (onFocusWithinChange) onFocusWithinChange(false);\n        }\n    }, [\n        onBlurWithin,\n        onFocusWithinChange,\n        state\n    ]);\n    let onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);\n    let onFocus = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // Double check that document.activeElement actually matches e.target in case a previously chained\n        // focus handler already moved focus somewhere else.\n        if (!state.current.isFocusWithin && document.activeElement === e.target) {\n            if (onFocusWithin) onFocusWithin(e);\n            if (onFocusWithinChange) onFocusWithinChange(true);\n            state.current.isFocusWithin = true;\n            onSyntheticFocus(e);\n        }\n    }, [\n        onFocusWithin,\n        onFocusWithinChange,\n        onSyntheticFocus\n    ]);\n    if (isDisabled) return {\n        focusWithinProps: {\n            // These should not have been null, that would conflict in mergeProps\n            onFocus: undefined,\n            onBlur: undefined\n        }\n    };\n    return {\n        focusWithinProps: {\n            onFocus: onFocus,\n            onBlur: onBlur\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n// iOS fires onPointerEnter twice: once with pointerType=\"touch\" and again with pointerType=\"mouse\".\n// We want to ignore these emulated events so they do not trigger hover behavior.\n// See https://bugs.webkit.org/show_bug.cgi?id=214609.\nlet $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;\nlet $6179b936705e76d3$var$hoverCount = 0;\nfunction $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {\n    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;\n    // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter\n    // with pointerType=\"mouse\" immediately after onPointerUp and before onFocus. On other\n    // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in\n    // the distant future because a user previously touched the element.\n    setTimeout(()=>{\n        $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;\n    }, 50);\n}\nfunction $6179b936705e76d3$var$handleGlobalPointerEvent(e) {\n    if (e.pointerType === \"touch\") $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();\n}\nfunction $6179b936705e76d3$var$setupGlobalTouchEvents() {\n    if (typeof document === \"undefined\") return;\n    if (typeof PointerEvent !== \"undefined\") document.addEventListener(\"pointerup\", $6179b936705e76d3$var$handleGlobalPointerEvent);\n    else document.addEventListener(\"touchend\", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);\n    $6179b936705e76d3$var$hoverCount++;\n    return ()=>{\n        $6179b936705e76d3$var$hoverCount--;\n        if ($6179b936705e76d3$var$hoverCount > 0) return;\n        if (typeof PointerEvent !== \"undefined\") document.removeEventListener(\"pointerup\", $6179b936705e76d3$var$handleGlobalPointerEvent);\n        else document.removeEventListener(\"touchend\", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);\n    };\n}\nfunction $6179b936705e76d3$export$ae780daf29e6d456(props) {\n    let { onHoverStart: onHoverStart, onHoverChange: onHoverChange, onHoverEnd: onHoverEnd, isDisabled: isDisabled } = props;\n    let [isHovered, setHovered] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isHovered: false,\n        ignoreEmulatedMouseEvents: false,\n        pointerType: \"\",\n        target: null\n    }).current;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)($6179b936705e76d3$var$setupGlobalTouchEvents, []);\n    let { hoverProps: hoverProps, triggerHoverEnd: triggerHoverEnd } = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let triggerHoverStart = (event, pointerType)=>{\n            state.pointerType = pointerType;\n            if (isDisabled || pointerType === \"touch\" || state.isHovered || !event.currentTarget.contains(event.target)) return;\n            state.isHovered = true;\n            let target = event.currentTarget;\n            state.target = target;\n            if (onHoverStart) onHoverStart({\n                type: \"hoverstart\",\n                target: target,\n                pointerType: pointerType\n            });\n            if (onHoverChange) onHoverChange(true);\n            setHovered(true);\n        };\n        let triggerHoverEnd = (event, pointerType)=>{\n            state.pointerType = \"\";\n            state.target = null;\n            if (pointerType === \"touch\" || !state.isHovered) return;\n            state.isHovered = false;\n            let target = event.currentTarget;\n            if (onHoverEnd) onHoverEnd({\n                type: \"hoverend\",\n                target: target,\n                pointerType: pointerType\n            });\n            if (onHoverChange) onHoverChange(false);\n            setHovered(false);\n        };\n        let hoverProps = {};\n        if (typeof PointerEvent !== \"undefined\") {\n            hoverProps.onPointerEnter = (e)=>{\n                if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e.pointerType === \"mouse\") return;\n                triggerHoverStart(e, e.pointerType);\n            };\n            hoverProps.onPointerLeave = (e)=>{\n                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);\n            };\n        } else {\n            hoverProps.onTouchStart = ()=>{\n                state.ignoreEmulatedMouseEvents = true;\n            };\n            hoverProps.onMouseEnter = (e)=>{\n                if (!state.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e, \"mouse\");\n                state.ignoreEmulatedMouseEvents = false;\n            };\n            hoverProps.onMouseLeave = (e)=>{\n                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, \"mouse\");\n            };\n        }\n        return {\n            hoverProps: hoverProps,\n            triggerHoverEnd: triggerHoverEnd\n        };\n    }, [\n        onHoverStart,\n        onHoverChange,\n        onHoverEnd,\n        isDisabled,\n        state\n    ]);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Call the triggerHoverEnd as soon as isDisabled changes to true\n        // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering\n        if (isDisabled) triggerHoverEnd({\n            currentTarget: state.target\n        }, state.pointerType);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled\n    ]);\n    return {\n        hoverProps: hoverProps,\n        isHovered: isHovered\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\nfunction $e0b6e0b68ec7f50f$export$872b660ac5a1ff98(props) {\n    let { ref: ref, onInteractOutside: onInteractOutside, isDisabled: isDisabled, onInteractOutsideStart: onInteractOutsideStart } = props;\n    let stateRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isPointerDown: false,\n        ignoreEmulatedMouseEvents: false\n    });\n    let onPointerDown = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        if (onInteractOutside && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) {\n            if (onInteractOutsideStart) onInteractOutsideStart(e);\n            stateRef.current.isPointerDown = true;\n        }\n    });\n    let triggerInteractOutside = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((e)=>{\n        if (onInteractOutside) onInteractOutside(e);\n    });\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let state = stateRef.current;\n        if (isDisabled) return;\n        const element = ref.current;\n        const documentObject = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.getOwnerDocument)(element);\n        // Use pointer events if available. Otherwise, fall back to mouse and touch events.\n        if (typeof PointerEvent !== \"undefined\") {\n            let onPointerUp = (e)=>{\n                if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n                state.isPointerDown = false;\n            };\n            // changing these to capture phase fixed combobox\n            documentObject.addEventListener(\"pointerdown\", onPointerDown, true);\n            documentObject.addEventListener(\"pointerup\", onPointerUp, true);\n            return ()=>{\n                documentObject.removeEventListener(\"pointerdown\", onPointerDown, true);\n                documentObject.removeEventListener(\"pointerup\", onPointerUp, true);\n            };\n        } else {\n            let onMouseUp = (e)=>{\n                if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;\n                else if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n                state.isPointerDown = false;\n            };\n            let onTouchEnd = (e)=>{\n                state.ignoreEmulatedMouseEvents = true;\n                if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n                state.isPointerDown = false;\n            };\n            documentObject.addEventListener(\"mousedown\", onPointerDown, true);\n            documentObject.addEventListener(\"mouseup\", onMouseUp, true);\n            documentObject.addEventListener(\"touchstart\", onPointerDown, true);\n            documentObject.addEventListener(\"touchend\", onTouchEnd, true);\n            return ()=>{\n                documentObject.removeEventListener(\"mousedown\", onPointerDown, true);\n                documentObject.removeEventListener(\"mouseup\", onMouseUp, true);\n                documentObject.removeEventListener(\"touchstart\", onPointerDown, true);\n                documentObject.removeEventListener(\"touchend\", onTouchEnd, true);\n            };\n        }\n    }, [\n        ref,\n        isDisabled,\n        onPointerDown,\n        triggerInteractOutside\n    ]);\n}\nfunction $e0b6e0b68ec7f50f$var$isValidEvent(event, ref) {\n    if (event.button > 0) return false;\n    if (event.target) {\n        // if the event target is no longer in the document, ignore\n        const ownerDocument = event.target.ownerDocument;\n        if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false;\n        // If the target is within a top layer element (e.g. toasts), ignore.\n        if (event.target.closest(\"[data-react-aria-top-layer]\")) return false;\n    }\n    return ref.current && !ref.current.contains(event.target);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $93925083ecbb358c$export$48d1ea6320830260(handler) {\n    if (!handler) return undefined;\n    let shouldStopPropagation = true;\n    return (e)=>{\n        let event = {\n            ...e,\n            preventDefault () {\n                e.preventDefault();\n            },\n            isDefaultPrevented () {\n                return e.isDefaultPrevented();\n            },\n            stopPropagation () {\n                console.error(\"stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.\");\n            },\n            continuePropagation () {\n                shouldStopPropagation = false;\n            }\n        };\n        handler(event);\n        if (shouldStopPropagation) e.stopPropagation();\n    };\n}\nfunction $46d819fcbaf35654$export$8f71654801c2f7cd(props) {\n    return {\n        keyboardProps: props.isDisabled ? {} : {\n            onKeyDown: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyDown),\n            onKeyUp: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyUp)\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $e8a7022cf87cba2a$export$36da96379f79f245(props) {\n    let { onMoveStart: onMoveStart, onMove: onMove, onMoveEnd: onMoveEnd } = props;\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        didMove: false,\n        lastPosition: null,\n        id: null\n    });\n    let { addGlobalListener: addGlobalListener, removeGlobalListener: removeGlobalListener } = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useGlobalListeners)();\n    let move = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType, deltaX, deltaY)=>{\n        if (deltaX === 0 && deltaY === 0) return;\n        if (!state.current.didMove) {\n            state.current.didMove = true;\n            onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart({\n                type: \"movestart\",\n                pointerType: pointerType,\n                shiftKey: originalEvent.shiftKey,\n                metaKey: originalEvent.metaKey,\n                ctrlKey: originalEvent.ctrlKey,\n                altKey: originalEvent.altKey\n            });\n        }\n        onMove === null || onMove === void 0 ? void 0 : onMove({\n            type: \"move\",\n            pointerType: pointerType,\n            deltaX: deltaX,\n            deltaY: deltaY,\n            shiftKey: originalEvent.shiftKey,\n            metaKey: originalEvent.metaKey,\n            ctrlKey: originalEvent.ctrlKey,\n            altKey: originalEvent.altKey\n        });\n    });\n    let end = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEffectEvent)((originalEvent, pointerType)=>{\n        (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)();\n        if (state.current.didMove) onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd({\n            type: \"moveend\",\n            pointerType: pointerType,\n            shiftKey: originalEvent.shiftKey,\n            metaKey: originalEvent.metaKey,\n            ctrlKey: originalEvent.ctrlKey,\n            altKey: originalEvent.altKey\n        });\n    });\n    let moveProps = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let moveProps = {};\n        let start = ()=>{\n            (0, $14c0b72509d70225$export$16a4697467175487)();\n            state.current.didMove = false;\n        };\n        if (typeof PointerEvent === \"undefined\") {\n            let onMouseMove = (e)=>{\n                if (e.button === 0) {\n                    var _state_current_lastPosition, _state_current_lastPosition1;\n                    var _state_current_lastPosition_pageX, _state_current_lastPosition_pageY;\n                    move(e, \"mouse\", e.pageX - ((_state_current_lastPosition_pageX = (_state_current_lastPosition = state.current.lastPosition) === null || _state_current_lastPosition === void 0 ? void 0 : _state_current_lastPosition.pageX) !== null && _state_current_lastPosition_pageX !== void 0 ? _state_current_lastPosition_pageX : 0), e.pageY - ((_state_current_lastPosition_pageY = (_state_current_lastPosition1 = state.current.lastPosition) === null || _state_current_lastPosition1 === void 0 ? void 0 : _state_current_lastPosition1.pageY) !== null && _state_current_lastPosition_pageY !== void 0 ? _state_current_lastPosition_pageY : 0));\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                }\n            };\n            let onMouseUp = (e)=>{\n                if (e.button === 0) {\n                    end(e, \"mouse\");\n                    removeGlobalListener(window, \"mousemove\", onMouseMove, false);\n                    removeGlobalListener(window, \"mouseup\", onMouseUp, false);\n                }\n            };\n            moveProps.onMouseDown = (e)=>{\n                if (e.button === 0) {\n                    start();\n                    e.stopPropagation();\n                    e.preventDefault();\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                    addGlobalListener(window, \"mousemove\", onMouseMove, false);\n                    addGlobalListener(window, \"mouseup\", onMouseUp, false);\n                }\n            };\n            let onTouchMove = (e)=>{\n                let touch = [\n                    ...e.changedTouches\n                ].findIndex(({ identifier: identifier })=>identifier === state.current.id);\n                if (touch >= 0) {\n                    var _state_current_lastPosition, _state_current_lastPosition1;\n                    let { pageX: pageX, pageY: pageY } = e.changedTouches[touch];\n                    var _state_current_lastPosition_pageX, _state_current_lastPosition_pageY;\n                    move(e, \"touch\", pageX - ((_state_current_lastPosition_pageX = (_state_current_lastPosition = state.current.lastPosition) === null || _state_current_lastPosition === void 0 ? void 0 : _state_current_lastPosition.pageX) !== null && _state_current_lastPosition_pageX !== void 0 ? _state_current_lastPosition_pageX : 0), pageY - ((_state_current_lastPosition_pageY = (_state_current_lastPosition1 = state.current.lastPosition) === null || _state_current_lastPosition1 === void 0 ? void 0 : _state_current_lastPosition1.pageY) !== null && _state_current_lastPosition_pageY !== void 0 ? _state_current_lastPosition_pageY : 0));\n                    state.current.lastPosition = {\n                        pageX: pageX,\n                        pageY: pageY\n                    };\n                }\n            };\n            let onTouchEnd = (e)=>{\n                let touch = [\n                    ...e.changedTouches\n                ].findIndex(({ identifier: identifier })=>identifier === state.current.id);\n                if (touch >= 0) {\n                    end(e, \"touch\");\n                    state.current.id = null;\n                    removeGlobalListener(window, \"touchmove\", onTouchMove);\n                    removeGlobalListener(window, \"touchend\", onTouchEnd);\n                    removeGlobalListener(window, \"touchcancel\", onTouchEnd);\n                }\n            };\n            moveProps.onTouchStart = (e)=>{\n                if (e.changedTouches.length === 0 || state.current.id != null) return;\n                let { pageX: pageX, pageY: pageY, identifier: identifier } = e.changedTouches[0];\n                start();\n                e.stopPropagation();\n                e.preventDefault();\n                state.current.lastPosition = {\n                    pageX: pageX,\n                    pageY: pageY\n                };\n                state.current.id = identifier;\n                addGlobalListener(window, \"touchmove\", onTouchMove, false);\n                addGlobalListener(window, \"touchend\", onTouchEnd, false);\n                addGlobalListener(window, \"touchcancel\", onTouchEnd, false);\n            };\n        } else {\n            let onPointerMove = (e)=>{\n                if (e.pointerId === state.current.id) {\n                    var _state_current_lastPosition, _state_current_lastPosition1;\n                    let pointerType = e.pointerType || \"mouse\";\n                    var _state_current_lastPosition_pageX, _state_current_lastPosition_pageY;\n                    // Problems with PointerEvent#movementX/movementY:\n                    // 1. it is always 0 on macOS Safari.\n                    // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS\n                    move(e, pointerType, e.pageX - ((_state_current_lastPosition_pageX = (_state_current_lastPosition = state.current.lastPosition) === null || _state_current_lastPosition === void 0 ? void 0 : _state_current_lastPosition.pageX) !== null && _state_current_lastPosition_pageX !== void 0 ? _state_current_lastPosition_pageX : 0), e.pageY - ((_state_current_lastPosition_pageY = (_state_current_lastPosition1 = state.current.lastPosition) === null || _state_current_lastPosition1 === void 0 ? void 0 : _state_current_lastPosition1.pageY) !== null && _state_current_lastPosition_pageY !== void 0 ? _state_current_lastPosition_pageY : 0));\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                }\n            };\n            let onPointerUp = (e)=>{\n                if (e.pointerId === state.current.id) {\n                    let pointerType = e.pointerType || \"mouse\";\n                    end(e, pointerType);\n                    state.current.id = null;\n                    removeGlobalListener(window, \"pointermove\", onPointerMove, false);\n                    removeGlobalListener(window, \"pointerup\", onPointerUp, false);\n                    removeGlobalListener(window, \"pointercancel\", onPointerUp, false);\n                }\n            };\n            moveProps.onPointerDown = (e)=>{\n                if (e.button === 0 && state.current.id == null) {\n                    start();\n                    e.stopPropagation();\n                    e.preventDefault();\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                    state.current.id = e.pointerId;\n                    addGlobalListener(window, \"pointermove\", onPointerMove, false);\n                    addGlobalListener(window, \"pointerup\", onPointerUp, false);\n                    addGlobalListener(window, \"pointercancel\", onPointerUp, false);\n                }\n            };\n        }\n        let triggerKeyboardMove = (e, deltaX, deltaY)=>{\n            start();\n            move(e, \"keyboard\", deltaX, deltaY);\n            end(e, \"keyboard\");\n        };\n        moveProps.onKeyDown = (e)=>{\n            switch(e.key){\n                case \"Left\":\n                case \"ArrowLeft\":\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, -1, 0);\n                    break;\n                case \"Right\":\n                case \"ArrowRight\":\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, 1, 0);\n                    break;\n                case \"Up\":\n                case \"ArrowUp\":\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, 0, -1);\n                    break;\n                case \"Down\":\n                case \"ArrowDown\":\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, 0, 1);\n                    break;\n            }\n        };\n        return moveProps;\n    }, [\n        state,\n        addGlobalListener,\n        removeGlobalListener,\n        move,\n        end\n    ]);\n    return {\n        moveProps: moveProps\n    };\n}\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $7d0a636d7a4dcefd$export$2123ff2b87c81ca(props, ref) {\n    let { onScroll: onScroll, isDisabled: isDisabled } = props;\n    let onScrollHandler = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // If the ctrlKey is pressed, this is a zoom event, do nothing.\n        if (e.ctrlKey) return;\n        // stop scrolling the page\n        e.preventDefault();\n        e.stopPropagation();\n        if (onScroll) onScroll({\n            deltaX: e.deltaX,\n            deltaY: e.deltaY\n        });\n    }, [\n        onScroll\n    ]);\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useEvent)(ref, \"wheel\", isDisabled ? undefined : onScrollHandler);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $8a26561d2877236e$var$DEFAULT_THRESHOLD = 500;\nfunction $8a26561d2877236e$export$c24ed0104d07eab9(props) {\n    let { isDisabled: isDisabled, onLongPressStart: onLongPressStart, onLongPressEnd: onLongPressEnd, onLongPress: onLongPress, threshold: threshold = $8a26561d2877236e$var$DEFAULT_THRESHOLD, accessibilityDescription: accessibilityDescription } = props;\n    const timeRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    let { addGlobalListener: addGlobalListener, removeGlobalListener: removeGlobalListener } = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useGlobalListeners)();\n    let { pressProps: pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({\n        isDisabled: isDisabled,\n        onPressStart (e) {\n            e.continuePropagation();\n            if (e.pointerType === \"mouse\" || e.pointerType === \"touch\") {\n                if (onLongPressStart) onLongPressStart({\n                    ...e,\n                    type: \"longpressstart\"\n                });\n                timeRef.current = setTimeout(()=>{\n                    // Prevent other usePress handlers from also handling this event.\n                    e.target.dispatchEvent(new PointerEvent(\"pointercancel\", {\n                        bubbles: true\n                    }));\n                    if (onLongPress) onLongPress({\n                        ...e,\n                        type: \"longpress\"\n                    });\n                    timeRef.current = undefined;\n                }, threshold);\n                // Prevent context menu, which may be opened on long press on touch devices\n                if (e.pointerType === \"touch\") {\n                    let onContextMenu = (e)=>{\n                        e.preventDefault();\n                    };\n                    addGlobalListener(e.target, \"contextmenu\", onContextMenu, {\n                        once: true\n                    });\n                    addGlobalListener(window, \"pointerup\", ()=>{\n                        // If no contextmenu event is fired quickly after pointerup, remove the handler\n                        // so future context menu events outside a long press are not prevented.\n                        setTimeout(()=>{\n                            removeGlobalListener(e.target, \"contextmenu\", onContextMenu);\n                        }, 30);\n                    }, {\n                        once: true\n                    });\n                }\n            }\n        },\n        onPressEnd (e) {\n            if (timeRef.current) clearTimeout(timeRef.current);\n            if (onLongPressEnd && (e.pointerType === \"mouse\" || e.pointerType === \"touch\")) onLongPressEnd({\n                ...e,\n                type: \"longpressend\"\n            });\n        }\n    });\n    let descriptionProps = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useDescription)(onLongPress && !isDisabled ? accessibilityDescription : undefined);\n    return {\n        longPressProps: (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.mergeProps)(pressProps, descriptionProps)\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvaW50ZXJhY3Rpb25zL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNHJCO0FBQ3JlO0FBQ2pKO0FBQ0U7QUFDRDtBQUNYO0FBRTVEOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQ0Q7Ozs7Ozs7Ozs7Q0FVQyxHQUFHLGtFQUFrRTtBQUN0RSwyREFBMkQ7QUFDM0QseURBQXlEO0FBQ3pELGtIQUFrSDtBQUlsSDs7Ozs7Ozs7OztDQVVDLEdBQ0QsMEdBQTBHO0FBQzFHLDRIQUE0SDtBQUM1SCxJQUFJcUQsOEJBQThCO0FBQ2xDLElBQUlDLHdDQUF3QztBQUM1QyxJQUFJQywyQ0FBMkMsSUFBSUM7QUFDbkQsU0FBU0MsMENBQTBDQyxNQUFNO0lBQ3JELElBQUksQ0FBQyxHQUFHakMsb0RBQVcsS0FBTTtRQUNyQixJQUFJNEIsZ0NBQWdDLFdBQVc7WUFDM0MsaURBQWlEO1lBQ2pELE1BQU1NLGlCQUFpQixDQUFDLEdBQUdoRCwrREFBc0IsRUFBRytDO1lBQ3BESix3Q0FBd0NLLGVBQWVDLGVBQWUsQ0FBQ0MsS0FBSyxDQUFDQyxnQkFBZ0I7WUFDN0ZILGVBQWVDLGVBQWUsQ0FBQ0MsS0FBSyxDQUFDQyxnQkFBZ0IsR0FBRztRQUM1RDtRQUNBVCw4QkFBOEI7SUFDbEMsT0FBTyxJQUFJSyxrQkFBa0JLLGVBQWVMLGtCQUFrQk0sWUFBWTtRQUN0RSxzRkFBc0Y7UUFDdEYsa0RBQWtEO1FBQ2xEVCx5Q0FBeUNVLEdBQUcsQ0FBQ1AsUUFBUUEsT0FBT0csS0FBSyxDQUFDSyxVQUFVO1FBQzVFUixPQUFPRyxLQUFLLENBQUNLLFVBQVUsR0FBRztJQUM5QjtBQUNKO0FBQ0EsU0FBU0MsMENBQTBDVCxNQUFNO0lBQ3JELElBQUksQ0FBQyxHQUFHakMsb0RBQVcsS0FBTTtRQUNyQiwwREFBMEQ7UUFDMUQsc0VBQXNFO1FBQ3RFLElBQUk0Qixn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LHFCQUFxQnRPLEVBQUV6RSxNQUFNLEVBQUUsZUFBZXlVO3dCQUNsRCxHQUFHO29CQUNQLEdBQUc7d0JBQ0NoSSxNQUFNO29CQUNWO2dCQUNKO1lBQ0o7UUFDSjtRQUNBMUosWUFBWTBCLENBQUM7WUFDVCxJQUFJK1AsUUFBUXJRLE9BQU8sRUFBRXVRLGFBQWFGLFFBQVFyUSxPQUFPO1lBQ2pELElBQUlpUSxrQkFBbUIzUCxDQUFBQSxFQUFFekMsV0FBVyxLQUFLLFdBQVd5QyxFQUFFekMsV0FBVyxLQUFLLE9BQU0sR0FBSW9TLGVBQWU7Z0JBQzNGLEdBQUczUCxDQUFDO2dCQUNKMUMsTUFBTTtZQUNWO1FBQ0o7SUFDSjtJQUNBLElBQUk0UyxtQkFBbUIsQ0FBQyxHQUFHcFcsNkRBQW9CLEVBQUc4VixlQUFlLENBQUNwUixhQUFhc1IsMkJBQTJCbE87SUFDMUcsT0FBTztRQUNIdU8sZ0JBQWdCLENBQUMsR0FBR25ZLHlEQUFnQixFQUFHbUksWUFBWStQO0lBQ3ZEO0FBQ0o7QUFLeWxDLENBQ3psQyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmljZWZldGNoLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL2ludGVyYWN0aW9ucy9kaXN0L2ltcG9ydC5tanM/NTM2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZU9iamVjdFJlZiBhcyAkYng3U0wkdXNlT2JqZWN0UmVmLCBtZXJnZVByb3BzIGFzICRieDdTTCRtZXJnZVByb3BzLCB1c2VTeW5jUmVmIGFzICRieDdTTCR1c2VTeW5jUmVmLCB1c2VHbG9iYWxMaXN0ZW5lcnMgYXMgJGJ4N1NMJHVzZUdsb2JhbExpc3RlbmVycywgdXNlRWZmZWN0RXZlbnQgYXMgJGJ4N1NMJHVzZUVmZmVjdEV2ZW50LCBnZXRPd25lckRvY3VtZW50IGFzICRieDdTTCRnZXRPd25lckRvY3VtZW50LCBpc01hYyBhcyAkYng3U0wkaXNNYWMsIG9wZW5MaW5rIGFzICRieDdTTCRvcGVuTGluaywgaXNWaXJ0dWFsQ2xpY2sgYXMgJGJ4N1NMJGlzVmlydHVhbENsaWNrLCBmb2N1c1dpdGhvdXRTY3JvbGxpbmcgYXMgJGJ4N1NMJGZvY3VzV2l0aG91dFNjcm9sbGluZywgaXNWaXJ0dWFsUG9pbnRlckV2ZW50IGFzICRieDdTTCRpc1ZpcnR1YWxQb2ludGVyRXZlbnQsIGdldE93bmVyV2luZG93IGFzICRieDdTTCRnZXRPd25lcldpbmRvdywgaXNJT1MgYXMgJGJ4N1NMJGlzSU9TLCBydW5BZnRlclRyYW5zaXRpb24gYXMgJGJ4N1NMJHJ1bkFmdGVyVHJhbnNpdGlvbiwgdXNlTGF5b3V0RWZmZWN0IGFzICRieDdTTCR1c2VMYXlvdXRFZmZlY3QsIHVzZUV2ZW50IGFzICRieDdTTCR1c2VFdmVudCwgdXNlRGVzY3JpcHRpb24gYXMgJGJ4N1NMJHVzZURlc2NyaXB0aW9ufSBmcm9tIFwiQHJlYWN0LWFyaWEvdXRpbHNcIjtcbmltcG9ydCAkYng3U0wkcmVhY3QsIHt1c2VDb250ZXh0IGFzICRieDdTTCR1c2VDb250ZXh0LCB1c2VTdGF0ZSBhcyAkYng3U0wkdXNlU3RhdGUsIHVzZVJlZiBhcyAkYng3U0wkdXNlUmVmLCB1c2VNZW1vIGFzICRieDdTTCR1c2VNZW1vLCB1c2VFZmZlY3QgYXMgJGJ4N1NMJHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgYXMgJGJ4N1NMJHVzZUNhbGxiYWNrfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XyBhcyAkYng3U0wkX30gZnJvbSBcIkBzd2MvaGVscGVycy9fL19jbGFzc19wcml2YXRlX2ZpZWxkX2dldFwiO1xuaW1wb3J0IHtfIGFzICRieDdTTCRfMX0gZnJvbSBcIkBzd2MvaGVscGVycy9fL19jbGFzc19wcml2YXRlX2ZpZWxkX2luaXRcIjtcbmltcG9ydCB7XyBhcyAkYng3U0wkXzJ9IGZyb20gXCJAc3djL2hlbHBlcnMvXy9fY2xhc3NfcHJpdmF0ZV9maWVsZF9zZXRcIjtcbmltcG9ydCB7dXNlSXNTU1IgYXMgJGJ4N1NMJHVzZUlzU1NSfSBmcm9tIFwiQHJlYWN0LWFyaWEvc3NyXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gcmVhY3QuXG4vLyBPcmlnaW5hbCBsaWNlbnNpbmcgZm9yIHRoZSBmb2xsb3dpbmcgY2FuIGJlIGZvdW5kIGluIHRoZVxuLy8gTk9USUNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3RyZWUvY2M3YzFhZWNlNDZhNmI2OWI0MTk1OGQ3MzFlMGZkMjdjOTRiZmM2Yy9wYWNrYWdlcy9yZWFjdC1pbnRlcmFjdGlvbnNcblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbi8vIE5vdGUgdGhhdCBzdGF0ZSBvbmx5IG1hdHRlcnMgaGVyZSBmb3IgaU9TLiBOb24taU9TIGdldHMgdXNlci1zZWxlY3Q6IG5vbmUgYXBwbGllZCB0byB0aGUgdGFyZ2V0IGVsZW1lbnRcbi8vIHJhdGhlciB0aGFuIGF0IHRoZSBkb2N1bWVudCBsZXZlbCBzbyB3ZSBqdXN0IG5lZWQgdG8gYXBwbHkvcmVtb3ZlIHVzZXItc2VsZWN0OiBub25lIGZvciBlYWNoIHByZXNzZWQgZWxlbWVudCBpbmRpdmlkdWFsbHlcbmxldCAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc3RhdGUgPSBcImRlZmF1bHRcIjtcbmxldCAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc2F2ZWRVc2VyU2VsZWN0ID0gXCJcIjtcbmxldCAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkbW9kaWZpZWRFbGVtZW50TWFwID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uICQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCQxNmE0Njk3NDY3MTc1NDg3KHRhcmdldCkge1xuICAgIGlmICgoMCwgJGJ4N1NMJGlzSU9TKSgpKSB7XG4gICAgICAgIGlmICgkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc3RhdGUgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudE9iamVjdCA9ICgwLCAkYng3U0wkZ2V0T3duZXJEb2N1bWVudCkodGFyZ2V0KTtcbiAgICAgICAgICAgICQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzYXZlZFVzZXJTZWxlY3QgPSBkb2N1bWVudE9iamVjdC5kb2N1bWVudEVsZW1lbnQuc3R5bGUud2Via2l0VXNlclNlbGVjdDtcbiAgICAgICAgICAgIGRvY3VtZW50T2JqZWN0LmRvY3VtZW50RWxlbWVudC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gXCJub25lXCI7XG4gICAgICAgIH1cbiAgICAgICAgJDE0YzBiNzI1MDlkNzAyMjUkdmFyJHN0YXRlID0gXCJkaXNhYmxlZFwiO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgICAgICAvLyBJZiBub3QgaU9TLCBzdG9yZSB0aGUgdGFyZ2V0J3Mgb3JpZ2luYWwgdXNlci1zZWxlY3QgYW5kIGNoYW5nZSB0byB1c2VyLXNlbGVjdDogbm9uZVxuICAgICAgICAvLyBJZ25vcmUgc3RhdGUgc2luY2UgaXQgZG9lc24ndCBhcHBseSBmb3Igbm9uIGlPU1xuICAgICAgICAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkbW9kaWZpZWRFbGVtZW50TWFwLnNldCh0YXJnZXQsIHRhcmdldC5zdHlsZS51c2VyU2VsZWN0KTtcbiAgICAgICAgdGFyZ2V0LnN0eWxlLnVzZXJTZWxlY3QgPSBcIm5vbmVcIjtcbiAgICB9XG59XG5mdW5jdGlvbiAkMTRjMGI3MjUwOWQ3MDIyNSRleHBvcnQkYjBkNmZhMWFiMzJlMzI5NSh0YXJnZXQpIHtcbiAgICBpZiAoKDAsICRieDdTTCRpc0lPUykoKSkge1xuICAgICAgICAvLyBJZiB0aGUgc3RhdGUgaXMgYWxyZWFkeSBkZWZhdWx0LCB0aGVyZSdzIG5vdGhpbmcgdG8gZG8uXG4gICAgICAgIC8vIElmIGl0IGlzIHJlc3RvcmluZywgdGhlbiB0aGVyZSdzIG5vIG5lZWQgdG8gcXVldWUgYSBzZWNvbmQgcmVzdG9yZS5cbiAgICAgICAgaWYgKCQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzdGF0ZSAhPT0gXCJkaXNhYmxlZFwiKSByZXR1cm47XG4gICAgICAgICQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzdGF0ZSA9IFwicmVzdG9yaW5nXCI7XG4gICAgICAgIC8vIFRoZXJlIGFwcGVhcnMgdG8gYmUgYSBkZWxheSBvbiBpT1Mgd2hlcmUgc2VsZWN0aW9uIHN0aWxsIG1pZ2h0IG9jY3VyXG4gICAgICAgIC8vIGFmdGVyIHBvaW50ZXIgdXAsIHNvIHdhaXQgYSBiaXQgYmVmb3JlIHJlbW92aW5nIHVzZXItc2VsZWN0LlxuICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAvLyBXYWl0IGZvciBhbnkgQ1NTIHRyYW5zaXRpb25zIHRvIGNvbXBsZXRlIHNvIHdlIGRvbid0IHJlY29tcHV0ZSBzdHlsZVxuICAgICAgICAgICAgLy8gZm9yIHRoZSB3aG9sZSBwYWdlIGluIHRoZSBtaWRkbGUgb2YgdGhlIGFuaW1hdGlvbiBhbmQgY2F1c2UgamFuay5cbiAgICAgICAgICAgICgwLCAkYng3U0wkcnVuQWZ0ZXJUcmFuc2l0aW9uKSgoKT0+e1xuICAgICAgICAgICAgICAgIC8vIEF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIGlmICgkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc3RhdGUgPT09IFwicmVzdG9yaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudE9iamVjdCA9ICgwLCAkYng3U0wkZ2V0T3duZXJEb2N1bWVudCkodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50T2JqZWN0LmRvY3VtZW50RWxlbWVudC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID09PSBcIm5vbmVcIikgZG9jdW1lbnRPYmplY3QuZG9jdW1lbnRFbGVtZW50LnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc2F2ZWRVc2VyU2VsZWN0IHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzYXZlZFVzZXJTZWxlY3QgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkc3RhdGUgPSBcImRlZmF1bHRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMzAwKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIC8vIElmIG5vdCBpT1MsIHJlc3RvcmUgdGhlIHRhcmdldCdzIG9yaWdpbmFsIHVzZXItc2VsZWN0IGlmIGFueVxuICAgIC8vIElnbm9yZSBzdGF0ZSBzaW5jZSBpdCBkb2Vzbid0IGFwcGx5IGZvciBub24gaU9TXG4gICAge1xuICAgICAgICBpZiAodGFyZ2V0ICYmICQxNGMwYjcyNTA5ZDcwMjI1JHZhciRtb2RpZmllZEVsZW1lbnRNYXAuaGFzKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXRPbGRVc2VyU2VsZWN0ID0gJDE0YzBiNzI1MDlkNzAyMjUkdmFyJG1vZGlmaWVkRWxlbWVudE1hcC5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQuc3R5bGUudXNlclNlbGVjdCA9PT0gXCJub25lXCIgJiYgdGFyZ2V0T2xkVXNlclNlbGVjdCkgdGFyZ2V0LnN0eWxlLnVzZXJTZWxlY3QgPSB0YXJnZXRPbGRVc2VyU2VsZWN0O1xuICAgICAgICAgICAgaWYgKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSA9PT0gXCJcIikgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgICAgICAgICAgJDE0YzBiNzI1MDlkNzAyMjUkdmFyJG1vZGlmaWVkRWxlbWVudE1hcC5kZWxldGUodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmNvbnN0ICRhZTFlZWJhOGI5ZWFmZDA4JGV4cG9ydCQ1MTY1ZWNjYjM1YWFhZGI1ID0gKDAsICRieDdTTCRyZWFjdCkuY3JlYXRlQ29udGV4dCh7XG4gICAgcmVnaXN0ZXI6ICgpPT57fVxufSk7XG4kYWUxZWViYThiOWVhZmQwOCRleHBvcnQkNTE2NWVjY2IzNWFhYWRiNS5kaXNwbGF5TmFtZSA9IFwiUHJlc3NSZXNwb25kZXJDb250ZXh0XCI7XG5cblxuXG5mdW5jdGlvbiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkdXNlUHJlc3NSZXNwb25kZXJDb250ZXh0KHByb3BzKSB7XG4gICAgLy8gQ29uc3VtZSBjb250ZXh0IGZyb20gPFByZXNzUmVzcG9uZGVyPiBhbmQgbWVyZ2Ugd2l0aCBwcm9wcy5cbiAgICBsZXQgY29udGV4dCA9ICgwLCAkYng3U0wkdXNlQ29udGV4dCkoKDAsICRhZTFlZWJhOGI5ZWFmZDA4JGV4cG9ydCQ1MTY1ZWNjYjM1YWFhZGI1KSk7XG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHsgcmVnaXN0ZXI6IHJlZ2lzdGVyLCAuLi5jb250ZXh0UHJvcHMgfSA9IGNvbnRleHQ7XG4gICAgICAgIHByb3BzID0gKDAsICRieDdTTCRtZXJnZVByb3BzKShjb250ZXh0UHJvcHMsIHByb3BzKTtcbiAgICAgICAgcmVnaXN0ZXIoKTtcbiAgICB9XG4gICAgKDAsICRieDdTTCR1c2VTeW5jUmVmKShjb250ZXh0LCBwcm9wcy5yZWYpO1xuICAgIHJldHVybiBwcm9wcztcbn1cbnZhciAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkX3Nob3VsZFN0b3BQcm9wYWdhdGlvbiA9IC8qI19fUFVSRV9fKi8gbmV3IFdlYWtNYXAoKTtcbmNsYXNzICRmNmMzMWNjZTJhZGY2NTRmJHZhciRQcmVzc0V2ZW50IHtcbiAgICBjb250aW51ZVByb3BhZ2F0aW9uKCkge1xuICAgICAgICAoMCwgJGJ4N1NMJF8yKSh0aGlzLCAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkX3Nob3VsZFN0b3BQcm9wYWdhdGlvbiwgZmFsc2UpO1xuICAgIH1cbiAgICBnZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gKDAsICRieDdTTCRfKSh0aGlzLCAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkX3Nob3VsZFN0b3BQcm9wYWdhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHBvaW50ZXJUeXBlLCBvcmlnaW5hbEV2ZW50KXtcbiAgICAgICAgKDAsICRieDdTTCRfMSkodGhpcywgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJF9zaG91bGRTdG9wUHJvcGFnYXRpb24sIHtcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgKDAsICRieDdTTCRfMikodGhpcywgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJF9zaG91bGRTdG9wUHJvcGFnYXRpb24sIHRydWUpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGU7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gb3JpZ2luYWxFdmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICB0aGlzLnNoaWZ0S2V5ID0gb3JpZ2luYWxFdmVudC5zaGlmdEtleTtcbiAgICAgICAgdGhpcy5tZXRhS2V5ID0gb3JpZ2luYWxFdmVudC5tZXRhS2V5O1xuICAgICAgICB0aGlzLmN0cmxLZXkgPSBvcmlnaW5hbEV2ZW50LmN0cmxLZXk7XG4gICAgICAgIHRoaXMuYWx0S2V5ID0gb3JpZ2luYWxFdmVudC5hbHRLZXk7XG4gICAgfVxufVxuY29uc3QgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJExJTktfQ0xJQ0tFRCA9IFN5bWJvbChcImxpbmtDbGlja2VkXCIpO1xuZnVuY3Rpb24gJGY2YzMxY2NlMmFkZjY1NGYkZXhwb3J0JDQ1NzEyZWNlZGE2ZmFkMjEocHJvcHMpIHtcbiAgICBsZXQgeyBvblByZXNzOiBvblByZXNzLCBvblByZXNzQ2hhbmdlOiBvblByZXNzQ2hhbmdlLCBvblByZXNzU3RhcnQ6IG9uUHJlc3NTdGFydCwgb25QcmVzc0VuZDogb25QcmVzc0VuZCwgb25QcmVzc1VwOiBvblByZXNzVXAsIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsIGlzUHJlc3NlZDogaXNQcmVzc2VkUHJvcCwgcHJldmVudEZvY3VzT25QcmVzczogcHJldmVudEZvY3VzT25QcmVzcywgc2hvdWxkQ2FuY2VsT25Qb2ludGVyRXhpdDogc2hvdWxkQ2FuY2VsT25Qb2ludGVyRXhpdCwgYWxsb3dUZXh0U2VsZWN0aW9uT25QcmVzczogYWxsb3dUZXh0U2VsZWN0aW9uT25QcmVzcywgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHJlZjogXywgLi4uZG9tUHJvcHMgfSA9ICRmNmMzMWNjZTJhZGY2NTRmJHZhciR1c2VQcmVzc1Jlc3BvbmRlckNvbnRleHQocHJvcHMpO1xuICAgIGxldCBbaXNQcmVzc2VkLCBzZXRQcmVzc2VkXSA9ICgwLCAkYng3U0wkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgcmVmID0gKDAsICRieDdTTCR1c2VSZWYpKHtcbiAgICAgICAgaXNQcmVzc2VkOiBmYWxzZSxcbiAgICAgICAgaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50czogZmFsc2UsXG4gICAgICAgIGlnbm9yZUNsaWNrQWZ0ZXJQcmVzczogZmFsc2UsXG4gICAgICAgIGRpZEZpcmVQcmVzc1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgaXNUcmlnZ2VyaW5nRXZlbnQ6IGZhbHNlLFxuICAgICAgICBhY3RpdmVQb2ludGVySWQ6IG51bGwsXG4gICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgaXNPdmVyVGFyZ2V0OiBmYWxzZSxcbiAgICAgICAgcG9pbnRlclR5cGU6IG51bGxcbiAgICB9KTtcbiAgICBsZXQgeyBhZGRHbG9iYWxMaXN0ZW5lcjogYWRkR2xvYmFsTGlzdGVuZXIsIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVyczogcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzIH0gPSAoMCwgJGJ4N1NMJHVzZUdsb2JhbExpc3RlbmVycykoKTtcbiAgICBsZXQgdHJpZ2dlclByZXNzU3RhcnQgPSAoMCwgJGJ4N1NMJHVzZUVmZmVjdEV2ZW50KSgob3JpZ2luYWxFdmVudCwgcG9pbnRlclR5cGUpPT57XG4gICAgICAgIGxldCBzdGF0ZSA9IHJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoaXNEaXNhYmxlZCB8fCBzdGF0ZS5kaWRGaXJlUHJlc3NTdGFydCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUuaXNUcmlnZ2VyaW5nRXZlbnQgPSB0cnVlO1xuICAgICAgICBpZiAob25QcmVzc1N0YXJ0KSB7XG4gICAgICAgICAgICBsZXQgZXZlbnQgPSBuZXcgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJFByZXNzRXZlbnQoXCJwcmVzc3N0YXJ0XCIsIHBvaW50ZXJUeXBlLCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIG9uUHJlc3NTdGFydChldmVudCk7XG4gICAgICAgICAgICBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSBldmVudC5zaG91bGRTdG9wUHJvcGFnYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUHJlc3NDaGFuZ2UpIG9uUHJlc3NDaGFuZ2UodHJ1ZSk7XG4gICAgICAgIHN0YXRlLmlzVHJpZ2dlcmluZ0V2ZW50ID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmRpZEZpcmVQcmVzc1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgc2V0UHJlc3NlZCh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHNob3VsZFN0b3BQcm9wYWdhdGlvbjtcbiAgICB9KTtcbiAgICBsZXQgdHJpZ2dlclByZXNzRW5kID0gKDAsICRieDdTTCR1c2VFZmZlY3RFdmVudCkoKG9yaWdpbmFsRXZlbnQsIHBvaW50ZXJUeXBlLCB3YXNQcmVzc2VkID0gdHJ1ZSk9PntcbiAgICAgICAgbGV0IHN0YXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghc3RhdGUuZGlkRmlyZVByZXNzU3RhcnQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgc3RhdGUuaWdub3JlQ2xpY2tBZnRlclByZXNzID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUuZGlkRmlyZVByZXNzU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaXNUcmlnZ2VyaW5nRXZlbnQgPSB0cnVlO1xuICAgICAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgaWYgKG9uUHJlc3NFbmQpIHtcbiAgICAgICAgICAgIGxldCBldmVudCA9IG5ldyAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkUHJlc3NFdmVudChcInByZXNzZW5kXCIsIHBvaW50ZXJUeXBlLCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIG9uUHJlc3NFbmQoZXZlbnQpO1xuICAgICAgICAgICAgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gZXZlbnQuc2hvdWxkU3RvcFByb3BhZ2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblByZXNzQ2hhbmdlKSBvblByZXNzQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgc2V0UHJlc3NlZChmYWxzZSk7XG4gICAgICAgIGlmIChvblByZXNzICYmIHdhc1ByZXNzZWQgJiYgIWlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGxldCBldmVudCA9IG5ldyAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkUHJlc3NFdmVudChcInByZXNzXCIsIHBvaW50ZXJUeXBlLCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIG9uUHJlc3MoZXZlbnQpO1xuICAgICAgICAgICAgc2hvdWxkU3RvcFByb3BhZ2F0aW9uICYmIChzaG91bGRTdG9wUHJvcGFnYXRpb24gPSBldmVudC5zaG91bGRTdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmlzVHJpZ2dlcmluZ0V2ZW50ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzaG91bGRTdG9wUHJvcGFnYXRpb247XG4gICAgfSk7XG4gICAgbGV0IHRyaWdnZXJQcmVzc1VwID0gKDAsICRieDdTTCR1c2VFZmZlY3RFdmVudCkoKG9yaWdpbmFsRXZlbnQsIHBvaW50ZXJUeXBlKT0+e1xuICAgICAgICBsZXQgc3RhdGUgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG9uUHJlc3NVcCkge1xuICAgICAgICAgICAgc3RhdGUuaXNUcmlnZ2VyaW5nRXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gbmV3ICRmNmMzMWNjZTJhZGY2NTRmJHZhciRQcmVzc0V2ZW50KFwicHJlc3N1cFwiLCBwb2ludGVyVHlwZSwgb3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICBvblByZXNzVXAoZXZlbnQpO1xuICAgICAgICAgICAgc3RhdGUuaXNUcmlnZ2VyaW5nRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBldmVudC5zaG91bGRTdG9wUHJvcGFnYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgbGV0IGNhbmNlbCA9ICgwLCAkYng3U0wkdXNlRWZmZWN0RXZlbnQpKChlKT0+e1xuICAgICAgICBsZXQgc3RhdGUgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKHN0YXRlLmlzUHJlc3NlZCAmJiBzdGF0ZS50YXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc092ZXJUYXJnZXQgJiYgc3RhdGUucG9pbnRlclR5cGUgIT0gbnVsbCkgdHJpZ2dlclByZXNzRW5kKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRjcmVhdGVFdmVudChzdGF0ZS50YXJnZXQsIGUpLCBzdGF0ZS5wb2ludGVyVHlwZSwgZmFsc2UpO1xuICAgICAgICAgICAgc3RhdGUuaXNQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBzdGF0ZS5pc092ZXJUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVBvaW50ZXJJZCA9IG51bGw7XG4gICAgICAgICAgICBzdGF0ZS5wb2ludGVyVHlwZSA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIGlmICghYWxsb3dUZXh0U2VsZWN0aW9uT25QcmVzcykgKDAsICQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCRiMGQ2ZmExYWIzMmUzMjk1KShzdGF0ZS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGNhbmNlbE9uUG9pbnRlckV4aXQgPSAoMCwgJGJ4N1NMJHVzZUVmZmVjdEV2ZW50KSgoZSk9PntcbiAgICAgICAgaWYgKHNob3VsZENhbmNlbE9uUG9pbnRlckV4aXQpIGNhbmNlbChlKTtcbiAgICB9KTtcbiAgICBsZXQgcHJlc3NQcm9wcyA9ICgwLCAkYng3U0wkdXNlTWVtbykoKCk9PntcbiAgICAgICAgbGV0IHN0YXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGxldCBwcmVzc1Byb3BzID0ge1xuICAgICAgICAgICAgb25LZXlEb3duIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc1ZhbGlkS2V5Ym9hcmRFdmVudChlLm5hdGl2ZUV2ZW50LCBlLmN1cnJlbnRUYXJnZXQpICYmIGUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGF0ZV9tZXRhS2V5RXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJHNob3VsZFByZXZlbnREZWZhdWx0S2V5Ym9hcmQoZS50YXJnZXQsIGUua2V5KSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZXZlbnQgaXMgcmVwZWF0aW5nLCBpdCBtYXkgaGF2ZSBzdGFydGVkIG9uIGEgZGlmZmVyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gYWZ0ZXIgd2hpY2ggZm9jdXMgbW92ZWQgdG8gdGhlIGN1cnJlbnQgZWxlbWVudC4gSWdub3JlIHRoZXNlIGV2ZW50cyBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBoYW5kbGUgdGhlIGZpcnN0IGtleSBkb3duIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc1ByZXNzZWQgJiYgIWUucmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc1ByZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJpZ2dlclByZXNzU3RhcnQoZSwgXCJrZXlib2FyZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvY3VzIG1heSBtb3ZlIGJlZm9yZSB0aGUga2V5IHVwIGV2ZW50LCBzbyByZWdpc3RlciB0aGUgZXZlbnQgb24gdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSBzYW1lIGVsZW1lbnQgd2hlcmUgdGhlIGtleSBkb3duIGV2ZW50IG9jY3VycmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIoKDAsICRieDdTTCRnZXRPd25lckRvY3VtZW50KShlLmN1cnJlbnRUYXJnZXQpLCBcImtleXVwXCIsIG9uS2V5VXAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBrZXlkb3duIGV2ZW50cyB0aGF0IG9jY3VyIHdoaWxlIHRoZSBNZXRhIChlLmcuIENvbW1hbmQpIGtleSBpcyBoZWxkLlxuICAgICAgICAgICAgICAgICAgICAvLyBtYWNPUyBoYXMgYSBidWcgd2hlcmUga2V5dXAgZXZlbnRzIGFyZSBub3QgZmlyZWQgd2hpbGUgdGhlIE1ldGEga2V5IGlzIGRvd24uXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIE1ldGEga2V5IGl0c2VsZiBpcyByZWxlYXNlZCB3ZSB3aWxsIGdldCBhbiBldmVudCBmb3IgdGhhdCwgYW5kIHdlJ2xsIGFjdCBhcyBpZlxuICAgICAgICAgICAgICAgICAgICAvLyBhbGwgb2YgdGhlc2Ugb3RoZXIga2V5cyB3ZXJlIHJlbGVhc2VkIGFzIHdlbGwuXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEzOTM1MjRcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTU1MjkxXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyOTk1NTNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUubWV0YUtleSAmJiAoMCwgJGJ4N1NMJGlzTWFjKSgpKSAoX3N0YXRlX21ldGFLZXlFdmVudHMgPSBzdGF0ZS5tZXRhS2V5RXZlbnRzKSA9PT0gbnVsbCB8fCBfc3RhdGVfbWV0YUtleUV2ZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlX21ldGFLZXlFdmVudHMuc2V0KGUua2V5LCBlLm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5ID09PSBcIk1ldGFcIikgc3RhdGUubWV0YUtleUV2ZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbktleVVwIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc1ZhbGlkS2V5Ym9hcmRFdmVudChlLm5hdGl2ZUV2ZW50LCBlLmN1cnJlbnRUYXJnZXQpICYmICFlLnJlcGVhdCAmJiBlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpICYmIHN0YXRlLnRhcmdldCkgdHJpZ2dlclByZXNzVXAoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGNyZWF0ZUV2ZW50KHN0YXRlLnRhcmdldCwgZSksIFwia2V5Ym9hcmRcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DbGljayAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlICYmICFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGUgJiYgZS5idXR0b24gPT09IDAgJiYgIXN0YXRlLmlzVHJpZ2dlcmluZ0V2ZW50ICYmICEoMCwgJGJ4N1NMJG9wZW5MaW5rKS5pc09wZW5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRyaWdnZXJlZCBmcm9tIGEgc2NyZWVuIHJlYWRlciBvciBieSB1c2luZyBlbGVtZW50LmNsaWNrKCksXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgYXMgaWYgaXQgd2VyZSBhIGtleWJvYXJkIGNsaWNrLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlnbm9yZUNsaWNrQWZ0ZXJQcmVzcyAmJiAhc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyAmJiAhc3RhdGUuaXNQcmVzc2VkICYmIChzdGF0ZS5wb2ludGVyVHlwZSA9PT0gXCJ2aXJ0dWFsXCIgfHwgKDAsICRieDdTTCRpc1ZpcnR1YWxDbGljaykoZS5uYXRpdmVFdmVudCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGVsZW1lbnQgcmVjZWl2ZXMgZm9jdXMgKFZvaWNlT3ZlciBvbiBpT1MgZG9lcyBub3QgZG8gdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNEaXNhYmxlZCAmJiAhcHJldmVudEZvY3VzT25QcmVzcykgKDAsICRieDdTTCRmb2N1c1dpdGhvdXRTY3JvbGxpbmcpKGUuY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RvcFByZXNzU3RhcnQgPSB0cmlnZ2VyUHJlc3NTdGFydChlLCBcInZpcnR1YWxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RvcFByZXNzVXAgPSB0cmlnZ2VyUHJlc3NVcChlLCBcInZpcnR1YWxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RvcFByZXNzRW5kID0gdHJpZ2dlclByZXNzRW5kKGUsIFwidmlydHVhbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHN0b3BQcmVzc1N0YXJ0ICYmIHN0b3BQcmVzc1VwICYmIHN0b3BQcmVzc0VuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlnbm9yZUNsaWNrQWZ0ZXJQcmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IG9uS2V5VXAgPSAoZSk9PntcbiAgICAgICAgICAgIHZhciBfc3RhdGVfbWV0YUtleUV2ZW50cztcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc1ByZXNzZWQgJiYgc3RhdGUudGFyZ2V0ICYmICRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc1ZhbGlkS2V5Ym9hcmRFdmVudChlLCBzdGF0ZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9zdGF0ZV9tZXRhS2V5RXZlbnRzMTtcbiAgICAgICAgICAgICAgICBpZiAoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJHNob3VsZFByZXZlbnREZWZhdWx0S2V5Ym9hcmQoZS50YXJnZXQsIGUua2V5KSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJpZ2dlclByZXNzRW5kKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRjcmVhdGVFdmVudChzdGF0ZS50YXJnZXQsIGUpLCBcImtleWJvYXJkXCIsIHN0YXRlLnRhcmdldC5jb250YWlucyh0YXJnZXQpKTtcbiAgICAgICAgICAgICAgICByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIC8vIElmIGEgbGluayB3YXMgdHJpZ2dlcmVkIHdpdGggYSBrZXkgb3RoZXIgdGhhbiBFbnRlciwgb3BlbiB0aGUgVVJMIG91cnNlbHZlcy5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHRoZSBsaW5rIGhhcyBhIHJvbGUgb3ZlcnJpZGUsIGFuZCB0aGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgLy8gb25seSBhcHBsaWVzIHdoZW4gdXNpbmcgdGhlIEVudGVyIGtleS5cbiAgICAgICAgICAgICAgICBpZiAoZS5rZXkgIT09IFwiRW50ZXJcIiAmJiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNIVE1MQW5jaG9yTGluayhzdGF0ZS50YXJnZXQpICYmIHN0YXRlLnRhcmdldC5jb250YWlucyh0YXJnZXQpICYmICFlWyRmNmMzMWNjZTJhZGY2NTRmJHZhciRMSU5LX0NMSUNLRURdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIGEgaGlkZGVuIHByb3BlcnR5IG9uIHRoZSBldmVudCBzbyB3ZSBvbmx5IHRyaWdnZXIgbGluayBjbGljayBvbmNlLFxuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSB1c2VQcmVzcyBpbnN0YW5jZXMgYXR0YWNoZWQgdG8gdGhlIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGVbJGY2YzMxY2NlMmFkZjY1NGYkdmFyJExJTktfQ0xJQ0tFRF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAoMCwgJGJ4N1NMJG9wZW5MaW5rKShzdGF0ZS50YXJnZXQsIGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUuaXNQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgKF9zdGF0ZV9tZXRhS2V5RXZlbnRzMSA9IHN0YXRlLm1ldGFLZXlFdmVudHMpID09PSBudWxsIHx8IF9zdGF0ZV9tZXRhS2V5RXZlbnRzMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlX21ldGFLZXlFdmVudHMxLmRlbGV0ZShlLmtleSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5ID09PSBcIk1ldGFcIiAmJiAoKF9zdGF0ZV9tZXRhS2V5RXZlbnRzID0gc3RhdGUubWV0YUtleUV2ZW50cykgPT09IG51bGwgfHwgX3N0YXRlX21ldGFLZXlFdmVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZV9tZXRhS2V5RXZlbnRzLnNpemUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9zdGF0ZV90YXJnZXQ7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVjb3JkZWQga2V5ZG93biBldmVudHMgdGhhdCBvY2N1cnJlZCB3aGlsZSB0aGUgTWV0YSBrZXkgd2FzIHByZXNzZWQsXG4gICAgICAgICAgICAgICAgLy8gYW5kIHRob3NlIGhhdmVuJ3QgcmVjZWl2ZWQga2V5dXAgZXZlbnRzIGFscmVhZHksIGZpcmUga2V5dXAgZXZlbnRzIG91cnNlbHZlcy5cbiAgICAgICAgICAgICAgICAvLyBTZWUgY29tbWVudCBhYm92ZSBmb3IgbW9yZSBpbmZvIGFib3V0IHRoZSBtYWNPUyBidWcgY2F1c2luZyB0aGlzLlxuICAgICAgICAgICAgICAgIGxldCBldmVudHMgPSBzdGF0ZS5tZXRhS2V5RXZlbnRzO1xuICAgICAgICAgICAgICAgIHN0YXRlLm1ldGFLZXlFdmVudHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZXZlbnQgb2YgZXZlbnRzLnZhbHVlcygpKShfc3RhdGVfdGFyZ2V0ID0gc3RhdGUudGFyZ2V0KSA9PT0gbnVsbCB8fCBfc3RhdGVfdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGVfdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEtleWJvYXJkRXZlbnQoXCJrZXl1cFwiLCBldmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIFBvaW50ZXJFdmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcHJlc3NQcm9wcy5vblBvaW50ZXJEb3duID0gKGUpPT57XG4gICAgICAgICAgICAgICAgLy8gT25seSBoYW5kbGUgbGVmdCBjbGlja3MsIGFuZCBpZ25vcmUgZXZlbnRzIHRoYXQgYnViYmxlZCB0aHJvdWdoIHBvcnRhbHMuXG4gICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9uICE9PSAwIHx8ICFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gaU9TIHNhZmFyaSBmaXJlcyBwb2ludGVyIGV2ZW50cyBmcm9tIFZvaWNlT3ZlciB3aXRoIGluY29ycmVjdCBjb29yZGluYXRlcy90YXJnZXQuXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGFuZCBsZXQgdGhlIG9uQ2xpY2sgaGFuZGxlciB0YWtlIGNhcmUgb2YgaXQgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjIyNjI3XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIyMzIwMlxuICAgICAgICAgICAgICAgIGlmICgoMCwgJGJ4N1NMJGlzVmlydHVhbFBvaW50ZXJFdmVudCkoZS5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucG9pbnRlclR5cGUgPSBcInZpcnR1YWxcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEdWUgdG8gYnJvd3NlciBpbmNvbnNpc3RlbmNpZXMsIGVzcGVjaWFsbHkgb24gbW9iaWxlIGJyb3dzZXJzLCB3ZSBwcmV2ZW50XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBvbiBwb2ludGVyIGRvd24gYW5kIGhhbmRsZSBmb2N1c2luZyB0aGUgcHJlc3NhYmxlIGVsZW1lbnQgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICAgIGlmICgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkc2hvdWxkUHJldmVudERlZmF1bHQoZS5jdXJyZW50VGFyZ2V0KSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnBvaW50ZXJUeXBlID0gZS5wb2ludGVyVHlwZTtcbiAgICAgICAgICAgICAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlzUHJlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc1ByZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc092ZXJUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVQb2ludGVySWQgPSBlLnBvaW50ZXJJZDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRGlzYWJsZWQgJiYgIXByZXZlbnRGb2N1c09uUHJlc3MpICgwLCAkYng3U0wkZm9jdXNXaXRob3V0U2Nyb2xsaW5nKShlLmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93VGV4dFNlbGVjdGlvbk9uUHJlc3MpICgwLCAkMTRjMGI3MjUwOWQ3MDIyNSRleHBvcnQkMTZhNDY5NzQ2NzE3NTQ4Nykoc3RhdGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJpZ2dlclByZXNzU3RhcnQoZSwgc3RhdGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcigoMCwgJGJ4N1NMJGdldE93bmVyRG9jdW1lbnQpKGUuY3VycmVudFRhcmdldCksIFwicG9pbnRlcm1vdmVcIiwgb25Qb2ludGVyTW92ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcigoMCwgJGJ4N1NMJGdldE93bmVyRG9jdW1lbnQpKGUuY3VycmVudFRhcmdldCksIFwicG9pbnRlcnVwXCIsIG9uUG9pbnRlclVwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKCgwLCAkYng3U0wkZ2V0T3duZXJEb2N1bWVudCkoZS5jdXJyZW50VGFyZ2V0KSwgXCJwb2ludGVyY2FuY2VsXCIsIG9uUG9pbnRlckNhbmNlbCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXNzUHJvcHMub25Nb3VzZURvd24gPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21lIGFuZCBGaXJlZm94IG9uIHRvdWNoIFdpbmRvd3MgZGV2aWNlcyByZXF1aXJlIG1vdXNlIGRvd24gZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGJlIGNhbmNlbGVkIGluIGFkZGl0aW9uIHRvIHBvaW50ZXIgZXZlbnRzLCBvciBhbiBleHRyYSBhc3luY2hyb25vdXNcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9jdXMgZXZlbnQgd2lsbCBiZSBmaXJlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRzaG91bGRQcmV2ZW50RGVmYXVsdChlLmN1cnJlbnRUYXJnZXQpKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXNzUHJvcHMub25Qb2ludGVyVXAgPSAoZSk9PntcbiAgICAgICAgICAgICAgICAvLyBpT1MgZmlyZXMgcG9pbnRlcnVwIHdpdGggemVybyB3aWR0aCBhbmQgaGVpZ2h0LCBzbyBjaGVjayB0aGUgcG9pbnRlclR5cGUgcmVjb3JkZWQgZHVyaW5nIHBvaW50ZXJkb3duLlxuICAgICAgICAgICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSB8fCBzdGF0ZS5wb2ludGVyVHlwZSA9PT0gXCJ2aXJ0dWFsXCIpIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGhhbmRsZSBsZWZ0IGNsaWNrc1xuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBvbiBpT1Mgc29tZXRpbWVzIGZpcmVzIHBvaW50ZXJ1cCBldmVudHMsIGV2ZW5cbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSB0b3VjaCBpc24ndCBvdmVyIHRoZSB0YXJnZXQsIHNvIGRvdWJsZSBjaGVjay5cbiAgICAgICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDAgJiYgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzT3ZlclRhcmdldChlLCBlLmN1cnJlbnRUYXJnZXQpKSB0cmlnZ2VyUHJlc3NVcChlLCBzdGF0ZS5wb2ludGVyVHlwZSB8fCBlLnBvaW50ZXJUeXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBTYWZhcmkgb24gaU9TIDwgMTMuMiBkb2VzIG5vdCBpbXBsZW1lbnQgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBldmVudHMgY29ycmVjdGx5LlxuICAgICAgICAgICAgLy8gVXNlIHBvaW50ZXIgbW92ZSBldmVudHMgaW5zdGVhZCB0byBpbXBsZW1lbnQgb3VyIG93biBoaXQgdGVzdGluZy5cbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTk5ODAzXG4gICAgICAgICAgICBsZXQgb25Qb2ludGVyTW92ZSA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlLnBvaW50ZXJJZCAhPT0gc3RhdGUuYWN0aXZlUG9pbnRlcklkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnRhcmdldCAmJiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNPdmVyVGFyZ2V0KGUsIHN0YXRlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc092ZXJUYXJnZXQgJiYgc3RhdGUucG9pbnRlclR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNPdmVyVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJQcmVzc1N0YXJ0KCRmNmMzMWNjZTJhZGY2NTRmJHZhciRjcmVhdGVFdmVudChzdGF0ZS50YXJnZXQsIGUpLCBzdGF0ZS5wb2ludGVyVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLnRhcmdldCAmJiBzdGF0ZS5pc092ZXJUYXJnZXQgJiYgc3RhdGUucG9pbnRlclR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc092ZXJUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlclByZXNzRW5kKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRjcmVhdGVFdmVudChzdGF0ZS50YXJnZXQsIGUpLCBzdGF0ZS5wb2ludGVyVHlwZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxPblBvaW50ZXJFeGl0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgb25Qb2ludGVyVXAgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoZS5wb2ludGVySWQgPT09IHN0YXRlLmFjdGl2ZVBvaW50ZXJJZCAmJiBzdGF0ZS5pc1ByZXNzZWQgJiYgZS5idXR0b24gPT09IDAgJiYgc3RhdGUudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNPdmVyVGFyZ2V0KGUsIHN0YXRlLnRhcmdldCkgJiYgc3RhdGUucG9pbnRlclR5cGUgIT0gbnVsbCkgdHJpZ2dlclByZXNzRW5kKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRjcmVhdGVFdmVudChzdGF0ZS50YXJnZXQsIGUpLCBzdGF0ZS5wb2ludGVyVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlLmlzT3ZlclRhcmdldCAmJiBzdGF0ZS5wb2ludGVyVHlwZSAhPSBudWxsKSB0cmlnZ2VyUHJlc3NFbmQoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGNyZWF0ZUV2ZW50KHN0YXRlLnRhcmdldCwgZSksIHN0YXRlLnBvaW50ZXJUeXBlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc092ZXJUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlUG9pbnRlcklkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd1RleHRTZWxlY3Rpb25PblByZXNzKSAoMCwgJDE0YzBiNzI1MDlkNzAyMjUkZXhwb3J0JGIwZDZmYTFhYjMyZTMyOTUpKHN0YXRlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBvblBvaW50ZXJDYW5jZWwgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBjYW5jZWwoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJlc3NQcm9wcy5vbkRyYWdTdGFydCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBkb2VzIG5vdCBjYWxsIG9uUG9pbnRlckNhbmNlbCB3aGVuIGEgZHJhZyBzdGFydHMsIHdoZXJlYXMgQ2hyb21lIGFuZCBGaXJlZm94IGRvLlxuICAgICAgICAgICAgICAgIGNhbmNlbChlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmVzc1Byb3BzLm9uTW91c2VEb3duID0gKGUpPT57XG4gICAgICAgICAgICAgICAgLy8gT25seSBoYW5kbGUgbGVmdCBjbGlja3NcbiAgICAgICAgICAgICAgICBpZiAoZS5idXR0b24gIT09IDAgfHwgIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBEdWUgdG8gYnJvd3NlciBpbmNvbnNpc3RlbmNpZXMsIGVzcGVjaWFsbHkgb24gbW9iaWxlIGJyb3dzZXJzLCB3ZSBwcmV2ZW50XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBvbiBtb3VzZSBkb3duIGFuZCBoYW5kbGUgZm9jdXNpbmcgdGhlIHByZXNzYWJsZSBlbGVtZW50IG91cnNlbHZlcy5cbiAgICAgICAgICAgICAgICBpZiAoJGY2YzMxY2NlMmFkZjY1NGYkdmFyJHNob3VsZFByZXZlbnREZWZhdWx0KGUuY3VycmVudFRhcmdldCkpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLmlzUHJlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGUuaXNPdmVyVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZS50YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgc3RhdGUucG9pbnRlclR5cGUgPSAoMCwgJGJ4N1NMJGlzVmlydHVhbENsaWNrKShlLm5hdGl2ZUV2ZW50KSA/IFwidmlydHVhbFwiIDogXCJtb3VzZVwiO1xuICAgICAgICAgICAgICAgIGlmICghaXNEaXNhYmxlZCAmJiAhcHJldmVudEZvY3VzT25QcmVzcykgKDAsICRieDdTTCRmb2N1c1dpdGhvdXRTY3JvbGxpbmcpKGUuY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgICAgICAgbGV0IHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRyaWdnZXJQcmVzc1N0YXJ0KGUsIHN0YXRlLnBvaW50ZXJUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKCgwLCAkYng3U0wkZ2V0T3duZXJEb2N1bWVudCkoZS5jdXJyZW50VGFyZ2V0KSwgXCJtb3VzZXVwXCIsIG9uTW91c2VVcCwgZmFsc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXNzUHJvcHMub25Nb3VzZUVudGVyID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgbGV0IHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlzUHJlc3NlZCAmJiAhc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyAmJiBzdGF0ZS5wb2ludGVyVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzT3ZlclRhcmdldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IHRyaWdnZXJQcmVzc1N0YXJ0KGUsIHN0YXRlLnBvaW50ZXJUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcmVzc1Byb3BzLm9uTW91c2VMZWF2ZSA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxldCBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pc1ByZXNzZWQgJiYgIXN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgJiYgc3RhdGUucG9pbnRlclR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc092ZXJUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJpZ2dlclByZXNzRW5kKGUsIHN0YXRlLnBvaW50ZXJUeXBlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbE9uUG9pbnRlckV4aXQoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJlc3NQcm9wcy5vbk1vdXNlVXAgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgJiYgZS5idXR0b24gPT09IDApIHRyaWdnZXJQcmVzc1VwKGUsIHN0YXRlLnBvaW50ZXJUeXBlIHx8IFwibW91c2VcIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IG9uTW91c2VVcCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgaGFuZGxlIGxlZnQgY2xpY2tzXG4gICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9uICE9PSAwKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc3RhdGUuaXNQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS50YXJnZXQgJiYgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzT3ZlclRhcmdldChlLCBzdGF0ZS50YXJnZXQpICYmIHN0YXRlLnBvaW50ZXJUeXBlICE9IG51bGwpIHRyaWdnZXJQcmVzc0VuZCgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkY3JlYXRlRXZlbnQoc3RhdGUudGFyZ2V0LCBlKSwgc3RhdGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlLnRhcmdldCAmJiBzdGF0ZS5pc092ZXJUYXJnZXQgJiYgc3RhdGUucG9pbnRlclR5cGUgIT0gbnVsbCkgdHJpZ2dlclByZXNzRW5kKCRmNmMzMWNjZTJhZGY2NTRmJHZhciRjcmVhdGVFdmVudChzdGF0ZS50YXJnZXQsIGUpLCBzdGF0ZS5wb2ludGVyVHlwZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmlzT3ZlclRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXNzUHJvcHMub25Ub3VjaFN0YXJ0ID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgbGV0IHRvdWNoID0gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGdldFRvdWNoRnJvbUV2ZW50KGUubmF0aXZlRXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmICghdG91Y2gpIHJldHVybjtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVQb2ludGVySWQgPSB0b3VjaC5pZGVudGlmaWVyO1xuICAgICAgICAgICAgICAgIHN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlLmlzT3ZlclRhcmdldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGUuaXNQcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZS50YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgc3RhdGUucG9pbnRlclR5cGUgPSBcInRvdWNoXCI7XG4gICAgICAgICAgICAgICAgLy8gRHVlIHRvIGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzLCBlc3BlY2lhbGx5IG9uIG1vYmlsZSBicm93c2Vycywgd2UgcHJldmVudCBkZWZhdWx0XG4gICAgICAgICAgICAgICAgLy8gb24gdGhlIGVtdWxhdGVkIG1vdXNlIGV2ZW50IGFuZCBoYW5kbGUgZm9jdXNpbmcgdGhlIHByZXNzYWJsZSBlbGVtZW50IG91cnNlbHZlcy5cbiAgICAgICAgICAgICAgICBpZiAoIWlzRGlzYWJsZWQgJiYgIXByZXZlbnRGb2N1c09uUHJlc3MpICgwLCAkYng3U0wkZm9jdXNXaXRob3V0U2Nyb2xsaW5nKShlLmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgICAgICAgIGlmICghYWxsb3dUZXh0U2VsZWN0aW9uT25QcmVzcykgKDAsICQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCQxNmE0Njk3NDY3MTc1NDg3KShzdGF0ZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGxldCBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cmlnZ2VyUHJlc3NTdGFydChlLCBzdGF0ZS5wb2ludGVyVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcigoMCwgJGJ4N1NMJGdldE93bmVyV2luZG93KShlLmN1cnJlbnRUYXJnZXQpLCBcInNjcm9sbFwiLCBvblNjcm9sbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJlc3NQcm9wcy5vblRvdWNoTW92ZSA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaXNQcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHRvdWNoID0gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGdldFRvdWNoQnlJZChlLm5hdGl2ZUV2ZW50LCBzdGF0ZS5hY3RpdmVQb2ludGVySWQpO1xuICAgICAgICAgICAgICAgIGxldCBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0b3VjaCAmJiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNPdmVyVGFyZ2V0KHRvdWNoLCBlLmN1cnJlbnRUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaXNPdmVyVGFyZ2V0ICYmIHN0YXRlLnBvaW50ZXJUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzT3ZlclRhcmdldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cmlnZ2VyUHJlc3NTdGFydChlLCBzdGF0ZS5wb2ludGVyVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmlzT3ZlclRhcmdldCAmJiBzdGF0ZS5wb2ludGVyVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzT3ZlclRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cmlnZ2VyUHJlc3NFbmQoZSwgc3RhdGUucG9pbnRlclR5cGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsT25Qb2ludGVyRXhpdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcmVzc1Byb3BzLm9uVG91Y2hFbmQgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlzUHJlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB0b3VjaCA9ICRmNmMzMWNjZTJhZGY2NTRmJHZhciRnZXRUb3VjaEJ5SWQoZS5uYXRpdmVFdmVudCwgc3RhdGUuYWN0aXZlUG9pbnRlcklkKTtcbiAgICAgICAgICAgICAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG91Y2ggJiYgJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzT3ZlclRhcmdldCh0b3VjaCwgZS5jdXJyZW50VGFyZ2V0KSAmJiBzdGF0ZS5wb2ludGVyVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJQcmVzc1VwKGUsIHN0YXRlLnBvaW50ZXJUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJpZ2dlclByZXNzRW5kKGUsIHN0YXRlLnBvaW50ZXJUeXBlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmlzT3ZlclRhcmdldCAmJiBzdGF0ZS5wb2ludGVyVHlwZSAhPSBudWxsKSBzaG91bGRTdG9wUHJvcGFnYXRpb24gPSB0cmlnZ2VyUHJlc3NFbmQoZSwgc3RhdGUucG9pbnRlclR5cGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmlzUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVBvaW50ZXJJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3RhdGUuaXNPdmVyVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnRhcmdldCAmJiAhYWxsb3dUZXh0U2VsZWN0aW9uT25QcmVzcykgKDAsICQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCRiMGQ2ZmExYWIzMmUzMjk1KShzdGF0ZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVycygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXNzUHJvcHMub25Ub3VjaENhbmNlbCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlzUHJlc3NlZCkgY2FuY2VsKGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBvblNjcm9sbCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pc1ByZXNzZWQgJiYgZS50YXJnZXQuY29udGFpbnMoc3RhdGUudGFyZ2V0KSkgY2FuY2VsKHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhcmdldDogc3RhdGUudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBzaGlmdEtleTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGN0cmxLZXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXRhS2V5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYWx0S2V5OiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXNzUHJvcHMub25EcmFnU3RhcnQgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYW5jZWwoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmVzc1Byb3BzO1xuICAgIH0sIFtcbiAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIsXG4gICAgICAgIGlzRGlzYWJsZWQsXG4gICAgICAgIHByZXZlbnRGb2N1c09uUHJlc3MsXG4gICAgICAgIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVycyxcbiAgICAgICAgYWxsb3dUZXh0U2VsZWN0aW9uT25QcmVzcyxcbiAgICAgICAgY2FuY2VsLFxuICAgICAgICBjYW5jZWxPblBvaW50ZXJFeGl0LFxuICAgICAgICB0cmlnZ2VyUHJlc3NFbmQsXG4gICAgICAgIHRyaWdnZXJQcmVzc1N0YXJ0LFxuICAgICAgICB0cmlnZ2VyUHJlc3NVcFxuICAgIF0pO1xuICAgIC8vIFJlbW92ZSB1c2VyLXNlbGVjdDogbm9uZSBpbiBjYXNlIGNvbXBvbmVudCB1bm1vdW50cyBpbW1lZGlhdGVseSBhZnRlciBwcmVzc1N0YXJ0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycm93LWJvZHktc3R5bGVcbiAgICAoMCwgJGJ4N1NMJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICB2YXIgX3JlZl9jdXJyZW50X3RhcmdldDtcbiAgICAgICAgICAgIGlmICghYWxsb3dUZXh0U2VsZWN0aW9uT25QcmVzcykgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICAgICAgKDAsICQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCRiMGQ2ZmExYWIzMmUzMjk1KSgoX3JlZl9jdXJyZW50X3RhcmdldCA9IHJlZi5jdXJyZW50LnRhcmdldCkgIT09IG51bGwgJiYgX3JlZl9jdXJyZW50X3RhcmdldCAhPT0gdm9pZCAwID8gX3JlZl9jdXJyZW50X3RhcmdldCA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBhbGxvd1RleHRTZWxlY3Rpb25PblByZXNzXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNQcmVzc2VkOiBpc1ByZXNzZWRQcm9wIHx8IGlzUHJlc3NlZCxcbiAgICAgICAgcHJlc3NQcm9wczogKDAsICRieDdTTCRtZXJnZVByb3BzKShkb21Qcm9wcywgcHJlc3NQcm9wcylcbiAgICB9O1xufVxuZnVuY3Rpb24gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzSFRNTEFuY2hvckxpbmsodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC50YWdOYW1lID09PSBcIkFcIiAmJiB0YXJnZXQuaGFzQXR0cmlidXRlKFwiaHJlZlwiKTtcbn1cbmZ1bmN0aW9uICRmNmMzMWNjZTJhZGY2NTRmJHZhciRpc1ZhbGlkS2V5Ym9hcmRFdmVudChldmVudCwgY3VycmVudFRhcmdldCkge1xuICAgIGNvbnN0IHsga2V5OiBrZXksIGNvZGU6IGNvZGUgfSA9IGV2ZW50O1xuICAgIGNvbnN0IGVsZW1lbnQgPSBjdXJyZW50VGFyZ2V0O1xuICAgIGNvbnN0IHJvbGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInJvbGVcIik7XG4gICAgLy8gQWNjZXNzaWJpbGl0eSBmb3Iga2V5Ym9hcmRzLiBTcGFjZSBhbmQgRW50ZXIgb25seS5cbiAgICAvLyBcIlNwYWNlYmFyXCIgaXMgZm9yIElFIDExXG4gICAgcmV0dXJuIChrZXkgPT09IFwiRW50ZXJcIiB8fCBrZXkgPT09IFwiIFwiIHx8IGtleSA9PT0gXCJTcGFjZWJhclwiIHx8IGNvZGUgPT09IFwiU3BhY2VcIikgJiYgIShlbGVtZW50IGluc3RhbmNlb2YgKDAsICRieDdTTCRnZXRPd25lcldpbmRvdykoZWxlbWVudCkuSFRNTElucHV0RWxlbWVudCAmJiAhJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzVmFsaWRJbnB1dEtleShlbGVtZW50LCBrZXkpIHx8IGVsZW1lbnQgaW5zdGFuY2VvZiAoMCwgJGJ4N1NMJGdldE93bmVyV2luZG93KShlbGVtZW50KS5IVE1MVGV4dEFyZWFFbGVtZW50IHx8IGVsZW1lbnQuaXNDb250ZW50RWRpdGFibGUpICYmIC8vIExpbmtzIHNob3VsZCBvbmx5IHRyaWdnZXIgd2l0aCBFbnRlciBrZXlcbiAgICAhKChyb2xlID09PSBcImxpbmtcIiB8fCAhcm9sZSAmJiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNIVE1MQW5jaG9yTGluayhlbGVtZW50KSkgJiYga2V5ICE9PSBcIkVudGVyXCIpO1xufVxuZnVuY3Rpb24gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGdldFRvdWNoRnJvbUV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgeyB0YXJnZXRUb3VjaGVzOiB0YXJnZXRUb3VjaGVzIH0gPSBldmVudDtcbiAgICBpZiAodGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAwKSByZXR1cm4gdGFyZ2V0VG91Y2hlc1swXTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRmNmMzMWNjZTJhZGY2NTRmJHZhciRnZXRUb3VjaEJ5SWQoZXZlbnQsIHBvaW50ZXJJZCkge1xuICAgIGNvbnN0IGNoYW5nZWRUb3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgdG91Y2ggPSBjaGFuZ2VkVG91Y2hlc1tpXTtcbiAgICAgICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT09IHBvaW50ZXJJZCkgcmV0dXJuIHRvdWNoO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRmNmMzMWNjZTJhZGY2NTRmJHZhciRjcmVhdGVFdmVudCh0YXJnZXQsIGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW50VGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5LFxuICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXG4gICAgICAgIG1ldGFLZXk6IGUubWV0YUtleSxcbiAgICAgICAgYWx0S2V5OiBlLmFsdEtleVxuICAgIH07XG59XG5mdW5jdGlvbiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkZ2V0UG9pbnRDbGllbnRSZWN0KHBvaW50KSB7XG4gICAgbGV0IG9mZnNldFggPSAwO1xuICAgIGxldCBvZmZzZXRZID0gMDtcbiAgICBpZiAocG9pbnQud2lkdGggIT09IHVuZGVmaW5lZCkgb2Zmc2V0WCA9IHBvaW50LndpZHRoIC8gMjtcbiAgICBlbHNlIGlmIChwb2ludC5yYWRpdXNYICE9PSB1bmRlZmluZWQpIG9mZnNldFggPSBwb2ludC5yYWRpdXNYO1xuICAgIGlmIChwb2ludC5oZWlnaHQgIT09IHVuZGVmaW5lZCkgb2Zmc2V0WSA9IHBvaW50LmhlaWdodCAvIDI7XG4gICAgZWxzZSBpZiAocG9pbnQucmFkaXVzWSAhPT0gdW5kZWZpbmVkKSBvZmZzZXRZID0gcG9pbnQucmFkaXVzWTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHBvaW50LmNsaWVudFkgLSBvZmZzZXRZLFxuICAgICAgICByaWdodDogcG9pbnQuY2xpZW50WCArIG9mZnNldFgsXG4gICAgICAgIGJvdHRvbTogcG9pbnQuY2xpZW50WSArIG9mZnNldFksXG4gICAgICAgIGxlZnQ6IHBvaW50LmNsaWVudFggLSBvZmZzZXRYXG4gICAgfTtcbn1cbmZ1bmN0aW9uICRmNmMzMWNjZTJhZGY2NTRmJHZhciRhcmVSZWN0YW5nbGVzT3ZlcmxhcHBpbmcoYSwgYikge1xuICAgIC8vIGNoZWNrIGlmIHRoZXkgY2Fubm90IG92ZXJsYXAgb24geCBheGlzXG4gICAgaWYgKGEubGVmdCA+IGIucmlnaHQgfHwgYi5sZWZ0ID4gYS5yaWdodCkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGNoZWNrIGlmIHRoZXkgY2Fubm90IG92ZXJsYXAgb24geSBheGlzXG4gICAgaWYgKGEudG9wID4gYi5ib3R0b20gfHwgYi50b3AgPiBhLmJvdHRvbSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzT3ZlclRhcmdldChwb2ludCwgdGFyZ2V0KSB7XG4gICAgbGV0IHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHBvaW50UmVjdCA9ICRmNmMzMWNjZTJhZGY2NTRmJHZhciRnZXRQb2ludENsaWVudFJlY3QocG9pbnQpO1xuICAgIHJldHVybiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkYXJlUmVjdGFuZ2xlc092ZXJsYXBwaW5nKHJlY3QsIHBvaW50UmVjdCk7XG59XG5mdW5jdGlvbiAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkc2hvdWxkUHJldmVudERlZmF1bHQodGFyZ2V0KSB7XG4gICAgLy8gV2UgY2Fubm90IHByZXZlbnQgZGVmYXVsdCBpZiB0aGUgdGFyZ2V0IGlzIGEgZHJhZ2dhYmxlIGVsZW1lbnQuXG4gICAgcmV0dXJuICEodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHx8ICF0YXJnZXQuaGFzQXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIpO1xufVxuZnVuY3Rpb24gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJHNob3VsZFByZXZlbnREZWZhdWx0S2V5Ym9hcmQodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkgcmV0dXJuICEkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNWYWxpZElucHV0S2V5KHRhcmdldCwga2V5KTtcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQpIHJldHVybiB0YXJnZXQudHlwZSAhPT0gXCJzdWJtaXRcIiAmJiB0YXJnZXQudHlwZSAhPT0gXCJyZXNldFwiO1xuICAgIGlmICgkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNIVE1MQW5jaG9yTGluayh0YXJnZXQpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCAkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkbm9uVGV4dElucHV0VHlwZXMgPSBuZXcgU2V0KFtcbiAgICBcImNoZWNrYm94XCIsXG4gICAgXCJyYWRpb1wiLFxuICAgIFwicmFuZ2VcIixcbiAgICBcImNvbG9yXCIsXG4gICAgXCJmaWxlXCIsXG4gICAgXCJpbWFnZVwiLFxuICAgIFwiYnV0dG9uXCIsXG4gICAgXCJzdWJtaXRcIixcbiAgICBcInJlc2V0XCJcbl0pO1xuZnVuY3Rpb24gJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzVmFsaWRJbnB1dEtleSh0YXJnZXQsIGtleSkge1xuICAgIC8vIE9ubHkgc3BhY2Ugc2hvdWxkIHRvZ2dsZSBjaGVja2JveGVzIGFuZCByYWRpb3MsIG5vdCBlbnRlci5cbiAgICByZXR1cm4gdGFyZ2V0LnR5cGUgPT09IFwiY2hlY2tib3hcIiB8fCB0YXJnZXQudHlwZSA9PT0gXCJyYWRpb1wiID8ga2V5ID09PSBcIiBcIiA6ICRmNmMzMWNjZTJhZGY2NTRmJHZhciRub25UZXh0SW5wdXRUeXBlcy5oYXModGFyZ2V0LnR5cGUpO1xufVxuXG5cblxuY29uc3QgJDNiMTE3ZTQzZGMwY2E5NWQkZXhwb3J0JDI3YzcwMWVkOWU0NDllOTkgPSAvKiNfX1BVUkVfXyovICgwLCAkYng3U0wkcmVhY3QpLmZvcndhcmRSZWYoKHsgY2hpbGRyZW46IGNoaWxkcmVuLCAuLi5wcm9wcyB9LCByZWYpPT57XG4gICAgcmVmID0gKDAsICRieDdTTCR1c2VPYmplY3RSZWYpKHJlZik7XG4gICAgbGV0IHsgcHJlc3NQcm9wczogcHJlc3NQcm9wcyB9ID0gKDAsICRmNmMzMWNjZTJhZGY2NTRmJGV4cG9ydCQ0NTcxMmVjZWRhNmZhZDIxKSh7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICByZWY6IHJlZlxuICAgIH0pO1xuICAgIGxldCBjaGlsZCA9ICgwLCAkYng3U0wkcmVhY3QpLkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkYng3U0wkcmVhY3QpLmNsb25lRWxlbWVudChjaGlsZCwgLy8gQHRzLWlnbm9yZVxuICAgIHtcbiAgICAgICAgcmVmOiByZWYsXG4gICAgICAgIC4uLigwLCAkYng3U0wkbWVyZ2VQcm9wcykoY2hpbGQucHJvcHMsIHByZXNzUHJvcHMpXG4gICAgfSk7XG59KTtcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuY29uc3QgJGYxYWI4Yzc1NDc4YzZmNzMkZXhwb3J0JDMzNTE4NzFlZTRiMjg4YjggPSAvKiNfX1BVUkVfXyovICgwLCAkYng3U0wkcmVhY3QpLmZvcndhcmRSZWYoKHsgY2hpbGRyZW46IGNoaWxkcmVuLCAuLi5wcm9wcyB9LCByZWYpPT57XG4gICAgbGV0IGlzUmVnaXN0ZXJlZCA9ICgwLCAkYng3U0wkdXNlUmVmKShmYWxzZSk7XG4gICAgbGV0IHByZXZDb250ZXh0ID0gKDAsICRieDdTTCR1c2VDb250ZXh0KSgoMCwgJGFlMWVlYmE4YjllYWZkMDgkZXhwb3J0JDUxNjVlY2NiMzVhYWFkYjUpKTtcbiAgICByZWYgPSAoMCwgJGJ4N1NMJHVzZU9iamVjdFJlZikocmVmIHx8IChwcmV2Q29udGV4dCA9PT0gbnVsbCB8fCBwcmV2Q29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldkNvbnRleHQucmVmKSk7XG4gICAgbGV0IGNvbnRleHQgPSAoMCwgJGJ4N1NMJG1lcmdlUHJvcHMpKHByZXZDb250ZXh0IHx8IHt9LCB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICByZWY6IHJlZixcbiAgICAgICAgcmVnaXN0ZXIgKCkge1xuICAgICAgICAgICAgaXNSZWdpc3RlcmVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHByZXZDb250ZXh0KSBwcmV2Q29udGV4dC5yZWdpc3RlcigpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgKDAsICRieDdTTCR1c2VTeW5jUmVmKShwcmV2Q29udGV4dCwgcmVmKTtcbiAgICAoMCwgJGJ4N1NMJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKCFpc1JlZ2lzdGVyZWQuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQSBQcmVzc1Jlc3BvbmRlciB3YXMgcmVuZGVyZWQgd2l0aG91dCBhIHByZXNzYWJsZSBjaGlsZC4gRWl0aGVyIGNhbGwgdGhlIHVzZVByZXNzIGhvb2ssIG9yIHdyYXAgeW91ciBET00gbm9kZSB3aXRoIDxQcmVzc2FibGU+IGNvbXBvbmVudC5cIik7XG4gICAgICAgICAgICBpc1JlZ2lzdGVyZWQuY3VycmVudCA9IHRydWU7IC8vIG9ubHkgd2FybiBvbmNlIGluIHN0cmljdCBtb2RlLlxuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkYng3U0wkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoKDAsICRhZTFlZWJhOGI5ZWFmZDA4JGV4cG9ydCQ1MTY1ZWNjYjM1YWFhZGI1KS5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogY29udGV4dFxuICAgIH0sIGNoaWxkcmVuKTtcbn0pO1xuZnVuY3Rpb24gJGYxYWI4Yzc1NDc4YzZmNzMkZXhwb3J0JGNmNzU0MjhlMGI5ZWQxZWEoeyBjaGlsZHJlbjogY2hpbGRyZW4gfSkge1xuICAgIGxldCBjb250ZXh0ID0gKDAsICRieDdTTCR1c2VNZW1vKSgoKT0+KHtcbiAgICAgICAgICAgIHJlZ2lzdGVyOiAoKT0+e31cbiAgICAgICAgfSksIFtdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgJGJ4N1NMJHJlYWN0KS5jcmVhdGVFbGVtZW50KCgwLCAkYWUxZWViYThiOWVhZmQwOCRleHBvcnQkNTE2NWVjY2IzNWFhYWRiNSkuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGNvbnRleHRcbiAgICB9LCBjaGlsZHJlbik7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFBvcnRpb25zIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZSBhcmUgYmFzZWQgb24gY29kZSBmcm9tIHJlYWN0LlxuLy8gT3JpZ2luYWwgbGljZW5zaW5nIGZvciB0aGUgZm9sbG93aW5nIGNhbiBiZSBmb3VuZCBpbiB0aGVcbi8vIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC90cmVlL2NjN2MxYWVjZTQ2YTZiNjliNDE5NThkNzMxZTBmZDI3Yzk0YmZjNmMvcGFja2FnZXMvcmVhY3QtaW50ZXJhY3Rpb25zXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuY2xhc3MgJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JDkwNWU3ZmM1NDRhNzFmMzYge1xuICAgIGlzRGVmYXVsdFByZXZlbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbiAgICB9XG4gICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubmF0aXZlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICB0aGlzLm5hdGl2ZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gKCk9PnRydWU7XG4gICAgfVxuICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHBlcnNpc3QoKSB7fVxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIG5hdGl2ZUV2ZW50KXtcbiAgICAgICAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldDtcbiAgICAgICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbmF0aXZlRXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgICAgdGhpcy5idWJibGVzID0gbmF0aXZlRXZlbnQuYnViYmxlcztcbiAgICAgICAgdGhpcy5jYW5jZWxhYmxlID0gbmF0aXZlRXZlbnQuY2FuY2VsYWJsZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgICAgdGhpcy5ldmVudFBoYXNlID0gbmF0aXZlRXZlbnQuZXZlbnRQaGFzZTtcbiAgICAgICAgdGhpcy5pc1RydXN0ZWQgPSBuYXRpdmVFdmVudC5pc1RydXN0ZWQ7XG4gICAgICAgIHRoaXMudGltZVN0YW1wID0gbmF0aXZlRXZlbnQudGltZVN0YW1wO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbn1cbmZ1bmN0aW9uICQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCQ3MTVjNjgyZDA5ZDYzOWNjKG9uQmx1cikge1xuICAgIGxldCBzdGF0ZVJlZiA9ICgwLCAkYng3U0wkdXNlUmVmKSh7XG4gICAgICAgIGlzRm9jdXNlZDogZmFsc2UsXG4gICAgICAgIG9ic2VydmVyOiBudWxsXG4gICAgfSk7XG4gICAgLy8gQ2xlYW4gdXAgTXV0YXRpb25PYnNlcnZlciBvbiB1bm1vdW50LiBTZWUgYmVsb3cuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycm93LWJvZHktc3R5bGVcbiAgICAoMCwgJGJ4N1NMJHVzZUxheW91dEVmZmVjdCkoKCk9PntcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGlmIChzdGF0ZS5vYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIHN0YXRlLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vYnNlcnZlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIGxldCBkaXNwYXRjaEJsdXIgPSAoMCwgJGJ4N1NMJHVzZUVmZmVjdEV2ZW50KSgoZSk9PntcbiAgICAgICAgb25CbHVyID09PSBudWxsIHx8IG9uQmx1ciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25CbHVyKGUpO1xuICAgIH0pO1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGR1cmluZyBhIFJlYWN0IG9uRm9jdXMgZXZlbnQuXG4gICAgcmV0dXJuICgwLCAkYng3U0wkdXNlQ2FsbGJhY2spKChlKT0+e1xuICAgICAgICAvLyBSZWFjdCBkb2VzIG5vdCBmaXJlIG9uQmx1ciB3aGVuIGFuIGVsZW1lbnQgaXMgZGlzYWJsZWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvOTE0MlxuICAgICAgICAvLyBNb3N0IGJyb3dzZXJzIGZpcmUgYSBuYXRpdmUgZm9jdXNvdXQgZXZlbnQgaW4gdGhpcyBjYXNlLCBleGNlcHQgZm9yIEZpcmVmb3guIEluIHRoYXQgY2FzZSwgd2UgdXNlIGFcbiAgICAgICAgLy8gTXV0YXRpb25PYnNlcnZlciB0byB3YXRjaCBmb3IgdGhlIGRpc2FibGVkIGF0dHJpYnV0ZSwgYW5kIGRpc3BhdGNoIHRoZXNlIGV2ZW50cyBvdXJzZWx2ZXMuXG4gICAgICAgIC8vIEZvciBicm93c2VycyB0aGF0IGRvLCBmb2N1c291dCBmaXJlcyBiZWZvcmUgdGhlIE11dGF0aW9uT2JzZXJ2ZXIsIHNvIG9uQmx1ciBzaG91bGQgbm90IGZpcmUgdHdpY2UuXG4gICAgICAgIGlmIChlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50IHx8IGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCB8fCBlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxUZXh0QXJlYUVsZW1lbnQgfHwgZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCkge1xuICAgICAgICAgICAgc3RhdGVSZWYuY3VycmVudC5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgbGV0IG9uQmx1ckhhbmRsZXIgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBzdGF0ZVJlZi5jdXJyZW50LmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuZGlzYWJsZWQpIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBkaXNwYXRjaCBhIChmYWtlKSBSZWFjdCBzeW50aGV0aWMgZXZlbnQuXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hCbHVyKG5ldyAkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkOTA1ZTdmYzU0NGE3MWYzNihcImJsdXJcIiwgZSkpO1xuICAgICAgICAgICAgICAgIC8vIFdlIG5vIGxvbmdlciBuZWVkIHRoZSBNdXRhdGlvbk9ic2VydmVyIG9uY2UgdGhlIHRhcmdldCBpcyBibHVycmVkLlxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZVJlZi5jdXJyZW50Lm9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlUmVmLmN1cnJlbnQub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZVJlZi5jdXJyZW50Lm9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBvbkJsdXJIYW5kbGVyLCB7XG4gICAgICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0ZVJlZi5jdXJyZW50Lm9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCk9PntcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVSZWYuY3VycmVudC5pc0ZvY3VzZWQgJiYgdGFyZ2V0LmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfc3RhdGVSZWZfY3VycmVudF9vYnNlcnZlcjtcbiAgICAgICAgICAgICAgICAgICAgKF9zdGF0ZVJlZl9jdXJyZW50X29ic2VydmVyID0gc3RhdGVSZWYuY3VycmVudC5vYnNlcnZlcikgPT09IG51bGwgfHwgX3N0YXRlUmVmX2N1cnJlbnRfb2JzZXJ2ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZVJlZl9jdXJyZW50X29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlbGF0ZWRUYXJnZXRFbCA9IHRhcmdldCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA/IG51bGwgOiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRm9jdXNFdmVudChcImJsdXJcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldEVsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEZvY3VzRXZlbnQoXCJmb2N1c291dFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldEVsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0YXRlUmVmLmN1cnJlbnQub2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQsIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1xuICAgICAgICAgICAgICAgICAgICBcImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgZGlzcGF0Y2hCbHVyXG4gICAgXSk7XG59XG5cblxuZnVuY3Rpb24gJGExZWE1OWQ2ODI3MGYwZGQkZXhwb3J0JGY4MTY4ZDhkZDhmZDY2ZTYocHJvcHMpIHtcbiAgICBsZXQgeyBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLCBvbkZvY3VzOiBvbkZvY3VzUHJvcCwgb25CbHVyOiBvbkJsdXJQcm9wLCBvbkZvY3VzQ2hhbmdlOiBvbkZvY3VzQ2hhbmdlIH0gPSBwcm9wcztcbiAgICBjb25zdCBvbkJsdXIgPSAoMCwgJGJ4N1NMJHVzZUNhbGxiYWNrKSgoZSk9PntcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChvbkJsdXJQcm9wKSBvbkJsdXJQcm9wKGUpO1xuICAgICAgICAgICAgaWYgKG9uRm9jdXNDaGFuZ2UpIG9uRm9jdXNDaGFuZ2UoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIG9uQmx1clByb3AsXG4gICAgICAgIG9uRm9jdXNDaGFuZ2VcbiAgICBdKTtcbiAgICBjb25zdCBvblN5bnRoZXRpY0ZvY3VzID0gKDAsICQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCQ3MTVjNjgyZDA5ZDYzOWNjKShvbkJsdXIpO1xuICAgIGNvbnN0IG9uRm9jdXMgPSAoMCwgJGJ4N1NMJHVzZUNhbGxiYWNrKSgoZSk9PntcbiAgICAgICAgLy8gRG91YmxlIGNoZWNrIHRoYXQgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhY3R1YWxseSBtYXRjaGVzIGUudGFyZ2V0IGluIGNhc2UgYSBwcmV2aW91c2x5IGNoYWluZWRcbiAgICAgICAgLy8gZm9jdXMgaGFuZGxlciBhbHJlYWR5IG1vdmVkIGZvY3VzIHNvbWV3aGVyZSBlbHNlLlxuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlLnRhcmdldCkge1xuICAgICAgICAgICAgaWYgKG9uRm9jdXNQcm9wKSBvbkZvY3VzUHJvcChlKTtcbiAgICAgICAgICAgIGlmIChvbkZvY3VzQ2hhbmdlKSBvbkZvY3VzQ2hhbmdlKHRydWUpO1xuICAgICAgICAgICAgb25TeW50aGV0aWNGb2N1cyhlKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgb25Gb2N1c0NoYW5nZSxcbiAgICAgICAgb25Gb2N1c1Byb3AsXG4gICAgICAgIG9uU3ludGhldGljRm9jdXNcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmb2N1c1Byb3BzOiB7XG4gICAgICAgICAgICBvbkZvY3VzOiAhaXNEaXNhYmxlZCAmJiAob25Gb2N1c1Byb3AgfHwgb25Gb2N1c0NoYW5nZSB8fCBvbkJsdXJQcm9wKSA/IG9uRm9jdXMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvbkJsdXI6ICFpc0Rpc2FibGVkICYmIChvbkJsdXJQcm9wIHx8IG9uRm9jdXNDaGFuZ2UpID8gb25CbHVyIDogdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvLyBQb3J0aW9ucyBvZiB0aGUgY29kZSBpbiB0aGlzIGZpbGUgYXJlIGJhc2VkIG9uIGNvZGUgZnJvbSByZWFjdC5cbi8vIE9yaWdpbmFsIGxpY2Vuc2luZyBmb3IgdGhlIGZvbGxvd2luZyBjYW4gYmUgZm91bmQgaW4gdGhlXG4vLyBOT1RJQ0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvdHJlZS9jYzdjMWFlY2U0NmE2YjY5YjQxOTU4ZDczMWUwZmQyN2M5NGJmYzZjL3BhY2thZ2VzL3JlYWN0LWludGVyYWN0aW9uc1xuXG5cblxubGV0ICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHkgPSBudWxsO1xubGV0ICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjaGFuZ2VIYW5kbGVycyA9IG5ldyBTZXQoKTtcbmxldCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzU2V0dXBHbG9iYWxMaXN0ZW5lcnMgPSBmYWxzZTtcbmxldCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzRXZlbnRCZWZvcmVGb2N1cyA9IGZhbHNlO1xubGV0ICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNCbHVycmVkV2luZG93UmVjZW50bHkgPSBmYWxzZTtcbi8vIE9ubHkgVGFiIG9yIEVzYyBrZXlzIHdpbGwgbWFrZSBmb2N1cyB2aXNpYmxlIG9uIHRleHQgaW5wdXQgZWxlbWVudHNcbmNvbnN0ICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRGT0NVU19WSVNJQkxFX0lOUFVUX0tFWVMgPSB7XG4gICAgVGFiOiB0cnVlLFxuICAgIEVzY2FwZTogdHJ1ZVxufTtcbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJHZhciR0cmlnZ2VyQ2hhbmdlSGFuZGxlcnMobW9kYWxpdHksIGUpIHtcbiAgICBmb3IgKGxldCBoYW5kbGVyIG9mICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjaGFuZ2VIYW5kbGVycyloYW5kbGVyKG1vZGFsaXR5LCBlKTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBhIEtleWJvYXJkRXZlbnQgaXMgdW5tb2RpZmllZCBhbmQgY291bGQgbWFrZSBrZXlib2FyZCBmb2N1cyBzdHlsZXMgdmlzaWJsZS5cbiAqLyBmdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaXNWYWxpZEtleShlKSB7XG4gICAgLy8gQ29udHJvbCBhbmQgU2hpZnQga2V5cyB0cmlnZ2VyIHdoZW4gbmF2aWdhdGluZyBiYWNrIHRvIHRoZSB0YWIgd2l0aCBrZXlib2FyZC5cbiAgICByZXR1cm4gIShlLm1ldGFLZXkgfHwgISgwLCAkYng3U0wkaXNNYWMpKCkgJiYgZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUua2V5ID09PSBcIkNvbnRyb2xcIiB8fCBlLmtleSA9PT0gXCJTaGlmdFwiIHx8IGUua2V5ID09PSBcIk1ldGFcIik7XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlS2V5Ym9hcmRFdmVudChlKSB7XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0V2ZW50QmVmb3JlRm9jdXMgPSB0cnVlO1xuICAgIGlmICgkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaXNWYWxpZEtleShlKSkge1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY3VycmVudE1vZGFsaXR5ID0gXCJrZXlib2FyZFwiO1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkdHJpZ2dlckNoYW5nZUhhbmRsZXJzKFwia2V5Ym9hcmRcIiwgZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudChlKSB7XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eSA9IFwicG9pbnRlclwiO1xuICAgIGlmIChlLnR5cGUgPT09IFwibW91c2Vkb3duXCIgfHwgZS50eXBlID09PSBcInBvaW50ZXJkb3duXCIpIHtcbiAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0V2ZW50QmVmb3JlRm9jdXMgPSB0cnVlO1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkdHJpZ2dlckNoYW5nZUhhbmRsZXJzKFwicG9pbnRlclwiLCBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlQ2xpY2tFdmVudChlKSB7XG4gICAgaWYgKCgwLCAkYng3U0wkaXNWaXJ0dWFsQ2xpY2spKGUpKSB7XG4gICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNFdmVudEJlZm9yZUZvY3VzID0gdHJ1ZTtcbiAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eSA9IFwidmlydHVhbFwiO1xuICAgIH1cbn1cbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVGb2N1c0V2ZW50KGUpIHtcbiAgICAvLyBGaXJlZm94IGZpcmVzIHR3byBleHRyYSBmb2N1cyBldmVudHMgd2hlbiB0aGUgdXNlciBmaXJzdCBjbGlja3MgaW50byBhbiBpZnJhbWU6XG4gICAgLy8gZmlyc3Qgb24gdGhlIHdpbmRvdywgdGhlbiBvbiB0aGUgZG9jdW1lbnQuIFdlIGlnbm9yZSB0aGVzZSBldmVudHMgc28gdGhleSBkb24ndFxuICAgIC8vIGNhdXNlIGtleWJvYXJkIGZvY3VzIHJpbmdzIHRvIGFwcGVhci5cbiAgICBpZiAoZS50YXJnZXQgPT09IHdpbmRvdyB8fCBlLnRhcmdldCA9PT0gZG9jdW1lbnQpIHJldHVybjtcbiAgICAvLyBJZiBhIGZvY3VzIGV2ZW50IG9jY3VycyB3aXRob3V0IGEgcHJlY2VkaW5nIGtleWJvYXJkIG9yIHBvaW50ZXIgZXZlbnQsIHN3aXRjaCB0byB2aXJ0dWFsIG1vZGFsaXR5LlxuICAgIC8vIFRoaXMgb2NjdXJzLCBmb3IgZXhhbXBsZSwgd2hlbiBuYXZpZ2F0aW5nIGEgZm9ybSB3aXRoIHRoZSBuZXh0L3ByZXZpb3VzIGJ1dHRvbnMgb24gaU9TLlxuICAgIGlmICghJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0V2ZW50QmVmb3JlRm9jdXMgJiYgISQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNCbHVycmVkV2luZG93UmVjZW50bHkpIHtcbiAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eSA9IFwidmlydHVhbFwiO1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkdHJpZ2dlckNoYW5nZUhhbmRsZXJzKFwidmlydHVhbFwiLCBlKTtcbiAgICB9XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0V2ZW50QmVmb3JlRm9jdXMgPSBmYWxzZTtcbiAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzQmx1cnJlZFdpbmRvd1JlY2VudGx5ID0gZmFsc2U7XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlV2luZG93Qmx1cigpIHtcbiAgICAvLyBXaGVuIHRoZSB3aW5kb3cgaXMgYmx1cnJlZCwgcmVzZXQgc3RhdGUuIFRoaXMgaXMgbmVjZXNzYXJ5IHdoZW4gdGFiYmluZyBvdXQgb2YgdGhlIHdpbmRvdyxcbiAgICAvLyBmb3IgZXhhbXBsZSwgc2luY2UgYSBzdWJzZXF1ZW50IGZvY3VzIGV2ZW50IHdvbid0IGJlIGZpcmVkLlxuICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNFdmVudEJlZm9yZUZvY3VzID0gZmFsc2U7XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0JsdXJyZWRXaW5kb3dSZWNlbnRseSA9IHRydWU7XG59XG4vKipcbiAqIFNldHVwIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMgdG8gY29udHJvbCB3aGVuIGtleWJvYXJkIGZvY3VzIHN0eWxlIHNob3VsZCBiZSB2aXNpYmxlLlxuICovIGZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRzZXR1cEdsb2JhbEZvY3VzRXZlbnRzKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8ICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNTZXR1cEdsb2JhbExpc3RlbmVycykgcmV0dXJuO1xuICAgIC8vIFByb2dyYW1tYXRpYyBmb2N1cygpIGNhbGxzIHNob3VsZG4ndCBhZmZlY3QgdGhlIGN1cnJlbnQgaW5wdXQgbW9kYWxpdHkuXG4gICAgLy8gSG93ZXZlciwgd2UgbmVlZCB0byBkZXRlY3Qgb3RoZXIgY2FzZXMgd2hlbiBhIGZvY3VzIGV2ZW50IG9jY3VycyB3aXRob3V0XG4gICAgLy8gYSBwcmVjZWRpbmcgdXNlciBldmVudCAoZS5nLiBzY3JlZW4gcmVhZGVyIGZvY3VzKS4gT3ZlcnJpZGluZyB0aGUgZm9jdXNcbiAgICAvLyBtZXRob2Qgb24gSFRNTEVsZW1lbnQucHJvdG90eXBlIGlzIGEgYml0IGhhY2t5LCBidXQgd29ya3MuXG4gICAgbGV0IGZvY3VzID0gSFRNTEVsZW1lbnQucHJvdG90eXBlLmZvY3VzO1xuICAgIEhUTUxFbGVtZW50LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzRXZlbnRCZWZvcmVGb2N1cyA9IHRydWU7XG4gICAgICAgIGZvY3VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlS2V5Ym9hcmRFdmVudCwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVLZXlib2FyZEV2ZW50LCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUNsaWNrRXZlbnQsIHRydWUpO1xuICAgIC8vIFJlZ2lzdGVyIGZvY3VzIGV2ZW50cyBvbiB0aGUgd2luZG93IHNvIHRoZXkgYXJlIHN1cmUgdG8gaGFwcGVuXG4gICAgLy8gYmVmb3JlIFJlYWN0J3MgZXZlbnQgbGlzdGVuZXJzIChyZWdpc3RlcmVkIG9uIHRoZSBkb2N1bWVudCkuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlRm9jdXNFdmVudCwgdHJ1ZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVXaW5kb3dCbHVyLCBmYWxzZSk7XG4gICAgaWYgKHR5cGVvZiBQb2ludGVyRXZlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVQb2ludGVyRXZlbnQsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudCwgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50LCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50LCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudCwgdHJ1ZSk7XG4gICAgfVxuICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNTZXR1cEdsb2JhbExpc3RlbmVycyA9IHRydWU7XG59XG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiKSAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkc2V0dXBHbG9iYWxGb2N1c0V2ZW50cygpO1xuICAgIGVsc2UgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHNldHVwR2xvYmFsRm9jdXNFdmVudHMpO1xufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGI5YjNkZmRkYWIxN2RiMjcoKSB7XG4gICAgcmV0dXJuICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHkgIT09IFwicG9pbnRlclwiO1xufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JDYzMGZmNjUzYzVhZGE2YTkoKSB7XG4gICAgcmV0dXJuICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHk7XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkODM5N2RkZmM1MDRmZGI5YShtb2RhbGl0eSkge1xuICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHkgPSBtb2RhbGl0eTtcbiAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkdHJpZ2dlckNoYW5nZUhhbmRsZXJzKG1vZGFsaXR5LCBudWxsKTtcbn1cbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCQ5OGUyMGVjOTJmNjE0Y2ZlKCkge1xuICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRzZXR1cEdsb2JhbEZvY3VzRXZlbnRzKCk7XG4gICAgbGV0IFttb2RhbGl0eSwgc2V0TW9kYWxpdHldID0gKDAsICRieDdTTCR1c2VTdGF0ZSkoJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eSk7XG4gICAgKDAsICRieDdTTCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGxldCBoYW5kbGVyID0gKCk9PntcbiAgICAgICAgICAgIHNldE1vZGFsaXR5KCQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHkpO1xuICAgICAgICB9O1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY2hhbmdlSGFuZGxlcnMuYWRkKGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjaGFuZ2VIYW5kbGVycy5kZWxldGUoaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAoMCwgJGJ4N1NMJHVzZUlzU1NSKSgpID8gbnVsbCA6IG1vZGFsaXR5O1xufVxuY29uc3QgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJG5vblRleHRJbnB1dFR5cGVzID0gbmV3IFNldChbXG4gICAgXCJjaGVja2JveFwiLFxuICAgIFwicmFkaW9cIixcbiAgICBcInJhbmdlXCIsXG4gICAgXCJjb2xvclwiLFxuICAgIFwiZmlsZVwiLFxuICAgIFwiaW1hZ2VcIixcbiAgICBcImJ1dHRvblwiLFxuICAgIFwic3VibWl0XCIsXG4gICAgXCJyZXNldFwiXG5dKTtcbi8qKlxuICogSWYgdGhpcyBpcyBhdHRhY2hlZCB0byB0ZXh0IGlucHV0IGNvbXBvbmVudCwgcmV0dXJuIGlmIHRoZSBldmVudCBpcyBhIGZvY3VzIGV2ZW50IChUYWIvRXNjYXBlIGtleXMgcHJlc3NlZCkgc28gdGhhdFxuICogZm9jdXMgdmlzaWJsZSBzdHlsZSBjYW4gYmUgcHJvcGVybHkgc2V0LlxuICovIGZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRpc0tleWJvYXJkRm9jdXNFdmVudChpc1RleHRJbnB1dCwgbW9kYWxpdHksIGUpIHtcbiAgICB2YXIgX2VfdGFyZ2V0O1xuICAgIGlzVGV4dElucHV0ID0gaXNUZXh0SW5wdXQgfHwgKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS50YXJnZXQpIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCAmJiAhJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJG5vblRleHRJbnB1dFR5cGVzLmhhcyhlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZV90YXJnZXQgPSBlLnRhcmdldCkgPT09IG51bGwgfHwgX2VfdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZV90YXJnZXQudHlwZSkgfHwgKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS50YXJnZXQpIGluc3RhbmNlb2YgSFRNTFRleHRBcmVhRWxlbWVudCB8fCAoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnRhcmdldCkgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiAoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZSk7XG4gICAgcmV0dXJuICEoaXNUZXh0SW5wdXQgJiYgbW9kYWxpdHkgPT09IFwia2V5Ym9hcmRcIiAmJiBlIGluc3RhbmNlb2YgS2V5Ym9hcmRFdmVudCAmJiAhJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJEZPQ1VTX1ZJU0lCTEVfSU5QVVRfS0VZU1tlLmtleV0pO1xufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGZmZDllNTAyMWMxZmIyZDYocHJvcHMgPSB7fSkge1xuICAgIGxldCB7IGlzVGV4dElucHV0OiBpc1RleHRJbnB1dCwgYXV0b0ZvY3VzOiBhdXRvRm9jdXMgfSA9IHByb3BzO1xuICAgIGxldCBbaXNGb2N1c1Zpc2libGVTdGF0ZSwgc2V0Rm9jdXNWaXNpYmxlXSA9ICgwLCAkYng3U0wkdXNlU3RhdGUpKGF1dG9Gb2N1cyB8fCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkYjliM2RmZGRhYjE3ZGIyNygpKTtcbiAgICAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkZWM3MWI0YjgzYWMwOGVjMygoaXNGb2N1c1Zpc2libGUpPT57XG4gICAgICAgIHNldEZvY3VzVmlzaWJsZShpc0ZvY3VzVmlzaWJsZSk7XG4gICAgfSwgW1xuICAgICAgICBpc1RleHRJbnB1dFxuICAgIF0sIHtcbiAgICAgICAgaXNUZXh0SW5wdXQ6IGlzVGV4dElucHV0XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNGb2N1c1Zpc2libGU6IGlzRm9jdXNWaXNpYmxlU3RhdGVcbiAgICB9O1xufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGVjNzFiNGI4M2FjMDhlYzMoZm4sIGRlcHMsIG9wdHMpIHtcbiAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkc2V0dXBHbG9iYWxGb2N1c0V2ZW50cygpO1xuICAgICgwLCAkYng3U0wkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBsZXQgaGFuZGxlciA9IChtb2RhbGl0eSwgZSk9PntcbiAgICAgICAgICAgIGlmICghJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGlzS2V5Ym9hcmRGb2N1c0V2ZW50KCEhKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5pc1RleHRJbnB1dCksIG1vZGFsaXR5LCBlKSkgcmV0dXJuO1xuICAgICAgICAgICAgZm4oJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGI5YjNkZmRkYWIxN2RiMjcoKSk7XG4gICAgICAgIH07XG4gICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjaGFuZ2VIYW5kbGVycy5hZGQoaGFuZGxlcik7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGNoYW5nZUhhbmRsZXJzLmRlbGV0ZShoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgZGVwcyk7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFBvcnRpb25zIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZSBhcmUgYmFzZWQgb24gY29kZSBmcm9tIHJlYWN0LlxuLy8gT3JpZ2luYWwgbGljZW5zaW5nIGZvciB0aGUgZm9sbG93aW5nIGNhbiBiZSBmb3VuZCBpbiB0aGVcbi8vIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC90cmVlL2NjN2MxYWVjZTQ2YTZiNjliNDE5NThkNzMxZTBmZDI3Yzk0YmZjNmMvcGFja2FnZXMvcmVhY3QtaW50ZXJhY3Rpb25zXG5cblxuZnVuY3Rpb24gJDlhYjk0MjYyYmQwMDQ3YzckZXhwb3J0JDQyMGU2ODI3MzE2NWY0ZWMocHJvcHMpIHtcbiAgICBsZXQgeyBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLCBvbkJsdXJXaXRoaW46IG9uQmx1cldpdGhpbiwgb25Gb2N1c1dpdGhpbjogb25Gb2N1c1dpdGhpbiwgb25Gb2N1c1dpdGhpbkNoYW5nZTogb25Gb2N1c1dpdGhpbkNoYW5nZSB9ID0gcHJvcHM7XG4gICAgbGV0IHN0YXRlID0gKDAsICRieDdTTCR1c2VSZWYpKHtcbiAgICAgICAgaXNGb2N1c1dpdGhpbjogZmFsc2VcbiAgICB9KTtcbiAgICBsZXQgb25CbHVyID0gKDAsICRieDdTTCR1c2VDYWxsYmFjaykoKGUpPT57XG4gICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBvbkJsdXJXaXRoaW4gYW5kIHRoZW4gaW1tZWRpYXRlbHkgb25Gb2N1c1dpdGhpbiBhZ2FpblxuICAgICAgICAvLyB3aGVuIG1vdmluZyBmb2N1cyBpbnNpZGUgdGhlIGVsZW1lbnQuIE9ubHkgdHJpZ2dlciBpZiB0aGUgY3VycmVudFRhcmdldCBkb2Vzbid0XG4gICAgICAgIC8vIGluY2x1ZGUgdGhlIHJlbGF0ZWRUYXJnZXQgKHdoZXJlIGZvY3VzIGlzIG1vdmluZykuXG4gICAgICAgIGlmIChzdGF0ZS5jdXJyZW50LmlzRm9jdXNXaXRoaW4gJiYgIWUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgICAgICBzdGF0ZS5jdXJyZW50LmlzRm9jdXNXaXRoaW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChvbkJsdXJXaXRoaW4pIG9uQmx1cldpdGhpbihlKTtcbiAgICAgICAgICAgIGlmIChvbkZvY3VzV2l0aGluQ2hhbmdlKSBvbkZvY3VzV2l0aGluQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgb25CbHVyV2l0aGluLFxuICAgICAgICBvbkZvY3VzV2l0aGluQ2hhbmdlLFxuICAgICAgICBzdGF0ZVxuICAgIF0pO1xuICAgIGxldCBvblN5bnRoZXRpY0ZvY3VzID0gKDAsICQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCQ3MTVjNjgyZDA5ZDYzOWNjKShvbkJsdXIpO1xuICAgIGxldCBvbkZvY3VzID0gKDAsICRieDdTTCR1c2VDYWxsYmFjaykoKGUpPT57XG4gICAgICAgIC8vIERvdWJsZSBjaGVjayB0aGF0IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYWN0dWFsbHkgbWF0Y2hlcyBlLnRhcmdldCBpbiBjYXNlIGEgcHJldmlvdXNseSBjaGFpbmVkXG4gICAgICAgIC8vIGZvY3VzIGhhbmRsZXIgYWxyZWFkeSBtb3ZlZCBmb2N1cyBzb21ld2hlcmUgZWxzZS5cbiAgICAgICAgaWYgKCFzdGF0ZS5jdXJyZW50LmlzRm9jdXNXaXRoaW4gJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZS50YXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChvbkZvY3VzV2l0aGluKSBvbkZvY3VzV2l0aGluKGUpO1xuICAgICAgICAgICAgaWYgKG9uRm9jdXNXaXRoaW5DaGFuZ2UpIG9uRm9jdXNXaXRoaW5DaGFuZ2UodHJ1ZSk7XG4gICAgICAgICAgICBzdGF0ZS5jdXJyZW50LmlzRm9jdXNXaXRoaW4gPSB0cnVlO1xuICAgICAgICAgICAgb25TeW50aGV0aWNGb2N1cyhlKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgb25Gb2N1c1dpdGhpbixcbiAgICAgICAgb25Gb2N1c1dpdGhpbkNoYW5nZSxcbiAgICAgICAgb25TeW50aGV0aWNGb2N1c1xuICAgIF0pO1xuICAgIGlmIChpc0Rpc2FibGVkKSByZXR1cm4ge1xuICAgICAgICBmb2N1c1dpdGhpblByb3BzOiB7XG4gICAgICAgICAgICAvLyBUaGVzZSBzaG91bGQgbm90IGhhdmUgYmVlbiBudWxsLCB0aGF0IHdvdWxkIGNvbmZsaWN0IGluIG1lcmdlUHJvcHNcbiAgICAgICAgICAgIG9uRm9jdXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9uQmx1cjogdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvY3VzV2l0aGluUHJvcHM6IHtcbiAgICAgICAgICAgIG9uRm9jdXM6IG9uRm9jdXMsXG4gICAgICAgICAgICBvbkJsdXI6IG9uQmx1clxuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gcmVhY3QuXG4vLyBPcmlnaW5hbCBsaWNlbnNpbmcgZm9yIHRoZSBmb2xsb3dpbmcgY2FuIGJlIGZvdW5kIGluIHRoZVxuLy8gTk9USUNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3RyZWUvY2M3YzFhZWNlNDZhNmI2OWI0MTk1OGQ3MzFlMGZkMjdjOTRiZmM2Yy9wYWNrYWdlcy9yZWFjdC1pbnRlcmFjdGlvbnNcblxuLy8gaU9TIGZpcmVzIG9uUG9pbnRlckVudGVyIHR3aWNlOiBvbmNlIHdpdGggcG9pbnRlclR5cGU9XCJ0b3VjaFwiIGFuZCBhZ2FpbiB3aXRoIHBvaW50ZXJUeXBlPVwibW91c2VcIi5cbi8vIFdlIHdhbnQgdG8gaWdub3JlIHRoZXNlIGVtdWxhdGVkIGV2ZW50cyBzbyB0aGV5IGRvIG5vdCB0cmlnZ2VyIGhvdmVyIGJlaGF2aW9yLlxuLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMTQ2MDkuXG5sZXQgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgPSBmYWxzZTtcbmxldCAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkaG92ZXJDb3VudCA9IDA7XG5mdW5jdGlvbiAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkc2V0R2xvYmFsSWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cygpIHtcbiAgICAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkZ2xvYmFsSWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9IHRydWU7XG4gICAgLy8gQ2xlYXIgZ2xvYmFsSWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyBhZnRlciBhIHNob3J0IHRpbWVvdXQuIGlPUyBmaXJlcyBvblBvaW50ZXJFbnRlclxuICAgIC8vIHdpdGggcG9pbnRlclR5cGU9XCJtb3VzZVwiIGltbWVkaWF0ZWx5IGFmdGVyIG9uUG9pbnRlclVwIGFuZCBiZWZvcmUgb25Gb2N1cy4gT24gb3RoZXJcbiAgICAvLyBkZXZpY2VzIHRoYXQgZG9uJ3QgaGF2ZSB0aGlzIHF1aXJrLCB3ZSBkb24ndCB3YW50IHRvIGlnbm9yZSBhIG1vdXNlIGhvdmVyIHNvbWV0aW1lIGluXG4gICAgLy8gdGhlIGRpc3RhbnQgZnV0dXJlIGJlY2F1c2UgYSB1c2VyIHByZXZpb3VzbHkgdG91Y2hlZCB0aGUgZWxlbWVudC5cbiAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRnbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGhhbmRsZUdsb2JhbFBvaW50ZXJFdmVudChlKSB7XG4gICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJHNldEdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMoKTtcbn1cbmZ1bmN0aW9uICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRzZXR1cEdsb2JhbFRvdWNoRXZlbnRzKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIFBvaW50ZXJFdmVudCAhPT0gXCJ1bmRlZmluZWRcIikgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkaGFuZGxlR2xvYmFsUG9pbnRlckV2ZW50KTtcbiAgICBlbHNlIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkc2V0R2xvYmFsSWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyk7XG4gICAgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGhvdmVyQ291bnQrKztcbiAgICByZXR1cm4gKCk9PntcbiAgICAgICAgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGhvdmVyQ291bnQtLTtcbiAgICAgICAgaWYgKCQ2MTc5YjkzNjcwNWU3NmQzJHZhciRob3ZlckNvdW50ID4gMCkgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIFBvaW50ZXJFdmVudCAhPT0gXCJ1bmRlZmluZWRcIikgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkaGFuZGxlR2xvYmFsUG9pbnRlckV2ZW50KTtcbiAgICAgICAgZWxzZSBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJHNldEdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMpO1xuICAgIH07XG59XG5mdW5jdGlvbiAkNjE3OWI5MzY3MDVlNzZkMyRleHBvcnQkYWU3ODBkYWYyOWU2ZDQ1Nihwcm9wcykge1xuICAgIGxldCB7IG9uSG92ZXJTdGFydDogb25Ib3ZlclN0YXJ0LCBvbkhvdmVyQ2hhbmdlOiBvbkhvdmVyQ2hhbmdlLCBvbkhvdmVyRW5kOiBvbkhvdmVyRW5kLCBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkIH0gPSBwcm9wcztcbiAgICBsZXQgW2lzSG92ZXJlZCwgc2V0SG92ZXJlZF0gPSAoMCwgJGJ4N1NMJHVzZVN0YXRlKShmYWxzZSk7XG4gICAgbGV0IHN0YXRlID0gKDAsICRieDdTTCR1c2VSZWYpKHtcbiAgICAgICAgaXNIb3ZlcmVkOiBmYWxzZSxcbiAgICAgICAgaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50czogZmFsc2UsXG4gICAgICAgIHBvaW50ZXJUeXBlOiBcIlwiLFxuICAgICAgICB0YXJnZXQ6IG51bGxcbiAgICB9KS5jdXJyZW50O1xuICAgICgwLCAkYng3U0wkdXNlRWZmZWN0KSgkNjE3OWI5MzY3MDVlNzZkMyR2YXIkc2V0dXBHbG9iYWxUb3VjaEV2ZW50cywgW10pO1xuICAgIGxldCB7IGhvdmVyUHJvcHM6IGhvdmVyUHJvcHMsIHRyaWdnZXJIb3ZlckVuZDogdHJpZ2dlckhvdmVyRW5kIH0gPSAoMCwgJGJ4N1NMJHVzZU1lbW8pKCgpPT57XG4gICAgICAgIGxldCB0cmlnZ2VySG92ZXJTdGFydCA9IChldmVudCwgcG9pbnRlclR5cGUpPT57XG4gICAgICAgICAgICBzdGF0ZS5wb2ludGVyVHlwZSA9IHBvaW50ZXJUeXBlO1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgcG9pbnRlclR5cGUgPT09IFwidG91Y2hcIiB8fCBzdGF0ZS5pc0hvdmVyZWQgfHwgIWV2ZW50LmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAgICAgc3RhdGUuaXNIb3ZlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgc3RhdGUudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKG9uSG92ZXJTdGFydCkgb25Ib3ZlclN0YXJ0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImhvdmVyc3RhcnRcIixcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG9uSG92ZXJDaGFuZ2UpIG9uSG92ZXJDaGFuZ2UodHJ1ZSk7XG4gICAgICAgICAgICBzZXRIb3ZlcmVkKHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgdHJpZ2dlckhvdmVyRW5kID0gKGV2ZW50LCBwb2ludGVyVHlwZSk9PntcbiAgICAgICAgICAgIHN0YXRlLnBvaW50ZXJUeXBlID0gXCJcIjtcbiAgICAgICAgICAgIHN0YXRlLnRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocG9pbnRlclR5cGUgPT09IFwidG91Y2hcIiB8fCAhc3RhdGUuaXNIb3ZlcmVkKSByZXR1cm47XG4gICAgICAgICAgICBzdGF0ZS5pc0hvdmVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgaWYgKG9uSG92ZXJFbmQpIG9uSG92ZXJFbmQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaG92ZXJlbmRcIixcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG9uSG92ZXJDaGFuZ2UpIG9uSG92ZXJDaGFuZ2UoZmFsc2UpO1xuICAgICAgICAgICAgc2V0SG92ZXJlZChmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBob3ZlclByb3BzID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgUG9pbnRlckV2ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBob3ZlclByb3BzLm9uUG9pbnRlckVudGVyID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKCQ2MTc5YjkzNjcwNWU3NmQzJHZhciRnbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzICYmIGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJIb3ZlclN0YXJ0KGUsIGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhvdmVyUHJvcHMub25Qb2ludGVyTGVhdmUgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGlzYWJsZWQgJiYgZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgdHJpZ2dlckhvdmVyRW5kKGUsIGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvdmVyUHJvcHMub25Ub3VjaFN0YXJ0ID0gKCk9PntcbiAgICAgICAgICAgICAgICBzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBob3ZlclByb3BzLm9uTW91c2VFbnRlciA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyAmJiAhJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMpIHRyaWdnZXJIb3ZlclN0YXJ0KGUsIFwibW91c2VcIik7XG4gICAgICAgICAgICAgICAgc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhvdmVyUHJvcHMub25Nb3VzZUxlYXZlID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Rpc2FibGVkICYmIGUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnRhcmdldCkpIHRyaWdnZXJIb3ZlckVuZChlLCBcIm1vdXNlXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaG92ZXJQcm9wczogaG92ZXJQcm9wcyxcbiAgICAgICAgICAgIHRyaWdnZXJIb3ZlckVuZDogdHJpZ2dlckhvdmVyRW5kXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBvbkhvdmVyU3RhcnQsXG4gICAgICAgIG9uSG92ZXJDaGFuZ2UsXG4gICAgICAgIG9uSG92ZXJFbmQsXG4gICAgICAgIGlzRGlzYWJsZWQsXG4gICAgICAgIHN0YXRlXG4gICAgXSk7XG4gICAgKDAsICRieDdTTCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIC8vIENhbGwgdGhlIHRyaWdnZXJIb3ZlckVuZCBhcyBzb29uIGFzIGlzRGlzYWJsZWQgY2hhbmdlcyB0byB0cnVlXG4gICAgICAgIC8vIFNhZmUgdG8gY2FsbCB0cmlnZ2VySG92ZXJFbmQsIGl0IHdpbGwgZWFybHkgcmV0dXJuIGlmIHdlIGFyZW4ndCBjdXJyZW50bHkgaG92ZXJpbmdcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQpIHRyaWdnZXJIb3ZlckVuZCh7XG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiBzdGF0ZS50YXJnZXRcbiAgICAgICAgfSwgc3RhdGUucG9pbnRlclR5cGUpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbXG4gICAgICAgIGlzRGlzYWJsZWRcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBob3ZlclByb3BzOiBob3ZlclByb3BzLFxuICAgICAgICBpc0hvdmVyZWQ6IGlzSG92ZXJlZFxuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFBvcnRpb25zIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZSBhcmUgYmFzZWQgb24gY29kZSBmcm9tIHJlYWN0LlxuLy8gT3JpZ2luYWwgbGljZW5zaW5nIGZvciB0aGUgZm9sbG93aW5nIGNhbiBiZSBmb3VuZCBpbiB0aGVcbi8vIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC90cmVlL2NjN2MxYWVjZTQ2YTZiNjliNDE5NThkNzMxZTBmZDI3Yzk0YmZjNmMvcGFja2FnZXMvcmVhY3QtaW50ZXJhY3Rpb25zXG5cblxuZnVuY3Rpb24gJGUwYjZlMGI2OGVjN2Y1MGYkZXhwb3J0JDg3MmI2NjBhYzVhMWZmOTgocHJvcHMpIHtcbiAgICBsZXQgeyByZWY6IHJlZiwgb25JbnRlcmFjdE91dHNpZGU6IG9uSW50ZXJhY3RPdXRzaWRlLCBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLCBvbkludGVyYWN0T3V0c2lkZVN0YXJ0OiBvbkludGVyYWN0T3V0c2lkZVN0YXJ0IH0gPSBwcm9wcztcbiAgICBsZXQgc3RhdGVSZWYgPSAoMCwgJGJ4N1NMJHVzZVJlZikoe1xuICAgICAgICBpc1BvaW50ZXJEb3duOiBmYWxzZSxcbiAgICAgICAgaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50czogZmFsc2VcbiAgICB9KTtcbiAgICBsZXQgb25Qb2ludGVyRG93biA9ICgwLCAkYng3U0wkdXNlRWZmZWN0RXZlbnQpKChlKT0+e1xuICAgICAgICBpZiAob25JbnRlcmFjdE91dHNpZGUgJiYgJGUwYjZlMGI2OGVjN2Y1MGYkdmFyJGlzVmFsaWRFdmVudChlLCByZWYpKSB7XG4gICAgICAgICAgICBpZiAob25JbnRlcmFjdE91dHNpZGVTdGFydCkgb25JbnRlcmFjdE91dHNpZGVTdGFydChlKTtcbiAgICAgICAgICAgIHN0YXRlUmVmLmN1cnJlbnQuaXNQb2ludGVyRG93biA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgdHJpZ2dlckludGVyYWN0T3V0c2lkZSA9ICgwLCAkYng3U0wkdXNlRWZmZWN0RXZlbnQpKChlKT0+e1xuICAgICAgICBpZiAob25JbnRlcmFjdE91dHNpZGUpIG9uSW50ZXJhY3RPdXRzaWRlKGUpO1xuICAgIH0pO1xuICAgICgwLCAkYng3U0wkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBsZXQgc3RhdGUgPSBzdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoaXNEaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50T2JqZWN0ID0gKDAsICRieDdTTCRnZXRPd25lckRvY3VtZW50KShlbGVtZW50KTtcbiAgICAgICAgLy8gVXNlIHBvaW50ZXIgZXZlbnRzIGlmIGF2YWlsYWJsZS4gT3RoZXJ3aXNlLCBmYWxsIGJhY2sgdG8gbW91c2UgYW5kIHRvdWNoIGV2ZW50cy5cbiAgICAgICAgaWYgKHR5cGVvZiBQb2ludGVyRXZlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCBvblBvaW50ZXJVcCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pc1BvaW50ZXJEb3duICYmICRlMGI2ZTBiNjhlYzdmNTBmJHZhciRpc1ZhbGlkRXZlbnQoZSwgcmVmKSkgdHJpZ2dlckludGVyYWN0T3V0c2lkZShlKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc1BvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gY2hhbmdpbmcgdGhlc2UgdG8gY2FwdHVyZSBwaGFzZSBmaXhlZCBjb21ib2JveFxuICAgICAgICAgICAgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIG9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgICAgICAgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBvblBvaW50ZXJVcCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICAgICBkb2N1bWVudE9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgb25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnRPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBvblBvaW50ZXJVcCwgdHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG9uTW91c2VVcCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzKSBzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUuaXNQb2ludGVyRG93biAmJiAkZTBiNmUwYjY4ZWM3ZjUwZiR2YXIkaXNWYWxpZEV2ZW50KGUsIHJlZikpIHRyaWdnZXJJbnRlcmFjdE91dHNpZGUoZSk7XG4gICAgICAgICAgICAgICAgc3RhdGUuaXNQb2ludGVyRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBvblRvdWNoRW5kID0gKGUpPT57XG4gICAgICAgICAgICAgICAgc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlzUG9pbnRlckRvd24gJiYgJGUwYjZlMGI2OGVjN2Y1MGYkdmFyJGlzVmFsaWRFdmVudChlLCByZWYpKSB0cmlnZ2VySW50ZXJhY3RPdXRzaWRlKGUpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmlzUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkb2N1bWVudE9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIG9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgICAgICAgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwLCB0cnVlKTtcbiAgICAgICAgICAgIGRvY3VtZW50T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIG9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgICAgICAgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIG9uVG91Y2hFbmQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAgICAgZG9jdW1lbnRPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBvblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudE9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBvbk1vdXNlVXAsIHRydWUpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50T2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIG9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50T2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBvblRvdWNoRW5kLCB0cnVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIHJlZixcbiAgICAgICAgaXNEaXNhYmxlZCxcbiAgICAgICAgb25Qb2ludGVyRG93bixcbiAgICAgICAgdHJpZ2dlckludGVyYWN0T3V0c2lkZVxuICAgIF0pO1xufVxuZnVuY3Rpb24gJGUwYjZlMGI2OGVjN2Y1MGYkdmFyJGlzVmFsaWRFdmVudChldmVudCwgcmVmKSB7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiA+IDApIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZXZlbnQudGFyZ2V0KSB7XG4gICAgICAgIC8vIGlmIHRoZSBldmVudCB0YXJnZXQgaXMgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCwgaWdub3JlXG4gICAgICAgIGNvbnN0IG93bmVyRG9jdW1lbnQgPSBldmVudC50YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgICAgaWYgKCFvd25lckRvY3VtZW50IHx8ICFvd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgd2l0aGluIGEgdG9wIGxheWVyIGVsZW1lbnQgKGUuZy4gdG9hc3RzKSwgaWdub3JlLlxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LmNsb3Nlc3QoXCJbZGF0YS1yZWFjdC1hcmlhLXRvcC1sYXllcl1cIikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50ICYmICFyZWYuY3VycmVudC5jb250YWlucyhldmVudC50YXJnZXQpO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJDkzOTI1MDgzZWNiYjM1OGMkZXhwb3J0JDQ4ZDFlYTYzMjA4MzAyNjAoaGFuZGxlcikge1xuICAgIGlmICghaGFuZGxlcikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBsZXQgc2hvdWxkU3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICByZXR1cm4gKGUpPT57XG4gICAgICAgIGxldCBldmVudCA9IHtcbiAgICAgICAgICAgIC4uLmUsXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCAoKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzRGVmYXVsdFByZXZlbnRlZCAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwic3RvcFByb3BhZ2F0aW9uIGlzIG5vdyB0aGUgZGVmYXVsdCBiZWhhdmlvciBmb3IgZXZlbnRzIGluIFJlYWN0IFNwZWN0cnVtLiBZb3UgY2FuIHVzZSBjb250aW51ZVByb3BhZ2F0aW9uKCkgdG8gcmV2ZXJ0IHRoaXMgYmVoYXZpb3IuXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRpbnVlUHJvcGFnYXRpb24gKCkge1xuICAgICAgICAgICAgICAgIHNob3VsZFN0b3BQcm9wYWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBoYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgaWYgKHNob3VsZFN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xufVxuXG5cbmZ1bmN0aW9uICQ0NmQ4MTlmY2JhZjM1NjU0JGV4cG9ydCQ4ZjcxNjU0ODAxYzJmN2NkKHByb3BzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5Ym9hcmRQcm9wczogcHJvcHMuaXNEaXNhYmxlZCA/IHt9IDoge1xuICAgICAgICAgICAgb25LZXlEb3duOiAoMCwgJDkzOTI1MDgzZWNiYjM1OGMkZXhwb3J0JDQ4ZDFlYTYzMjA4MzAyNjApKHByb3BzLm9uS2V5RG93biksXG4gICAgICAgICAgICBvbktleVVwOiAoMCwgJDkzOTI1MDgzZWNiYjM1OGMkZXhwb3J0JDQ4ZDFlYTYzMjA4MzAyNjApKHByb3BzLm9uS2V5VXApXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5mdW5jdGlvbiAkZThhNzAyMmNmODdjYmEyYSRleHBvcnQkMzZkYTk2Mzc5Zjc5ZjI0NShwcm9wcykge1xuICAgIGxldCB7IG9uTW92ZVN0YXJ0OiBvbk1vdmVTdGFydCwgb25Nb3ZlOiBvbk1vdmUsIG9uTW92ZUVuZDogb25Nb3ZlRW5kIH0gPSBwcm9wcztcbiAgICBsZXQgc3RhdGUgPSAoMCwgJGJ4N1NMJHVzZVJlZikoe1xuICAgICAgICBkaWRNb3ZlOiBmYWxzZSxcbiAgICAgICAgbGFzdFBvc2l0aW9uOiBudWxsLFxuICAgICAgICBpZDogbnVsbFxuICAgIH0pO1xuICAgIGxldCB7IGFkZEdsb2JhbExpc3RlbmVyOiBhZGRHbG9iYWxMaXN0ZW5lciwgcmVtb3ZlR2xvYmFsTGlzdGVuZXI6IHJlbW92ZUdsb2JhbExpc3RlbmVyIH0gPSAoMCwgJGJ4N1NMJHVzZUdsb2JhbExpc3RlbmVycykoKTtcbiAgICBsZXQgbW92ZSA9ICgwLCAkYng3U0wkdXNlRWZmZWN0RXZlbnQpKChvcmlnaW5hbEV2ZW50LCBwb2ludGVyVHlwZSwgZGVsdGFYLCBkZWx0YVkpPT57XG4gICAgICAgIGlmIChkZWx0YVggPT09IDAgJiYgZGVsdGFZID09PSAwKSByZXR1cm47XG4gICAgICAgIGlmICghc3RhdGUuY3VycmVudC5kaWRNb3ZlKSB7XG4gICAgICAgICAgICBzdGF0ZS5jdXJyZW50LmRpZE1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgb25Nb3ZlU3RhcnQgPT09IG51bGwgfHwgb25Nb3ZlU3RhcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uTW92ZVN0YXJ0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm1vdmVzdGFydFwiLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgICAgICAgICAgICBzaGlmdEtleTogb3JpZ2luYWxFdmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICBtZXRhS2V5OiBvcmlnaW5hbEV2ZW50Lm1ldGFLZXksXG4gICAgICAgICAgICAgICAgY3RybEtleTogb3JpZ2luYWxFdmVudC5jdHJsS2V5LFxuICAgICAgICAgICAgICAgIGFsdEtleTogb3JpZ2luYWxFdmVudC5hbHRLZXlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG9uTW92ZSA9PT0gbnVsbCB8fCBvbk1vdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uTW92ZSh7XG4gICAgICAgICAgICB0eXBlOiBcIm1vdmVcIixcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgICAgICAgIGRlbHRhWDogZGVsdGFYLFxuICAgICAgICAgICAgZGVsdGFZOiBkZWx0YVksXG4gICAgICAgICAgICBzaGlmdEtleTogb3JpZ2luYWxFdmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgIG1ldGFLZXk6IG9yaWdpbmFsRXZlbnQubWV0YUtleSxcbiAgICAgICAgICAgIGN0cmxLZXk6IG9yaWdpbmFsRXZlbnQuY3RybEtleSxcbiAgICAgICAgICAgIGFsdEtleTogb3JpZ2luYWxFdmVudC5hbHRLZXlcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgbGV0IGVuZCA9ICgwLCAkYng3U0wkdXNlRWZmZWN0RXZlbnQpKChvcmlnaW5hbEV2ZW50LCBwb2ludGVyVHlwZSk9PntcbiAgICAgICAgKDAsICQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCRiMGQ2ZmExYWIzMmUzMjk1KSgpO1xuICAgICAgICBpZiAoc3RhdGUuY3VycmVudC5kaWRNb3ZlKSBvbk1vdmVFbmQgPT09IG51bGwgfHwgb25Nb3ZlRW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbk1vdmVFbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJtb3ZlZW5kXCIsXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICAgICAgICBzaGlmdEtleTogb3JpZ2luYWxFdmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgIG1ldGFLZXk6IG9yaWdpbmFsRXZlbnQubWV0YUtleSxcbiAgICAgICAgICAgIGN0cmxLZXk6IG9yaWdpbmFsRXZlbnQuY3RybEtleSxcbiAgICAgICAgICAgIGFsdEtleTogb3JpZ2luYWxFdmVudC5hbHRLZXlcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgbGV0IG1vdmVQcm9wcyA9ICgwLCAkYng3U0wkdXNlTWVtbykoKCk9PntcbiAgICAgICAgbGV0IG1vdmVQcm9wcyA9IHt9O1xuICAgICAgICBsZXQgc3RhcnQgPSAoKT0+e1xuICAgICAgICAgICAgKDAsICQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCQxNmE0Njk3NDY3MTc1NDg3KSgpO1xuICAgICAgICAgICAgc3RhdGUuY3VycmVudC5kaWRNb3ZlID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgUG9pbnRlckV2ZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBsZXQgb25Nb3VzZU1vdmUgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbiwgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWCwgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VZO1xuICAgICAgICAgICAgICAgICAgICBtb3ZlKGUsIFwibW91c2VcIiwgZS5wYWdlWCAtICgoX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYID0gKF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbiA9IHN0YXRlLmN1cnJlbnQubGFzdFBvc2l0aW9uKSA9PT0gbnVsbCB8fCBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbi5wYWdlWCkgIT09IG51bGwgJiYgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYICE9PSB2b2lkIDAgPyBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVggOiAwKSwgZS5wYWdlWSAtICgoX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VZID0gKF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbjEgPSBzdGF0ZS5jdXJyZW50Lmxhc3RQb3NpdGlvbikgPT09IG51bGwgfHwgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uMS5wYWdlWSkgIT09IG51bGwgJiYgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VZICE9PSB2b2lkIDAgPyBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVkgOiAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnQubGFzdFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVg6IGUucGFnZVgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlWTogZS5wYWdlWVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgb25Nb3VzZVVwID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZChlLCBcIm1vdXNlXCIpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwibW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJtb3VzZXVwXCIsIG9uTW91c2VVcCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtb3ZlUHJvcHMub25Nb3VzZURvd24gPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50Lmxhc3RQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBlLnBhZ2VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVk6IGUucGFnZVlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIod2luZG93LCBcIm1vdXNlbW92ZVwiLCBvbk1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwibW91c2V1cFwiLCBvbk1vdXNlVXAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IG9uVG91Y2hNb3ZlID0gKGUpPT57XG4gICAgICAgICAgICAgICAgbGV0IHRvdWNoID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi5lLmNoYW5nZWRUb3VjaGVzXG4gICAgICAgICAgICAgICAgXS5maW5kSW5kZXgoKHsgaWRlbnRpZmllcjogaWRlbnRpZmllciB9KT0+aWRlbnRpZmllciA9PT0gc3RhdGUuY3VycmVudC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRvdWNoID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbiwgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uMTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgcGFnZVg6IHBhZ2VYLCBwYWdlWTogcGFnZVkgfSA9IGUuY2hhbmdlZFRvdWNoZXNbdG91Y2hdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYLCBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVk7XG4gICAgICAgICAgICAgICAgICAgIG1vdmUoZSwgXCJ0b3VjaFwiLCBwYWdlWCAtICgoX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYID0gKF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbiA9IHN0YXRlLmN1cnJlbnQubGFzdFBvc2l0aW9uKSA9PT0gbnVsbCB8fCBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbi5wYWdlWCkgIT09IG51bGwgJiYgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYICE9PSB2b2lkIDAgPyBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVggOiAwKSwgcGFnZVkgLSAoKF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWSA9IChfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24xID0gc3RhdGUuY3VycmVudC5sYXN0UG9zaXRpb24pID09PSBudWxsIHx8IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbjEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbjEucGFnZVkpICE9PSBudWxsICYmIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWSAhPT0gdm9pZCAwID8gX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VZIDogMCkpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50Lmxhc3RQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBwYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VZOiBwYWdlWVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgb25Ub3VjaEVuZCA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGxldCB0b3VjaCA9IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uZS5jaGFuZ2VkVG91Y2hlc1xuICAgICAgICAgICAgICAgIF0uZmluZEluZGV4KCh7IGlkZW50aWZpZXI6IGlkZW50aWZpZXIgfSk9PmlkZW50aWZpZXIgPT09IHN0YXRlLmN1cnJlbnQuaWQpO1xuICAgICAgICAgICAgICAgIGlmICh0b3VjaCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZChlLCBcInRvdWNoXCIpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50LmlkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlR2xvYmFsTGlzdGVuZXIod2luZG93LCBcInRvdWNobW92ZVwiLCBvblRvdWNoTW92ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJ0b3VjaGVuZFwiLCBvblRvdWNoRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlR2xvYmFsTGlzdGVuZXIod2luZG93LCBcInRvdWNoY2FuY2VsXCIsIG9uVG91Y2hFbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtb3ZlUHJvcHMub25Ub3VjaFN0YXJ0ID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID09PSAwIHx8IHN0YXRlLmN1cnJlbnQuaWQgIT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxldCB7IHBhZ2VYOiBwYWdlWCwgcGFnZVk6IHBhZ2VZLCBpZGVudGlmaWVyOiBpZGVudGlmaWVyIH0gPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudC5sYXN0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBwYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVk6IHBhZ2VZXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50LmlkID0gaWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwidG91Y2htb3ZlXCIsIG9uVG91Y2hNb3ZlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIod2luZG93LCBcInRvdWNoZW5kXCIsIG9uVG91Y2hFbmQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwidG91Y2hjYW5jZWxcIiwgb25Ub3VjaEVuZCwgZmFsc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBvblBvaW50ZXJNb3ZlID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKGUucG9pbnRlcklkID09PSBzdGF0ZS5jdXJyZW50LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24sIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbjE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyVHlwZSA9IGUucG9pbnRlclR5cGUgfHwgXCJtb3VzZVwiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYLCBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb25fcGFnZVk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb2JsZW1zIHdpdGggUG9pbnRlckV2ZW50I21vdmVtZW50WC9tb3ZlbWVudFk6XG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIGl0IGlzIGFsd2F5cyAwIG9uIG1hY09TIFNhZmFyaS5cbiAgICAgICAgICAgICAgICAgICAgLy8gMi4gT24gQ2hyb21lIEFuZHJvaWQsIGl0J3Mgc2NhbGVkIGJ5IGRldmljZVBpeGVsUmF0aW8sIGJ1dCBub3Qgb24gQ2hyb21lIG1hY09TXG4gICAgICAgICAgICAgICAgICAgIG1vdmUoZSwgcG9pbnRlclR5cGUsIGUucGFnZVggLSAoKF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWCA9IChfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24gPSBzdGF0ZS5jdXJyZW50Lmxhc3RQb3NpdGlvbikgPT09IG51bGwgfHwgX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24ucGFnZVgpICE9PSBudWxsICYmIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWCAhPT0gdm9pZCAwID8gX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYIDogMCksIGUucGFnZVkgLSAoKF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWSA9IChfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24xID0gc3RhdGUuY3VycmVudC5sYXN0UG9zaXRpb24pID09PSBudWxsIHx8IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbjEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbjEucGFnZVkpICE9PSBudWxsICYmIF9zdGF0ZV9jdXJyZW50X2xhc3RQb3NpdGlvbl9wYWdlWSAhPT0gdm9pZCAwID8gX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VZIDogMCkpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50Lmxhc3RQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBlLnBhZ2VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVk6IGUucGFnZVlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IG9uUG9pbnRlclVwID0gKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKGUucG9pbnRlcklkID09PSBzdGF0ZS5jdXJyZW50LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyVHlwZSA9IGUucG9pbnRlclR5cGUgfHwgXCJtb3VzZVwiO1xuICAgICAgICAgICAgICAgICAgICBlbmQoZSwgcG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50LmlkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlR2xvYmFsTGlzdGVuZXIod2luZG93LCBcInBvaW50ZXJtb3ZlXCIsIG9uUG9pbnRlck1vdmUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlR2xvYmFsTGlzdGVuZXIod2luZG93LCBcInBvaW50ZXJ1cFwiLCBvblBvaW50ZXJVcCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwicG9pbnRlcmNhbmNlbFwiLCBvblBvaW50ZXJVcCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtb3ZlUHJvcHMub25Qb2ludGVyRG93biA9IChlKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMCAmJiBzdGF0ZS5jdXJyZW50LmlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50Lmxhc3RQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBlLnBhZ2VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVk6IGUucGFnZVlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudC5pZCA9IGUucG9pbnRlcklkO1xuICAgICAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwicG9pbnRlcm1vdmVcIiwgb25Qb2ludGVyTW92ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwicG9pbnRlcnVwXCIsIG9uUG9pbnRlclVwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKHdpbmRvdywgXCJwb2ludGVyY2FuY2VsXCIsIG9uUG9pbnRlclVwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHJpZ2dlcktleWJvYXJkTW92ZSA9IChlLCBkZWx0YVgsIGRlbHRhWSk9PntcbiAgICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgICAgICBtb3ZlKGUsIFwia2V5Ym9hcmRcIiwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICAgICAgZW5kKGUsIFwia2V5Ym9hcmRcIik7XG4gICAgICAgIH07XG4gICAgICAgIG1vdmVQcm9wcy5vbktleURvd24gPSAoZSk9PntcbiAgICAgICAgICAgIHN3aXRjaChlLmtleSl7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkxlZnRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcktleWJvYXJkTW92ZShlLCAtMSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJSaWdodFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcktleWJvYXJkTW92ZShlLCAxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlVwXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyS2V5Ym9hcmRNb3ZlKGUsIDAsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkRvd25cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcktleWJvYXJkTW92ZShlLCAwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtb3ZlUHJvcHM7XG4gICAgfSwgW1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIsXG4gICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyLFxuICAgICAgICBtb3ZlLFxuICAgICAgICBlbmRcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtb3ZlUHJvcHM6IG1vdmVQcm9wc1xuICAgIH07XG59XG5cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmZ1bmN0aW9uICQ3ZDBhNjM2ZDdhNGRjZWZkJGV4cG9ydCQyMTIzZmYyYjg3YzgxY2EocHJvcHMsIHJlZikge1xuICAgIGxldCB7IG9uU2Nyb2xsOiBvblNjcm9sbCwgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCB9ID0gcHJvcHM7XG4gICAgbGV0IG9uU2Nyb2xsSGFuZGxlciA9ICgwLCAkYng3U0wkdXNlQ2FsbGJhY2spKChlKT0+e1xuICAgICAgICAvLyBJZiB0aGUgY3RybEtleSBpcyBwcmVzc2VkLCB0aGlzIGlzIGEgem9vbSBldmVudCwgZG8gbm90aGluZy5cbiAgICAgICAgaWYgKGUuY3RybEtleSkgcmV0dXJuO1xuICAgICAgICAvLyBzdG9wIHNjcm9sbGluZyB0aGUgcGFnZVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmIChvblNjcm9sbCkgb25TY3JvbGwoe1xuICAgICAgICAgICAgZGVsdGFYOiBlLmRlbHRhWCxcbiAgICAgICAgICAgIGRlbHRhWTogZS5kZWx0YVlcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBvblNjcm9sbFxuICAgIF0pO1xuICAgICgwLCAkYng3U0wkdXNlRXZlbnQpKHJlZiwgXCJ3aGVlbFwiLCBpc0Rpc2FibGVkID8gdW5kZWZpbmVkIDogb25TY3JvbGxIYW5kbGVyKTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuY29uc3QgJDhhMjY1NjFkMjg3NzIzNmUkdmFyJERFRkFVTFRfVEhSRVNIT0xEID0gNTAwO1xuZnVuY3Rpb24gJDhhMjY1NjFkMjg3NzIzNmUkZXhwb3J0JGMyNGVkMDEwNGQwN2VhYjkocHJvcHMpIHtcbiAgICBsZXQgeyBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLCBvbkxvbmdQcmVzc1N0YXJ0OiBvbkxvbmdQcmVzc1N0YXJ0LCBvbkxvbmdQcmVzc0VuZDogb25Mb25nUHJlc3NFbmQsIG9uTG9uZ1ByZXNzOiBvbkxvbmdQcmVzcywgdGhyZXNob2xkOiB0aHJlc2hvbGQgPSAkOGEyNjU2MWQyODc3MjM2ZSR2YXIkREVGQVVMVF9USFJFU0hPTEQsIGFjY2Vzc2liaWxpdHlEZXNjcmlwdGlvbjogYWNjZXNzaWJpbGl0eURlc2NyaXB0aW9uIH0gPSBwcm9wcztcbiAgICBjb25zdCB0aW1lUmVmID0gKDAsICRieDdTTCR1c2VSZWYpKCk7XG4gICAgbGV0IHsgYWRkR2xvYmFsTGlzdGVuZXI6IGFkZEdsb2JhbExpc3RlbmVyLCByZW1vdmVHbG9iYWxMaXN0ZW5lcjogcmVtb3ZlR2xvYmFsTGlzdGVuZXIgfSA9ICgwLCAkYng3U0wkdXNlR2xvYmFsTGlzdGVuZXJzKSgpO1xuICAgIGxldCB7IHByZXNzUHJvcHM6IHByZXNzUHJvcHMgfSA9ICgwLCAkZjZjMzFjY2UyYWRmNjU0ZiRleHBvcnQkNDU3MTJlY2VkYTZmYWQyMSkoe1xuICAgICAgICBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLFxuICAgICAgICBvblByZXNzU3RhcnQgKGUpIHtcbiAgICAgICAgICAgIGUuY29udGludWVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAob25Mb25nUHJlc3NTdGFydCkgb25Mb25nUHJlc3NTdGFydCh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibG9uZ3ByZXNzc3RhcnRcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRpbWVSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBvdGhlciB1c2VQcmVzcyBoYW5kbGVycyBmcm9tIGFsc28gaGFuZGxpbmcgdGhpcyBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgUG9pbnRlckV2ZW50KFwicG9pbnRlcmNhbmNlbFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uTG9uZ1ByZXNzKSBvbkxvbmdQcmVzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJsb25ncHJlc3NcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGltZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0sIHRocmVzaG9sZCk7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBjb250ZXh0IG1lbnUsIHdoaWNoIG1heSBiZSBvcGVuZWQgb24gbG9uZyBwcmVzcyBvbiB0b3VjaCBkZXZpY2VzXG4gICAgICAgICAgICAgICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb25Db250ZXh0TWVudSA9IChlKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcihlLnRhcmdldCwgXCJjb250ZXh0bWVudVwiLCBvbkNvbnRleHRNZW51LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcih3aW5kb3csIFwicG9pbnRlcnVwXCIsICgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBjb250ZXh0bWVudSBldmVudCBpcyBmaXJlZCBxdWlja2x5IGFmdGVyIHBvaW50ZXJ1cCwgcmVtb3ZlIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBmdXR1cmUgY29udGV4dCBtZW51IGV2ZW50cyBvdXRzaWRlIGEgbG9uZyBwcmVzcyBhcmUgbm90IHByZXZlbnRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVHbG9iYWxMaXN0ZW5lcihlLnRhcmdldCwgXCJjb250ZXh0bWVudVwiLCBvbkNvbnRleHRNZW51KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDMwKTtcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJlc3NFbmQgKGUpIHtcbiAgICAgICAgICAgIGlmICh0aW1lUmVmLmN1cnJlbnQpIGNsZWFyVGltZW91dCh0aW1lUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKG9uTG9uZ1ByZXNzRW5kICYmIChlLnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIgfHwgZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSkgb25Mb25nUHJlc3NFbmQoe1xuICAgICAgICAgICAgICAgIC4uLmUsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJsb25ncHJlc3NlbmRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgZGVzY3JpcHRpb25Qcm9wcyA9ICgwLCAkYng3U0wkdXNlRGVzY3JpcHRpb24pKG9uTG9uZ1ByZXNzICYmICFpc0Rpc2FibGVkID8gYWNjZXNzaWJpbGl0eURlc2NyaXB0aW9uIDogdW5kZWZpbmVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsb25nUHJlc3NQcm9wczogKDAsICRieDdTTCRtZXJnZVByb3BzKShwcmVzc1Byb3BzLCBkZXNjcmlwdGlvblByb3BzKVxuICAgIH07XG59XG5cblxuXG5cbmV4cG9ydCB7JDNiMTE3ZTQzZGMwY2E5NWQkZXhwb3J0JDI3YzcwMWVkOWU0NDllOTkgYXMgUHJlc3NhYmxlLCAkZjFhYjhjNzU0NzhjNmY3MyRleHBvcnQkMzM1MTg3MWVlNGIyODhiOCBhcyBQcmVzc1Jlc3BvbmRlciwgJGYxYWI4Yzc1NDc4YzZmNzMkZXhwb3J0JGNmNzU0MjhlMGI5ZWQxZWEgYXMgQ2xlYXJQcmVzc1Jlc3BvbmRlciwgJGExZWE1OWQ2ODI3MGYwZGQkZXhwb3J0JGY4MTY4ZDhkZDhmZDY2ZTYgYXMgdXNlRm9jdXMsICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRiOWIzZGZkZGFiMTdkYjI3IGFzIGlzRm9jdXNWaXNpYmxlLCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkNjMwZmY2NTNjNWFkYTZhOSBhcyBnZXRJbnRlcmFjdGlvbk1vZGFsaXR5LCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkODM5N2RkZmM1MDRmZGI5YSBhcyBzZXRJbnRlcmFjdGlvbk1vZGFsaXR5LCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkOThlMjBlYzkyZjYxNGNmZSBhcyB1c2VJbnRlcmFjdGlvbk1vZGFsaXR5LCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkZmZkOWU1MDIxYzFmYjJkNiBhcyB1c2VGb2N1c1Zpc2libGUsICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRlYzcxYjRiODNhYzA4ZWMzIGFzIHVzZUZvY3VzVmlzaWJsZUxpc3RlbmVyLCAkOWFiOTQyNjJiZDAwNDdjNyRleHBvcnQkNDIwZTY4MjczMTY1ZjRlYyBhcyB1c2VGb2N1c1dpdGhpbiwgJDYxNzliOTM2NzA1ZTc2ZDMkZXhwb3J0JGFlNzgwZGFmMjllNmQ0NTYgYXMgdXNlSG92ZXIsICRlMGI2ZTBiNjhlYzdmNTBmJGV4cG9ydCQ4NzJiNjYwYWM1YTFmZjk4IGFzIHVzZUludGVyYWN0T3V0c2lkZSwgJDQ2ZDgxOWZjYmFmMzU2NTQkZXhwb3J0JDhmNzE2NTQ4MDFjMmY3Y2QgYXMgdXNlS2V5Ym9hcmQsICRlOGE3MDIyY2Y4N2NiYTJhJGV4cG9ydCQzNmRhOTYzNzlmNzlmMjQ1IGFzIHVzZU1vdmUsICRmNmMzMWNjZTJhZGY2NTRmJGV4cG9ydCQ0NTcxMmVjZWRhNmZhZDIxIGFzIHVzZVByZXNzLCAkN2QwYTYzNmQ3YTRkY2VmZCRleHBvcnQkMjEyM2ZmMmI4N2M4MWNhIGFzIHVzZVNjcm9sbFdoZWVsLCAkOGEyNjU2MWQyODc3MjM2ZSRleHBvcnQkYzI0ZWQwMTA0ZDA3ZWFiOSBhcyB1c2VMb25nUHJlc3N9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZU9iamVjdFJlZiIsIiRieDdTTCR1c2VPYmplY3RSZWYiLCJtZXJnZVByb3BzIiwiJGJ4N1NMJG1lcmdlUHJvcHMiLCJ1c2VTeW5jUmVmIiwiJGJ4N1NMJHVzZVN5bmNSZWYiLCJ1c2VHbG9iYWxMaXN0ZW5lcnMiLCIkYng3U0wkdXNlR2xvYmFsTGlzdGVuZXJzIiwidXNlRWZmZWN0RXZlbnQiLCIkYng3U0wkdXNlRWZmZWN0RXZlbnQiLCJnZXRPd25lckRvY3VtZW50IiwiJGJ4N1NMJGdldE93bmVyRG9jdW1lbnQiLCJpc01hYyIsIiRieDdTTCRpc01hYyIsIm9wZW5MaW5rIiwiJGJ4N1NMJG9wZW5MaW5rIiwiaXNWaXJ0dWFsQ2xpY2siLCIkYng3U0wkaXNWaXJ0dWFsQ2xpY2siLCJmb2N1c1dpdGhvdXRTY3JvbGxpbmciLCIkYng3U0wkZm9jdXNXaXRob3V0U2Nyb2xsaW5nIiwiaXNWaXJ0dWFsUG9pbnRlckV2ZW50IiwiJGJ4N1NMJGlzVmlydHVhbFBvaW50ZXJFdmVudCIsImdldE93bmVyV2luZG93IiwiJGJ4N1NMJGdldE93bmVyV2luZG93IiwiaXNJT1MiLCIkYng3U0wkaXNJT1MiLCJydW5BZnRlclRyYW5zaXRpb24iLCIkYng3U0wkcnVuQWZ0ZXJUcmFuc2l0aW9uIiwidXNlTGF5b3V0RWZmZWN0IiwiJGJ4N1NMJHVzZUxheW91dEVmZmVjdCIsInVzZUV2ZW50IiwiJGJ4N1NMJHVzZUV2ZW50IiwidXNlRGVzY3JpcHRpb24iLCIkYng3U0wkdXNlRGVzY3JpcHRpb24iLCIkYng3U0wkcmVhY3QiLCJ1c2VDb250ZXh0IiwiJGJ4N1NMJHVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsIiRieDdTTCR1c2VTdGF0ZSIsInVzZVJlZiIsIiRieDdTTCR1c2VSZWYiLCJ1c2VNZW1vIiwiJGJ4N1NMJHVzZU1lbW8iLCJ1c2VFZmZlY3QiLCIkYng3U0wkdXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCIkYng3U0wkdXNlQ2FsbGJhY2siLCJfIiwiJGJ4N1NMJF8iLCIkYng3U0wkXzEiLCIkYng3U0wkXzIiLCJ1c2VJc1NTUiIsIiRieDdTTCR1c2VJc1NTUiIsIiQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzdGF0ZSIsIiQxNGMwYjcyNTA5ZDcwMjI1JHZhciRzYXZlZFVzZXJTZWxlY3QiLCIkMTRjMGI3MjUwOWQ3MDIyNSR2YXIkbW9kaWZpZWRFbGVtZW50TWFwIiwiV2Vha01hcCIsIiQxNGMwYjcyNTA5ZDcwMjI1JGV4cG9ydCQxNmE0Njk3NDY3MTc1NDg3IiwidGFyZ2V0IiwiZG9jdW1lbnRPYmplY3QiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZSIsIndlYmtpdFVzZXJTZWxlY3QiLCJIVE1MRWxlbWVudCIsIlNWR0VsZW1lbnQiLCJzZXQiLCJ1c2VyU2VsZWN0IiwiJDE0YzBiNzI1MDlkNzAyMjUkZXhwb3J0JGIwZDZmYTFhYjMyZTMyOTUiLCJzZXRUaW1lb3V0IiwiaGFzIiwidGFyZ2V0T2xkVXNlclNlbGVjdCIsImdldCIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsImRlbGV0ZSIsIiRhZTFlZWJhOGI5ZWFmZDA4JGV4cG9ydCQ1MTY1ZWNjYjM1YWFhZGI1IiwiY3JlYXRlQ29udGV4dCIsInJlZ2lzdGVyIiwiZGlzcGxheU5hbWUiLCIkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkdXNlUHJlc3NSZXNwb25kZXJDb250ZXh0IiwicHJvcHMiLCJjb250ZXh0IiwiY29udGV4dFByb3BzIiwicmVmIiwiJGY2YzMxY2NlMmFkZjY1NGYkdmFyJF9zaG91bGRTdG9wUHJvcGFnYXRpb24iLCIkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkUHJlc3NFdmVudCIsImNvbnRpbnVlUHJvcGFnYXRpb24iLCJzaG91bGRTdG9wUHJvcGFnYXRpb24iLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJwb2ludGVyVHlwZSIsIm9yaWdpbmFsRXZlbnQiLCJ3cml0YWJsZSIsInZhbHVlIiwiY3VycmVudFRhcmdldCIsInNoaWZ0S2V5IiwibWV0YUtleSIsImN0cmxLZXkiLCJhbHRLZXkiLCIkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkTElOS19DTElDS0VEIiwiU3ltYm9sIiwiJGY2YzMxY2NlMmFkZjY1NGYkZXhwb3J0JDQ1NzEyZWNlZGE2ZmFkMjEiLCJvblByZXNzIiwib25QcmVzc0NoYW5nZSIsIm9uUHJlc3NTdGFydCIsIm9uUHJlc3NFbmQiLCJvblByZXNzVXAiLCJpc0Rpc2FibGVkIiwiaXNQcmVzc2VkIiwiaXNQcmVzc2VkUHJvcCIsInByZXZlbnRGb2N1c09uUHJlc3MiLCJzaG91bGRDYW5jZWxPblBvaW50ZXJFeGl0IiwiYWxsb3dUZXh0U2VsZWN0aW9uT25QcmVzcyIsImRvbVByb3BzIiwic2V0UHJlc3NlZCIsImlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMiLCJpZ25vcmVDbGlja0FmdGVyUHJlc3MiLCJkaWRGaXJlUHJlc3NTdGFydCIsImlzVHJpZ2dlcmluZ0V2ZW50IiwiYWN0aXZlUG9pbnRlcklkIiwiaXNPdmVyVGFyZ2V0IiwiYWRkR2xvYmFsTGlzdGVuZXIiLCJyZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMiLCJ0cmlnZ2VyUHJlc3NTdGFydCIsInN0YXRlIiwiY3VycmVudCIsImV2ZW50IiwidHJpZ2dlclByZXNzRW5kIiwid2FzUHJlc3NlZCIsInRyaWdnZXJQcmVzc1VwIiwiY2FuY2VsIiwiZSIsIiRmNmMzMWNjZTJhZGY2NTRmJHZhciRjcmVhdGVFdmVudCIsImNhbmNlbE9uUG9pbnRlckV4aXQiLCJwcmVzc1Byb3BzIiwib25LZXlEb3duIiwiJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzVmFsaWRLZXlib2FyZEV2ZW50IiwibmF0aXZlRXZlbnQiLCJjb250YWlucyIsIl9zdGF0ZV9tZXRhS2V5RXZlbnRzIiwiJGY2YzMxY2NlMmFkZjY1NGYkdmFyJHNob3VsZFByZXZlbnREZWZhdWx0S2V5Ym9hcmQiLCJrZXkiLCJwcmV2ZW50RGVmYXVsdCIsInJlcGVhdCIsIm9uS2V5VXAiLCJzdG9wUHJvcGFnYXRpb24iLCJtZXRhS2V5RXZlbnRzIiwiTWFwIiwib25DbGljayIsImJ1dHRvbiIsImlzT3BlbmluZyIsInN0b3BQcmVzc1N0YXJ0Iiwic3RvcFByZXNzVXAiLCJzdG9wUHJlc3NFbmQiLCJfc3RhdGVfbWV0YUtleUV2ZW50czEiLCIkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNIVE1MQW5jaG9yTGluayIsInNpemUiLCJfc3RhdGVfdGFyZ2V0IiwiZXZlbnRzIiwidW5kZWZpbmVkIiwidmFsdWVzIiwiZGlzcGF0Y2hFdmVudCIsIktleWJvYXJkRXZlbnQiLCJQb2ludGVyRXZlbnQiLCJvblBvaW50ZXJEb3duIiwiJGY2YzMxY2NlMmFkZjY1NGYkdmFyJHNob3VsZFByZXZlbnREZWZhdWx0IiwicG9pbnRlcklkIiwib25Qb2ludGVyTW92ZSIsIm9uUG9pbnRlclVwIiwib25Qb2ludGVyQ2FuY2VsIiwib25Nb3VzZURvd24iLCIkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkaXNPdmVyVGFyZ2V0Iiwib25EcmFnU3RhcnQiLCJvbk1vdXNlVXAiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJvblRvdWNoU3RhcnQiLCJ0b3VjaCIsIiRmNmMzMWNjZTJhZGY2NTRmJHZhciRnZXRUb3VjaEZyb21FdmVudCIsImlkZW50aWZpZXIiLCJvblNjcm9sbCIsIm9uVG91Y2hNb3ZlIiwiJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGdldFRvdWNoQnlJZCIsIm9uVG91Y2hFbmQiLCJvblRvdWNoQ2FuY2VsIiwiX3JlZl9jdXJyZW50X3RhcmdldCIsInRhZ05hbWUiLCJoYXNBdHRyaWJ1dGUiLCJjb2RlIiwiZWxlbWVudCIsInJvbGUiLCJIVE1MSW5wdXRFbGVtZW50IiwiJGY2YzMxY2NlMmFkZjY1NGYkdmFyJGlzVmFsaWRJbnB1dEtleSIsIkhUTUxUZXh0QXJlYUVsZW1lbnQiLCJpc0NvbnRlbnRFZGl0YWJsZSIsInRhcmdldFRvdWNoZXMiLCJsZW5ndGgiLCJjaGFuZ2VkVG91Y2hlcyIsImkiLCIkZjZjMzFjY2UyYWRmNjU0ZiR2YXIkZ2V0UG9pbnRDbGllbnRSZWN0IiwicG9pbnQiLCJvZmZzZXRYIiwib2Zmc2V0WSIsIndpZHRoIiwicmFkaXVzWCIsImhlaWdodCIsInJhZGl1c1kiLCJ0b3AiLCJjbGllbnRZIiwicmlnaHQiLCJjbGllbnRYIiwiYm90dG9tIiwibGVmdCIsIiRmNmMzMWNjZTJhZGY2NTRmJHZhciRhcmVSZWN0YW5nbGVzT3ZlcmxhcHBpbmciLCJhIiwiYiIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwb2ludFJlY3QiLCJIVE1MQnV0dG9uRWxlbWVudCIsIiRmNmMzMWNjZTJhZGY2NTRmJHZhciRub25UZXh0SW5wdXRUeXBlcyIsIlNldCIsIiQzYjExN2U0M2RjMGNhOTVkJGV4cG9ydCQyN2M3MDFlZDllNDQ5ZTk5IiwiZm9yd2FyZFJlZiIsImNoaWxkcmVuIiwiY2hpbGQiLCJDaGlsZHJlbiIsIm9ubHkiLCJjbG9uZUVsZW1lbnQiLCIkZjFhYjhjNzU0NzhjNmY3MyRleHBvcnQkMzM1MTg3MWVlNGIyODhiOCIsImlzUmVnaXN0ZXJlZCIsInByZXZDb250ZXh0IiwiY29uc29sZSIsIndhcm4iLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCIkZjFhYjhjNzU0NzhjNmY3MyRleHBvcnQkY2Y3NTQyOGUwYjllZDFlYSIsIiQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCQ5MDVlN2ZjNTQ0YTcxZjM2IiwiaXNEZWZhdWx0UHJldmVudGVkIiwiZGVmYXVsdFByZXZlbnRlZCIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwicGVyc2lzdCIsInJlbGF0ZWRUYXJnZXQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImV2ZW50UGhhc2UiLCJpc1RydXN0ZWQiLCJ0aW1lU3RhbXAiLCIkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkNzE1YzY4MmQwOWQ2MzljYyIsIm9uQmx1ciIsInN0YXRlUmVmIiwiaXNGb2N1c2VkIiwib2JzZXJ2ZXIiLCJkaXNjb25uZWN0IiwiZGlzcGF0Y2hCbHVyIiwiSFRNTFNlbGVjdEVsZW1lbnQiLCJvbkJsdXJIYW5kbGVyIiwiZGlzYWJsZWQiLCJhZGRFdmVudExpc3RlbmVyIiwib25jZSIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJfc3RhdGVSZWZfY3VycmVudF9vYnNlcnZlciIsInJlbGF0ZWRUYXJnZXRFbCIsImRvY3VtZW50IiwiYWN0aXZlRWxlbWVudCIsIkZvY3VzRXZlbnQiLCJvYnNlcnZlIiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZUZpbHRlciIsIiRhMWVhNTlkNjgyNzBmMGRkJGV4cG9ydCRmODE2OGQ4ZGQ4ZmQ2NmU2Iiwib25Gb2N1cyIsIm9uRm9jdXNQcm9wIiwib25CbHVyUHJvcCIsIm9uRm9jdXNDaGFuZ2UiLCJvblN5bnRoZXRpY0ZvY3VzIiwiZm9jdXNQcm9wcyIsIiQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHkiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY2hhbmdlSGFuZGxlcnMiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzU2V0dXBHbG9iYWxMaXN0ZW5lcnMiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzRXZlbnRCZWZvcmVGb2N1cyIsIiQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNCbHVycmVkV2luZG93UmVjZW50bHkiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkRk9DVVNfVklTSUJMRV9JTlBVVF9LRVlTIiwiVGFiIiwiRXNjYXBlIiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHRyaWdnZXJDaGFuZ2VIYW5kbGVycyIsIm1vZGFsaXR5IiwiaGFuZGxlciIsIiQ1MDdmYWJlMTBlNzFjNmZiJHZhciRpc1ZhbGlkS2V5IiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUtleWJvYXJkRXZlbnQiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50IiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUNsaWNrRXZlbnQiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlRm9jdXNFdmVudCIsIndpbmRvdyIsIiQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVXaW5kb3dCbHVyIiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHNldHVwR2xvYmFsRm9jdXNFdmVudHMiLCJmb2N1cyIsInByb3RvdHlwZSIsImFwcGx5IiwiYXJndW1lbnRzIiwicmVhZHlTdGF0ZSIsIiQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRiOWIzZGZkZGFiMTdkYjI3IiwiJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JDYzMGZmNjUzYzVhZGE2YTkiLCIkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkODM5N2RkZmM1MDRmZGI5YSIsIiQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCQ5OGUyMGVjOTJmNjE0Y2ZlIiwic2V0TW9kYWxpdHkiLCJhZGQiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkbm9uVGV4dElucHV0VHlwZXMiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaXNLZXlib2FyZEZvY3VzRXZlbnQiLCJpc1RleHRJbnB1dCIsIl9lX3RhcmdldCIsIiQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRmZmQ5ZTUwMjFjMWZiMmQ2IiwiYXV0b0ZvY3VzIiwiaXNGb2N1c1Zpc2libGVTdGF0ZSIsInNldEZvY3VzVmlzaWJsZSIsIiQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRlYzcxYjRiODNhYzA4ZWMzIiwiaXNGb2N1c1Zpc2libGUiLCJmbiIsImRlcHMiLCJvcHRzIiwiJDlhYjk0MjYyYmQwMDQ3YzckZXhwb3J0JDQyMGU2ODI3MzE2NWY0ZWMiLCJvbkJsdXJXaXRoaW4iLCJvbkZvY3VzV2l0aGluIiwib25Gb2N1c1dpdGhpbkNoYW5nZSIsImlzRm9jdXNXaXRoaW4iLCJmb2N1c1dpdGhpblByb3BzIiwiJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMiLCIkNjE3OWI5MzY3MDVlNzZkMyR2YXIkaG92ZXJDb3VudCIsIiQ2MTc5YjkzNjcwNWU3NmQzJHZhciRzZXRHbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzIiwiJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGhhbmRsZUdsb2JhbFBvaW50ZXJFdmVudCIsIiQ2MTc5YjkzNjcwNWU3NmQzJHZhciRzZXR1cEdsb2JhbFRvdWNoRXZlbnRzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIiQ2MTc5YjkzNjcwNWU3NmQzJGV4cG9ydCRhZTc4MGRhZjI5ZTZkNDU2Iiwib25Ib3ZlclN0YXJ0Iiwib25Ib3ZlckNoYW5nZSIsIm9uSG92ZXJFbmQiLCJpc0hvdmVyZWQiLCJzZXRIb3ZlcmVkIiwiaG92ZXJQcm9wcyIsInRyaWdnZXJIb3ZlckVuZCIsInRyaWdnZXJIb3ZlclN0YXJ0Iiwib25Qb2ludGVyRW50ZXIiLCJvblBvaW50ZXJMZWF2ZSIsIiRlMGI2ZTBiNjhlYzdmNTBmJGV4cG9ydCQ4NzJiNjYwYWM1YTFmZjk4Iiwib25JbnRlcmFjdE91dHNpZGUiLCJvbkludGVyYWN0T3V0c2lkZVN0YXJ0IiwiaXNQb2ludGVyRG93biIsIiRlMGI2ZTBiNjhlYzdmNTBmJHZhciRpc1ZhbGlkRXZlbnQiLCJ0cmlnZ2VySW50ZXJhY3RPdXRzaWRlIiwib3duZXJEb2N1bWVudCIsImNsb3Nlc3QiLCIkOTM5MjUwODNlY2JiMzU4YyRleHBvcnQkNDhkMWVhNjMyMDgzMDI2MCIsImVycm9yIiwiJDQ2ZDgxOWZjYmFmMzU2NTQkZXhwb3J0JDhmNzE2NTQ4MDFjMmY3Y2QiLCJrZXlib2FyZFByb3BzIiwiJGU4YTcwMjJjZjg3Y2JhMmEkZXhwb3J0JDM2ZGE5NjM3OWY3OWYyNDUiLCJvbk1vdmVTdGFydCIsIm9uTW92ZSIsIm9uTW92ZUVuZCIsImRpZE1vdmUiLCJsYXN0UG9zaXRpb24iLCJpZCIsInJlbW92ZUdsb2JhbExpc3RlbmVyIiwibW92ZSIsImRlbHRhWCIsImRlbHRhWSIsImVuZCIsIm1vdmVQcm9wcyIsInN0YXJ0Iiwib25Nb3VzZU1vdmUiLCJfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24iLCJfc3RhdGVfY3VycmVudF9sYXN0UG9zaXRpb24xIiwiX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VYIiwiX3N0YXRlX2N1cnJlbnRfbGFzdFBvc2l0aW9uX3BhZ2VZIiwicGFnZVgiLCJwYWdlWSIsImZpbmRJbmRleCIsInRyaWdnZXJLZXlib2FyZE1vdmUiLCIkN2QwYTYzNmQ3YTRkY2VmZCRleHBvcnQkMjEyM2ZmMmI4N2M4MWNhIiwib25TY3JvbGxIYW5kbGVyIiwiJDhhMjY1NjFkMjg3NzIzNmUkdmFyJERFRkFVTFRfVEhSRVNIT0xEIiwiJDhhMjY1NjFkMjg3NzIzNmUkZXhwb3J0JGMyNGVkMDEwNGQwN2VhYjkiLCJvbkxvbmdQcmVzc1N0YXJ0Iiwib25Mb25nUHJlc3NFbmQiLCJvbkxvbmdQcmVzcyIsInRocmVzaG9sZCIsImFjY2Vzc2liaWxpdHlEZXNjcmlwdGlvbiIsInRpbWVSZWYiLCJvbkNvbnRleHRNZW51IiwiY2xlYXJUaW1lb3V0IiwiZGVzY3JpcHRpb25Qcm9wcyIsImxvbmdQcmVzc1Byb3BzIiwiUHJlc3NhYmxlIiwiUHJlc3NSZXNwb25kZXIiLCJDbGVhclByZXNzUmVzcG9uZGVyIiwidXNlRm9jdXMiLCJnZXRJbnRlcmFjdGlvbk1vZGFsaXR5Iiwic2V0SW50ZXJhY3Rpb25Nb2RhbGl0eSIsInVzZUludGVyYWN0aW9uTW9kYWxpdHkiLCJ1c2VGb2N1c1Zpc2libGUiLCJ1c2VGb2N1c1Zpc2libGVMaXN0ZW5lciIsInVzZUZvY3VzV2l0aGluIiwidXNlSG92ZXIiLCJ1c2VJbnRlcmFjdE91dHNpZGUiLCJ1c2VLZXlib2FyZCIsInVzZU1vdmUiLCJ1c2VQcmVzcyIsInVzZVNjcm9sbFdoZWVsIiwidXNlTG9uZ1ByZXNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-aria/interactions/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-aria/label/dist/import.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@react-aria/label/dist/import.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useField: () => (/* binding */ $2baaea4c71418dea$export$294aa081a6c6f55d),\n/* harmony export */   useLabel: () => (/* binding */ $d191a55c9702f145$export$8467354a121f1b9f)\n/* harmony export */ });\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/./node_modules/@react-aria/utils/dist/import.mjs\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $d191a55c9702f145$export$8467354a121f1b9f(props) {\n    let { id: id, label: label, \"aria-labelledby\": ariaLabelledby, \"aria-label\": ariaLabel, labelElementType: labelElementType = \"label\" } = props;\n    id = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_0__.useId)(id);\n    let labelId = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    let labelProps = {};\n    if (label) {\n        ariaLabelledby = ariaLabelledby ? `${labelId} ${ariaLabelledby}` : labelId;\n        labelProps = {\n            id: labelId,\n            htmlFor: labelElementType === \"label\" ? id : undefined\n        };\n    } else if (!ariaLabelledby && !ariaLabel) console.warn(\"If you do not provide a visible label, you must specify an aria-label or aria-labelledby attribute for accessibility\");\n    let fieldProps = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_0__.useLabels)({\n        id: id,\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": ariaLabelledby\n    });\n    return {\n        labelProps: labelProps,\n        fieldProps: fieldProps\n    };\n}\nfunction $2baaea4c71418dea$export$294aa081a6c6f55d(props) {\n    let { description: description, errorMessage: errorMessage, isInvalid: isInvalid, validationState: validationState } = props;\n    let { labelProps: labelProps, fieldProps: fieldProps } = (0, $d191a55c9702f145$export$8467354a121f1b9f)(props);\n    let descriptionId = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_0__.useSlotId)([\n        Boolean(description),\n        Boolean(errorMessage),\n        isInvalid,\n        validationState\n    ]);\n    let errorMessageId = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_0__.useSlotId)([\n        Boolean(description),\n        Boolean(errorMessage),\n        isInvalid,\n        validationState\n    ]);\n    fieldProps = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_0__.mergeProps)(fieldProps, {\n        \"aria-describedby\": [\n            descriptionId,\n            // Use aria-describedby for error message because aria-errormessage is unsupported using VoiceOver or NVDA. See https://github.com/adobe/react-spectrum/issues/1346#issuecomment-740136268\n            errorMessageId,\n            props[\"aria-describedby\"]\n        ].filter(Boolean).join(\" \") || undefined\n    });\n    return {\n        labelProps: labelProps,\n        fieldProps: fieldProps,\n        descriptionProps: {\n            id: descriptionId\n        },\n        errorMessageProps: {\n            id: errorMessageId\n        }\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvbGFiZWwvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF1SjtBQUV2Sjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FDRCxTQUFTUSwwQ0FBMENDLEtBQUs7SUFDcEQsSUFBSSxFQUFFQyxJQUFJQSxFQUFFLEVBQUVDLE9BQU9BLEtBQUssRUFBRSxtQkFBbUJDLGNBQWMsRUFBRSxjQUFjQyxTQUFTLEVBQUVDLGtCQUFrQkEsbUJBQW1CLE9BQU8sRUFBRSxHQUFHTDtJQUN6SUMsS0FBSyxDQUFDLEdBQUdMLG9EQUFXLEVBQUdLO0lBQ3ZCLElBQUlLLFVBQVUsQ0FBQyxHQUFHVixvREFBVztJQUM3QixJQUFJVyxhQUFhLENBQUM7SUFDbEIsSUFBSUwsT0FBTztRQUNQQyxpQkFBaUJBLGlCQUFpQixDQUFDLEVBQUVHLFFBQVEsQ0FBQyxFQUFFSCxlQUFlLENBQUMsR0FBR0c7UUFDbkVDLGFBQWE7WUFDVE4sSUFBSUs7WUFDSkUsU0FBU0gscUJBQXFCLFVBQVVKLEtBQUtRO1FBQ2pEO0lBQ0osT0FBTyxJQUFJLENBQUNOLGtCQUFrQixDQUFDQyxXQUFXTSxRQUFRQyxJQUFJLENBQUM7SUFDdkQsSUFBSUMsYUFBYSxDQUFDLEdBQUdkLHdEQUFlLEVBQUc7UUFDbkNHLElBQUlBO1FBQ0osY0FBY0c7UUFDZCxtQkFBbUJEO0lBQ3ZCO0lBQ0EsT0FBTztRQUNISSxZQUFZQTtRQUNaSyxZQUFZQTtJQUNoQjtBQUNKO0FBSUEsU0FBU0MsMENBQTBDYixLQUFLO0lBQ3BELElBQUksRUFBRWMsYUFBYUEsV0FBVyxFQUFFQyxjQUFjQSxZQUFZLEVBQUVDLFdBQVdBLFNBQVMsRUFBRUMsaUJBQWlCQSxlQUFlLEVBQUUsR0FBR2pCO0lBQ3ZILElBQUksRUFBRU8sWUFBWUEsVUFBVSxFQUFFSyxZQUFZQSxVQUFVLEVBQUUsR0FBRyxDQUFDLEdBQUdiLHlDQUF3QyxFQUFHQztJQUN4RyxJQUFJa0IsZ0JBQWdCLENBQUMsR0FBRzFCLHdEQUFlLEVBQUc7UUFDdEMyQixRQUFRTDtRQUNSSyxRQUFRSjtRQUNSQztRQUNBQztLQUNIO0lBQ0QsSUFBSUcsaUJBQWlCLENBQUMsR0FBRzVCLHdEQUFlLEVBQUc7UUFDdkMyQixRQUFRTDtRQUNSSyxRQUFRSjtRQUNSQztRQUNBQztLQUNIO0lBQ0RMLGFBQWEsQ0FBQyxHQUFHbEIseURBQWdCLEVBQUdrQixZQUFZO1FBQzVDLG9CQUFvQjtZQUNoQk07WUFDQSwwTEFBMEw7WUFDMUxFO1lBQ0FwQixLQUFLLENBQUMsbUJBQW1CO1NBQzVCLENBQUNxQixNQUFNLENBQUNGLFNBQVNHLElBQUksQ0FBQyxRQUFRYjtJQUNuQztJQUNBLE9BQU87UUFDSEYsWUFBWUE7UUFDWkssWUFBWUE7UUFDWlcsa0JBQWtCO1lBQ2R0QixJQUFJaUI7UUFDUjtRQUNBTSxtQkFBbUI7WUFDZnZCLElBQUltQjtRQUNSO0lBQ0o7QUFDSjtBQU1zSCxDQUN0SCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmljZWZldGNoLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL2xhYmVsL2Rpc3QvaW1wb3J0Lm1qcz84NjM0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlU2xvdElkIGFzICRpRDdxMCR1c2VTbG90SWQsIG1lcmdlUHJvcHMgYXMgJGlEN3EwJG1lcmdlUHJvcHMsIHVzZUlkIGFzICRpRDdxMCR1c2VJZCwgdXNlTGFiZWxzIGFzICRpRDdxMCR1c2VMYWJlbHN9IGZyb20gXCJAcmVhY3QtYXJpYS91dGlsc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIxIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICRkMTkxYTU1Yzk3MDJmMTQ1JGV4cG9ydCQ4NDY3MzU0YTEyMWYxYjlmKHByb3BzKSB7XG4gICAgbGV0IHsgaWQ6IGlkLCBsYWJlbDogbGFiZWwsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGFyaWFMYWJlbGxlZGJ5LCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsLCBsYWJlbEVsZW1lbnRUeXBlOiBsYWJlbEVsZW1lbnRUeXBlID0gXCJsYWJlbFwiIH0gPSBwcm9wcztcbiAgICBpZCA9ICgwLCAkaUQ3cTAkdXNlSWQpKGlkKTtcbiAgICBsZXQgbGFiZWxJZCA9ICgwLCAkaUQ3cTAkdXNlSWQpKCk7XG4gICAgbGV0IGxhYmVsUHJvcHMgPSB7fTtcbiAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgYXJpYUxhYmVsbGVkYnkgPSBhcmlhTGFiZWxsZWRieSA/IGAke2xhYmVsSWR9ICR7YXJpYUxhYmVsbGVkYnl9YCA6IGxhYmVsSWQ7XG4gICAgICAgIGxhYmVsUHJvcHMgPSB7XG4gICAgICAgICAgICBpZDogbGFiZWxJZCxcbiAgICAgICAgICAgIGh0bWxGb3I6IGxhYmVsRWxlbWVudFR5cGUgPT09IFwibGFiZWxcIiA/IGlkIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICghYXJpYUxhYmVsbGVkYnkgJiYgIWFyaWFMYWJlbCkgY29uc29sZS53YXJuKFwiSWYgeW91IGRvIG5vdCBwcm92aWRlIGEgdmlzaWJsZSBsYWJlbCwgeW91IG11c3Qgc3BlY2lmeSBhbiBhcmlhLWxhYmVsIG9yIGFyaWEtbGFiZWxsZWRieSBhdHRyaWJ1dGUgZm9yIGFjY2Vzc2liaWxpdHlcIik7XG4gICAgbGV0IGZpZWxkUHJvcHMgPSAoMCwgJGlEN3EwJHVzZUxhYmVscykoe1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwsXG4gICAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGFyaWFMYWJlbGxlZGJ5XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGFiZWxQcm9wczogbGFiZWxQcm9wcyxcbiAgICAgICAgZmllbGRQcm9wczogZmllbGRQcm9wc1xuICAgIH07XG59XG5cblxuXG5mdW5jdGlvbiAkMmJhYWVhNGM3MTQxOGRlYSRleHBvcnQkMjk0YWEwODFhNmM2ZjU1ZChwcm9wcykge1xuICAgIGxldCB7IGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiwgZXJyb3JNZXNzYWdlOiBlcnJvck1lc3NhZ2UsIGlzSW52YWxpZDogaXNJbnZhbGlkLCB2YWxpZGF0aW9uU3RhdGU6IHZhbGlkYXRpb25TdGF0ZSB9ID0gcHJvcHM7XG4gICAgbGV0IHsgbGFiZWxQcm9wczogbGFiZWxQcm9wcywgZmllbGRQcm9wczogZmllbGRQcm9wcyB9ID0gKDAsICRkMTkxYTU1Yzk3MDJmMTQ1JGV4cG9ydCQ4NDY3MzU0YTEyMWYxYjlmKShwcm9wcyk7XG4gICAgbGV0IGRlc2NyaXB0aW9uSWQgPSAoMCwgJGlEN3EwJHVzZVNsb3RJZCkoW1xuICAgICAgICBCb29sZWFuKGRlc2NyaXB0aW9uKSxcbiAgICAgICAgQm9vbGVhbihlcnJvck1lc3NhZ2UpLFxuICAgICAgICBpc0ludmFsaWQsXG4gICAgICAgIHZhbGlkYXRpb25TdGF0ZVxuICAgIF0pO1xuICAgIGxldCBlcnJvck1lc3NhZ2VJZCA9ICgwLCAkaUQ3cTAkdXNlU2xvdElkKShbXG4gICAgICAgIEJvb2xlYW4oZGVzY3JpcHRpb24pLFxuICAgICAgICBCb29sZWFuKGVycm9yTWVzc2FnZSksXG4gICAgICAgIGlzSW52YWxpZCxcbiAgICAgICAgdmFsaWRhdGlvblN0YXRlXG4gICAgXSk7XG4gICAgZmllbGRQcm9wcyA9ICgwLCAkaUQ3cTAkbWVyZ2VQcm9wcykoZmllbGRQcm9wcywge1xuICAgICAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogW1xuICAgICAgICAgICAgZGVzY3JpcHRpb25JZCxcbiAgICAgICAgICAgIC8vIFVzZSBhcmlhLWRlc2NyaWJlZGJ5IGZvciBlcnJvciBtZXNzYWdlIGJlY2F1c2UgYXJpYS1lcnJvcm1lc3NhZ2UgaXMgdW5zdXBwb3J0ZWQgdXNpbmcgVm9pY2VPdmVyIG9yIE5WREEuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYWRvYmUvcmVhY3Qtc3BlY3RydW0vaXNzdWVzLzEzNDYjaXNzdWVjb21tZW50LTc0MDEzNjI2OFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlSWQsXG4gICAgICAgICAgICBwcm9wc1tcImFyaWEtZGVzY3JpYmVkYnlcIl1cbiAgICAgICAgXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIikgfHwgdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGFiZWxQcm9wczogbGFiZWxQcm9wcyxcbiAgICAgICAgZmllbGRQcm9wczogZmllbGRQcm9wcyxcbiAgICAgICAgZGVzY3JpcHRpb25Qcm9wczoge1xuICAgICAgICAgICAgaWQ6IGRlc2NyaXB0aW9uSWRcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3JNZXNzYWdlUHJvcHM6IHtcbiAgICAgICAgICAgIGlkOiBlcnJvck1lc3NhZ2VJZFxuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG5cblxuXG5leHBvcnQgeyQyYmFhZWE0YzcxNDE4ZGVhJGV4cG9ydCQyOTRhYTA4MWE2YzZmNTVkIGFzIHVzZUZpZWxkLCAkZDE5MWE1NWM5NzAyZjE0NSRleHBvcnQkODQ2NzM1NGExMjFmMWI5ZiBhcyB1c2VMYWJlbH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidXNlU2xvdElkIiwiJGlEN3EwJHVzZVNsb3RJZCIsIm1lcmdlUHJvcHMiLCIkaUQ3cTAkbWVyZ2VQcm9wcyIsInVzZUlkIiwiJGlEN3EwJHVzZUlkIiwidXNlTGFiZWxzIiwiJGlEN3EwJHVzZUxhYmVscyIsIiRkMTkxYTU1Yzk3MDJmMTQ1JGV4cG9ydCQ4NDY3MzU0YTEyMWYxYjlmIiwicHJvcHMiLCJpZCIsImxhYmVsIiwiYXJpYUxhYmVsbGVkYnkiLCJhcmlhTGFiZWwiLCJsYWJlbEVsZW1lbnRUeXBlIiwibGFiZWxJZCIsImxhYmVsUHJvcHMiLCJodG1sRm9yIiwidW5kZWZpbmVkIiwiY29uc29sZSIsIndhcm4iLCJmaWVsZFByb3BzIiwiJDJiYWFlYTRjNzE0MThkZWEkZXhwb3J0JDI5NGFhMDgxYTZjNmY1NWQiLCJkZXNjcmlwdGlvbiIsImVycm9yTWVzc2FnZSIsImlzSW52YWxpZCIsInZhbGlkYXRpb25TdGF0ZSIsImRlc2NyaXB0aW9uSWQiLCJCb29sZWFuIiwiZXJyb3JNZXNzYWdlSWQiLCJmaWx0ZXIiLCJqb2luIiwiZGVzY3JpcHRpb25Qcm9wcyIsImVycm9yTWVzc2FnZVByb3BzIiwidXNlRmllbGQiLCJ1c2VMYWJlbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-aria/label/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-aria/ssr/dist/import.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@react-aria/ssr/dist/import.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SSRProvider: () => (/* binding */ $b5e257d569688ac6$export$9f8ac96af4b1b2ae),\n/* harmony export */   useIsSSR: () => (/* binding */ $b5e257d569688ac6$export$535bd6ca7f90a273),\n/* harmony export */   useSSRSafeId: () => (/* binding */ $b5e257d569688ac6$export$619500959fc48b26)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // We must avoid a circular dependency with @react-aria/utils, and this useLayoutEffect is\n// guarded by a check that it only runs on the client side.\n// eslint-disable-next-line rulesdir/useLayoutEffectRule\n// Default context value to use in case there is no SSRProvider. This is fine for\n// client-only apps. In order to support multiple copies of React Aria potentially\n// being on the page at once, the prefix is set to a random number. SSRProvider\n// will reset this to zero for consistency between server and client, so in the\n// SSR case multiple copies of React Aria is not supported.\nconst $b5e257d569688ac6$var$defaultContext = {\n    prefix: String(Math.round(Math.random() * 10000000000)),\n    current: 0\n};\nconst $b5e257d569688ac6$var$SSRContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext($b5e257d569688ac6$var$defaultContext);\nconst $b5e257d569688ac6$var$IsSSRContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext(false);\n// This is only used in React < 18.\nfunction $b5e257d569688ac6$var$LegacySSRProvider(props) {\n    let cur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    let counter = $b5e257d569688ac6$var$useCounter(cur === $b5e257d569688ac6$var$defaultContext);\n    let [isSSR, setIsSSR] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    let value = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            // If this is the first SSRProvider, start with an empty string prefix, otherwise\n            // append and increment the counter.\n            prefix: cur === $b5e257d569688ac6$var$defaultContext ? \"\" : `${cur.prefix}-${counter}`,\n            current: 0\n        }), [\n        cur,\n        counter\n    ]);\n    // If on the client, and the component was initially server rendered,\n    // then schedule a layout effect to update the component after hydration.\n    if (typeof document !== \"undefined\") // because the condition never changes after mounting.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        setIsSSR(false);\n    }, []);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$SSRContext.Provider, {\n        value: value\n    }, /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$IsSSRContext.Provider, {\n        value: isSSR\n    }, props.children));\n}\nlet $b5e257d569688ac6$var$warnedAboutSSRProvider = false;\nfunction $b5e257d569688ac6$export$9f8ac96af4b1b2ae(props) {\n    if (typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useId\"] === \"function\") {\n        if ( true && !$b5e257d569688ac6$var$warnedAboutSSRProvider) {\n            console.warn(\"In React 18, SSRProvider is not necessary and is a noop. You can remove it from your app.\");\n            $b5e257d569688ac6$var$warnedAboutSSRProvider = true;\n        }\n        return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement((0, react__WEBPACK_IMPORTED_MODULE_0__).Fragment, null, props.children);\n    }\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$LegacySSRProvider, props);\n}\nlet $b5e257d569688ac6$var$canUseDOM = Boolean( false && 0);\nlet $b5e257d569688ac6$var$componentIds = new WeakMap();\nfunction $b5e257d569688ac6$var$useCounter(isDisabled = false) {\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    let ref = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // eslint-disable-next-line rulesdir/pure-render\n    if (ref.current === null && !isDisabled) {\n        var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        // In strict mode, React renders components twice, and the ref will be reset to null on the second render.\n        // This means our id counter will be incremented twice instead of once. This is a problem because on the\n        // server, components are only rendered once and so ids generated on the server won't match the client.\n        // In React 18, useId was introduced to solve this, but it is not available in older versions. So to solve this\n        // we need to use some React internals to access the underlying Fiber instance, which is stable between renders.\n        // This is exposed as ReactCurrentOwner in development, which is all we need since StrictMode only runs in development.\n        // To ensure that we only increment the global counter once, we store the starting id for this component in\n        // a weak map associated with the Fiber. On the second render, we reset the global counter to this value.\n        // Since React runs the second render immediately after the first, this is safe.\n        // @ts-ignore\n        let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, react__WEBPACK_IMPORTED_MODULE_0__).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;\n        if (currentOwner) {\n            let prevComponentValue = $b5e257d569688ac6$var$componentIds.get(currentOwner);\n            if (prevComponentValue == null) $b5e257d569688ac6$var$componentIds.set(currentOwner, {\n                id: ctx.current,\n                state: currentOwner.memoizedState\n            });\n            else if (currentOwner.memoizedState !== prevComponentValue.state) {\n                // On the second render, the memoizedState gets reset by React.\n                // Reset the counter, and remove from the weak map so we don't\n                // do this for subsequent useId calls.\n                ctx.current = prevComponentValue.id;\n                $b5e257d569688ac6$var$componentIds.delete(currentOwner);\n            }\n        }\n        // eslint-disable-next-line rulesdir/pure-render\n        ref.current = ++ctx.current;\n    }\n    // eslint-disable-next-line rulesdir/pure-render\n    return ref.current;\n}\nfunction $b5e257d569688ac6$var$useLegacySSRSafeId(defaultId) {\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    // If we are rendering in a non-DOM environment, and there's no SSRProvider,\n    // provide a warning to hint to the developer to add one.\n    if (ctx === $b5e257d569688ac6$var$defaultContext && !$b5e257d569688ac6$var$canUseDOM) console.warn(\"When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.\");\n    let counter = $b5e257d569688ac6$var$useCounter(!!defaultId);\n    let prefix = ctx === $b5e257d569688ac6$var$defaultContext && \"development\" === \"test\" ? 0 : `react-aria${ctx.prefix}`;\n    return defaultId || `${prefix}-${counter}`;\n}\nfunction $b5e257d569688ac6$var$useModernSSRSafeId(defaultId) {\n    // @ts-ignore\n    let id = (0, react__WEBPACK_IMPORTED_MODULE_0__).useId();\n    let [didSSR] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)($b5e257d569688ac6$export$535bd6ca7f90a273());\n    let prefix = didSSR || \"development\" === \"test\" ? \"react-aria\" : `react-aria${$b5e257d569688ac6$var$defaultContext.prefix}`;\n    return defaultId || `${prefix}-${id}`;\n}\nconst $b5e257d569688ac6$export$619500959fc48b26 = typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useId\"] === \"function\" ? $b5e257d569688ac6$var$useModernSSRSafeId : $b5e257d569688ac6$var$useLegacySSRSafeId;\nfunction $b5e257d569688ac6$var$getSnapshot() {\n    return false;\n}\nfunction $b5e257d569688ac6$var$getServerSnapshot() {\n    return true;\n}\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction $b5e257d569688ac6$var$subscribe(onStoreChange) {\n    // noop\n    return ()=>{};\n}\nfunction $b5e257d569688ac6$export$535bd6ca7f90a273() {\n    // In React 18, we can use useSyncExternalStore to detect if we're server rendering or hydrating.\n    if (typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useSyncExternalStore\"] === \"function\") return (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useSyncExternalStore\"]($b5e257d569688ac6$var$subscribe, $b5e257d569688ac6$var$getSnapshot, $b5e257d569688ac6$var$getServerSnapshot);\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$IsSSRContext);\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvc3NyL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdNO0FBRWhNOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQUcsMEZBQTBGO0FBQzlGLDJEQUEyRDtBQUMzRCx3REFBd0Q7QUFFeEQsaUZBQWlGO0FBQ2pGLGtGQUFrRjtBQUNsRiwrRUFBK0U7QUFDL0UsK0VBQStFO0FBQy9FLDJEQUEyRDtBQUMzRCxNQUFNVyx1Q0FBdUM7SUFDekNDLFFBQVFDLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLO0lBQzFDQyxTQUFTO0FBQ2I7QUFDQSxNQUFNQyxtQ0FBaUQsV0FBSCxHQUFJLElBQUdsQixrQ0FBVyxFQUFHbUIsYUFBYSxDQUFDUjtBQUN2RixNQUFNUyxxQ0FBbUQsV0FBSCxHQUFJLElBQUdwQixrQ0FBVyxFQUFHbUIsYUFBYSxDQUFDO0FBQ3pGLG1DQUFtQztBQUNuQyxTQUFTRSx3Q0FBd0NDLEtBQUs7SUFDbEQsSUFBSUMsTUFBTSxDQUFDLEdBQUdyQiw2Q0FBZ0IsRUFBR2dCO0lBQ2pDLElBQUlNLFVBQVVDLGlDQUFpQ0YsUUFBUVo7SUFDdkQsSUFBSSxDQUFDZSxPQUFPQyxTQUFTLEdBQUcsQ0FBQyxHQUFHdkIsMkNBQWMsRUFBRztJQUM3QyxJQUFJd0IsUUFBUSxDQUFDLEdBQUd0QiwwQ0FBYSxFQUFHLElBQUs7WUFDN0IsaUZBQWlGO1lBQ2pGLG9DQUFvQztZQUNwQ00sUUFBUVcsUUFBUVosdUNBQXVDLEtBQUssQ0FBQyxFQUFFWSxJQUFJWCxNQUFNLENBQUMsQ0FBQyxFQUFFWSxRQUFRLENBQUM7WUFDdEZQLFNBQVM7UUFDYixJQUFJO1FBQ0pNO1FBQ0FDO0tBQ0g7SUFDRCxxRUFBcUU7SUFDckUseUVBQXlFO0lBQ3pFLElBQUksT0FBT0ssYUFBYSxhQUd4QixzREFGc0Q7SUFDdEQsc0RBQXNEO0lBQ3JELElBQUdyQixrREFBcUIs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L3Nzci9kaXN0L2ltcG9ydC5tanM/ZmM0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJDczU0p4JHJlYWN0LCB7dXNlQ29udGV4dCBhcyAkNzNTSngkdXNlQ29udGV4dCwgdXNlU3RhdGUgYXMgJDczU0p4JHVzZVN0YXRlLCB1c2VNZW1vIGFzICQ3M1NKeCR1c2VNZW1vLCB1c2VMYXlvdXRFZmZlY3QgYXMgJDczU0p4JHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIGFzICQ3M1NKeCR1c2VSZWZ9IGZyb20gXCJyZWFjdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFdlIG11c3QgYXZvaWQgYSBjaXJjdWxhciBkZXBlbmRlbmN5IHdpdGggQHJlYWN0LWFyaWEvdXRpbHMsIGFuZCB0aGlzIHVzZUxheW91dEVmZmVjdCBpc1xuLy8gZ3VhcmRlZCBieSBhIGNoZWNrIHRoYXQgaXQgb25seSBydW5zIG9uIHRoZSBjbGllbnQgc2lkZS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBydWxlc2Rpci91c2VMYXlvdXRFZmZlY3RSdWxlXG5cbi8vIERlZmF1bHQgY29udGV4dCB2YWx1ZSB0byB1c2UgaW4gY2FzZSB0aGVyZSBpcyBubyBTU1JQcm92aWRlci4gVGhpcyBpcyBmaW5lIGZvclxuLy8gY2xpZW50LW9ubHkgYXBwcy4gSW4gb3JkZXIgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgQXJpYSBwb3RlbnRpYWxseVxuLy8gYmVpbmcgb24gdGhlIHBhZ2UgYXQgb25jZSwgdGhlIHByZWZpeCBpcyBzZXQgdG8gYSByYW5kb20gbnVtYmVyLiBTU1JQcm92aWRlclxuLy8gd2lsbCByZXNldCB0aGlzIHRvIHplcm8gZm9yIGNvbnNpc3RlbmN5IGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQsIHNvIGluIHRoZVxuLy8gU1NSIGNhc2UgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IEFyaWEgaXMgbm90IHN1cHBvcnRlZC5cbmNvbnN0ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCA9IHtcbiAgICBwcmVmaXg6IFN0cmluZyhNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDAwMCkpLFxuICAgIGN1cnJlbnQ6IDBcbn07XG5jb25zdCAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkU1NSQ29udGV4dCA9IC8qI19fUFVSRV9fKi8gKDAsICQ3M1NKeCRyZWFjdCkuY3JlYXRlQ29udGV4dCgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZGVmYXVsdENvbnRleHQpO1xuY29uc3QgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJElzU1NSQ29udGV4dCA9IC8qI19fUFVSRV9fKi8gKDAsICQ3M1NKeCRyZWFjdCkuY3JlYXRlQ29udGV4dChmYWxzZSk7XG4vLyBUaGlzIGlzIG9ubHkgdXNlZCBpbiBSZWFjdCA8IDE4LlxuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJExlZ2FjeVNTUlByb3ZpZGVyKHByb3BzKSB7XG4gICAgbGV0IGN1ciA9ICgwLCAkNzNTSngkdXNlQ29udGV4dCkoJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJFNTUkNvbnRleHQpO1xuICAgIGxldCBjb3VudGVyID0gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUNvdW50ZXIoY3VyID09PSAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZGVmYXVsdENvbnRleHQpO1xuICAgIGxldCBbaXNTU1IsIHNldElzU1NSXSA9ICgwLCAkNzNTSngkdXNlU3RhdGUpKHRydWUpO1xuICAgIGxldCB2YWx1ZSA9ICgwLCAkNzNTSngkdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBTU1JQcm92aWRlciwgc3RhcnQgd2l0aCBhbiBlbXB0eSBzdHJpbmcgcHJlZml4LCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIGFwcGVuZCBhbmQgaW5jcmVtZW50IHRoZSBjb3VudGVyLlxuICAgICAgICAgICAgcHJlZml4OiBjdXIgPT09ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCA/IFwiXCIgOiBgJHtjdXIucHJlZml4fS0ke2NvdW50ZXJ9YCxcbiAgICAgICAgICAgIGN1cnJlbnQ6IDBcbiAgICAgICAgfSksIFtcbiAgICAgICAgY3VyLFxuICAgICAgICBjb3VudGVyXG4gICAgXSk7XG4gICAgLy8gSWYgb24gdGhlIGNsaWVudCwgYW5kIHRoZSBjb21wb25lbnQgd2FzIGluaXRpYWxseSBzZXJ2ZXIgcmVuZGVyZWQsXG4gICAgLy8gdGhlbiBzY2hlZHVsZSBhIGxheW91dCBlZmZlY3QgdG8gdXBkYXRlIHRoZSBjb21wb25lbnQgYWZ0ZXIgaHlkcmF0aW9uLlxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIC8vIFRoaXMgaWYgc3RhdGVtZW50IHRlY2huaWNhbGx5IGJyZWFrcyB0aGUgcnVsZXMgb2YgaG9va3MsIGJ1dCBpcyBzYWZlXG4gICAgLy8gYmVjYXVzZSB0aGUgY29uZGl0aW9uIG5ldmVyIGNoYW5nZXMgYWZ0ZXIgbW91bnRpbmcuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgKDAsICQ3M1NKeCR1c2VMYXlvdXRFZmZlY3QpKCgpPT57XG4gICAgICAgIHNldElzU1NSKGZhbHNlKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsICQ3M1NKeCRyZWFjdCkuY3JlYXRlRWxlbWVudCgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkU1NSQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICB9LCAvKiNfX1BVUkVfXyovICgwLCAkNzNTSngkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJElzU1NSQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogaXNTU1JcbiAgICB9LCBwcm9wcy5jaGlsZHJlbikpO1xufVxubGV0ICRiNWUyNTdkNTY5Njg4YWM2JHZhciR3YXJuZWRBYm91dFNTUlByb3ZpZGVyID0gZmFsc2U7XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkOWY4YWM5NmFmNGIxYjJhZShwcm9wcykge1xuICAgIGlmICh0eXBlb2YgKDAsICQ3M1NKeCRyZWFjdClbXCJ1c2VJZFwiXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJ0ZXN0XCIgJiYgISRiNWUyNTdkNTY5Njg4YWM2JHZhciR3YXJuZWRBYm91dFNTUlByb3ZpZGVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJJbiBSZWFjdCAxOCwgU1NSUHJvdmlkZXIgaXMgbm90IG5lY2Vzc2FyeSBhbmQgaXMgYSBub29wLiBZb3UgY2FuIHJlbW92ZSBpdCBmcm9tIHlvdXIgYXBwLlwiKTtcbiAgICAgICAgICAgICRiNWUyNTdkNTY5Njg4YWM2JHZhciR3YXJuZWRBYm91dFNTUlByb3ZpZGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgJDczU0p4JHJlYWN0KS5jcmVhdGVFbGVtZW50KCgwLCAkNzNTSngkcmVhY3QpLkZyYWdtZW50LCBudWxsLCBwcm9wcy5jaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkNzNTSngkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJExlZ2FjeVNTUlByb3ZpZGVyLCBwcm9wcyk7XG59XG5sZXQgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGNhblVzZURPTSA9IEJvb2xlYW4odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubGV0ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRjb21wb25lbnRJZHMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUNvdW50ZXIoaXNEaXNhYmxlZCA9IGZhbHNlKSB7XG4gICAgbGV0IGN0eCA9ICgwLCAkNzNTSngkdXNlQ29udGV4dCkoJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJFNTUkNvbnRleHQpO1xuICAgIGxldCByZWYgPSAoMCwgJDczU0p4JHVzZVJlZikobnVsbCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJ1bGVzZGlyL3B1cmUtcmVuZGVyXG4gICAgaWYgKHJlZi5jdXJyZW50ID09PSBudWxsICYmICFpc0Rpc2FibGVkKSB7XG4gICAgICAgIHZhciBfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRURfUmVhY3RDdXJyZW50T3duZXIsIF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbiAgICAgICAgLy8gSW4gc3RyaWN0IG1vZGUsIFJlYWN0IHJlbmRlcnMgY29tcG9uZW50cyB0d2ljZSwgYW5kIHRoZSByZWYgd2lsbCBiZSByZXNldCB0byBudWxsIG9uIHRoZSBzZWNvbmQgcmVuZGVyLlxuICAgICAgICAvLyBUaGlzIG1lYW5zIG91ciBpZCBjb3VudGVyIHdpbGwgYmUgaW5jcmVtZW50ZWQgdHdpY2UgaW5zdGVhZCBvZiBvbmNlLiBUaGlzIGlzIGEgcHJvYmxlbSBiZWNhdXNlIG9uIHRoZVxuICAgICAgICAvLyBzZXJ2ZXIsIGNvbXBvbmVudHMgYXJlIG9ubHkgcmVuZGVyZWQgb25jZSBhbmQgc28gaWRzIGdlbmVyYXRlZCBvbiB0aGUgc2VydmVyIHdvbid0IG1hdGNoIHRoZSBjbGllbnQuXG4gICAgICAgIC8vIEluIFJlYWN0IDE4LCB1c2VJZCB3YXMgaW50cm9kdWNlZCB0byBzb2x2ZSB0aGlzLCBidXQgaXQgaXMgbm90IGF2YWlsYWJsZSBpbiBvbGRlciB2ZXJzaW9ucy4gU28gdG8gc29sdmUgdGhpc1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHVzZSBzb21lIFJlYWN0IGludGVybmFscyB0byBhY2Nlc3MgdGhlIHVuZGVybHlpbmcgRmliZXIgaW5zdGFuY2UsIHdoaWNoIGlzIHN0YWJsZSBiZXR3ZWVuIHJlbmRlcnMuXG4gICAgICAgIC8vIFRoaXMgaXMgZXhwb3NlZCBhcyBSZWFjdEN1cnJlbnRPd25lciBpbiBkZXZlbG9wbWVudCwgd2hpY2ggaXMgYWxsIHdlIG5lZWQgc2luY2UgU3RyaWN0TW9kZSBvbmx5IHJ1bnMgaW4gZGV2ZWxvcG1lbnQuXG4gICAgICAgIC8vIFRvIGVuc3VyZSB0aGF0IHdlIG9ubHkgaW5jcmVtZW50IHRoZSBnbG9iYWwgY291bnRlciBvbmNlLCB3ZSBzdG9yZSB0aGUgc3RhcnRpbmcgaWQgZm9yIHRoaXMgY29tcG9uZW50IGluXG4gICAgICAgIC8vIGEgd2VhayBtYXAgYXNzb2NpYXRlZCB3aXRoIHRoZSBGaWJlci4gT24gdGhlIHNlY29uZCByZW5kZXIsIHdlIHJlc2V0IHRoZSBnbG9iYWwgY291bnRlciB0byB0aGlzIHZhbHVlLlxuICAgICAgICAvLyBTaW5jZSBSZWFjdCBydW5zIHRoZSBzZWNvbmQgcmVuZGVyIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBmaXJzdCwgdGhpcyBpcyBzYWZlLlxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCBjdXJyZW50T3duZXIgPSAoX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gKDAsICQ3M1NKeCRyZWFjdCkuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQpID09PSBudWxsIHx8IF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRF9SZWFjdEN1cnJlbnRPd25lciA9IF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lcikgPT09IG51bGwgfHwgX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEX1JlYWN0Q3VycmVudE93bmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRURfUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGN1cnJlbnRPd25lcikge1xuICAgICAgICAgICAgbGV0IHByZXZDb21wb25lbnRWYWx1ZSA9ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRjb21wb25lbnRJZHMuZ2V0KGN1cnJlbnRPd25lcik7XG4gICAgICAgICAgICBpZiAocHJldkNvbXBvbmVudFZhbHVlID09IG51bGwpIC8vIE9uIHRoZSBmaXJzdCByZW5kZXIsIGFuZCBmaXJzdCBjYWxsIHRvIHVzZUlkLCBzdG9yZSB0aGUgaWQgYW5kIHN0YXRlIGluIG91ciB3ZWFrIG1hcC5cbiAgICAgICAgICAgICRiNWUyNTdkNTY5Njg4YWM2JHZhciRjb21wb25lbnRJZHMuc2V0KGN1cnJlbnRPd25lciwge1xuICAgICAgICAgICAgICAgIGlkOiBjdHguY3VycmVudCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogY3VycmVudE93bmVyLm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudE93bmVyLm1lbW9pemVkU3RhdGUgIT09IHByZXZDb21wb25lbnRWYWx1ZS5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIE9uIHRoZSBzZWNvbmQgcmVuZGVyLCB0aGUgbWVtb2l6ZWRTdGF0ZSBnZXRzIHJlc2V0IGJ5IFJlYWN0LlxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBjb3VudGVyLCBhbmQgcmVtb3ZlIGZyb20gdGhlIHdlYWsgbWFwIHNvIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgLy8gZG8gdGhpcyBmb3Igc3Vic2VxdWVudCB1c2VJZCBjYWxscy5cbiAgICAgICAgICAgICAgICBjdHguY3VycmVudCA9IHByZXZDb21wb25lbnRWYWx1ZS5pZDtcbiAgICAgICAgICAgICAgICAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkY29tcG9uZW50SWRzLmRlbGV0ZShjdXJyZW50T3duZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBydWxlc2Rpci9wdXJlLXJlbmRlclxuICAgICAgICByZWYuY3VycmVudCA9ICsrY3R4LmN1cnJlbnQ7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBydWxlc2Rpci9wdXJlLXJlbmRlclxuICAgIHJldHVybiByZWYuY3VycmVudDtcbn1cbmZ1bmN0aW9uICRiNWUyNTdkNTY5Njg4YWM2JHZhciR1c2VMZWdhY3lTU1JTYWZlSWQoZGVmYXVsdElkKSB7XG4gICAgbGV0IGN0eCA9ICgwLCAkNzNTSngkdXNlQ29udGV4dCkoJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJFNTUkNvbnRleHQpO1xuICAgIC8vIElmIHdlIGFyZSByZW5kZXJpbmcgaW4gYSBub24tRE9NIGVudmlyb25tZW50LCBhbmQgdGhlcmUncyBubyBTU1JQcm92aWRlcixcbiAgICAvLyBwcm92aWRlIGEgd2FybmluZyB0byBoaW50IHRvIHRoZSBkZXZlbG9wZXIgdG8gYWRkIG9uZS5cbiAgICBpZiAoY3R4ID09PSAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZGVmYXVsdENvbnRleHQgJiYgISRiNWUyNTdkNTY5Njg4YWM2JHZhciRjYW5Vc2VET00pIGNvbnNvbGUud2FybihcIldoZW4gc2VydmVyIHJlbmRlcmluZywgeW91IG11c3Qgd3JhcCB5b3VyIGFwcGxpY2F0aW9uIGluIGFuIDxTU1JQcm92aWRlcj4gdG8gZW5zdXJlIGNvbnNpc3RlbnQgaWRzIGFyZSBnZW5lcmF0ZWQgYmV0d2VlbiB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIuXCIpO1xuICAgIGxldCBjb3VudGVyID0gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUNvdW50ZXIoISFkZWZhdWx0SWQpO1xuICAgIGxldCBwcmVmaXggPSBjdHggPT09ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIgPyBcInJlYWN0LWFyaWFcIiA6IGByZWFjdC1hcmlhJHtjdHgucHJlZml4fWA7XG4gICAgcmV0dXJuIGRlZmF1bHRJZCB8fCBgJHtwcmVmaXh9LSR7Y291bnRlcn1gO1xufVxuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZU1vZGVyblNTUlNhZmVJZChkZWZhdWx0SWQpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbGV0IGlkID0gKDAsICQ3M1NKeCRyZWFjdCkudXNlSWQoKTtcbiAgICBsZXQgW2RpZFNTUl0gPSAoMCwgJDczU0p4JHVzZVN0YXRlKSgkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNTM1YmQ2Y2E3ZjkwYTI3MygpKTtcbiAgICBsZXQgcHJlZml4ID0gZGlkU1NSIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IFwicmVhY3QtYXJpYVwiIDogYHJlYWN0LWFyaWEkeyRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dC5wcmVmaXh9YDtcbiAgICByZXR1cm4gZGVmYXVsdElkIHx8IGAke3ByZWZpeH0tJHtpZH1gO1xufVxuY29uc3QgJGI1ZTI1N2Q1Njk2ODhhYzYkZXhwb3J0JDYxOTUwMDk1OWZjNDhiMjYgPSB0eXBlb2YgKDAsICQ3M1NKeCRyZWFjdClbXCJ1c2VJZFwiXSA9PT0gXCJmdW5jdGlvblwiID8gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZU1vZGVyblNTUlNhZmVJZCA6ICRiNWUyNTdkNTY5Njg4YWM2JHZhciR1c2VMZWdhY3lTU1JTYWZlSWQ7XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZ2V0U25hcHNob3QoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGdldFNlcnZlclNuYXBzaG90KCkge1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHN1YnNjcmliZShvblN0b3JlQ2hhbmdlKSB7XG4gICAgLy8gbm9vcFxuICAgIHJldHVybiAoKT0+e307XG59XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNTM1YmQ2Y2E3ZjkwYTI3MygpIHtcbiAgICAvLyBJbiBSZWFjdCAxOCwgd2UgY2FuIHVzZSB1c2VTeW5jRXh0ZXJuYWxTdG9yZSB0byBkZXRlY3QgaWYgd2UncmUgc2VydmVyIHJlbmRlcmluZyBvciBoeWRyYXRpbmcuXG4gICAgaWYgKHR5cGVvZiAoMCwgJDczU0p4JHJlYWN0KVtcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCJdID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiAoMCwgJDczU0p4JHJlYWN0KVtcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCJdKCRiNWUyNTdkNTY5Njg4YWM2JHZhciRzdWJzY3JpYmUsICRiNWUyNTdkNTY5Njg4YWM2JHZhciRnZXRTbmFwc2hvdCwgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGdldFNlcnZlclNuYXBzaG90KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICByZXR1cm4gKDAsICQ3M1NKeCR1c2VDb250ZXh0KSgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkSXNTU1JDb250ZXh0KTtcbn1cblxuXG5cblxuZXhwb3J0IHskYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkOWY4YWM5NmFmNGIxYjJhZSBhcyBTU1JQcm92aWRlciwgJGI1ZTI1N2Q1Njk2ODhhYzYkZXhwb3J0JDYxOTUwMDk1OWZjNDhiMjYgYXMgdXNlU1NSU2FmZUlkLCAkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNTM1YmQ2Y2E3ZjkwYTI3MyBhcyB1c2VJc1NTUn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsiJDczU0p4JHJlYWN0IiwidXNlQ29udGV4dCIsIiQ3M1NKeCR1c2VDb250ZXh0IiwidXNlU3RhdGUiLCIkNzNTSngkdXNlU3RhdGUiLCJ1c2VNZW1vIiwiJDczU0p4JHVzZU1lbW8iLCJ1c2VMYXlvdXRFZmZlY3QiLCIkNzNTSngkdXNlTGF5b3V0RWZmZWN0IiwidXNlUmVmIiwiJDczU0p4JHVzZVJlZiIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCIsInByZWZpeCIsIlN0cmluZyIsIk1hdGgiLCJyb3VuZCIsInJhbmRvbSIsImN1cnJlbnQiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkU1NSQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkSXNTU1JDb250ZXh0IiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJExlZ2FjeVNTUlByb3ZpZGVyIiwicHJvcHMiLCJjdXIiLCJjb3VudGVyIiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUNvdW50ZXIiLCJpc1NTUiIsInNldElzU1NSIiwidmFsdWUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsImNoaWxkcmVuIiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHdhcm5lZEFib3V0U1NSUHJvdmlkZXIiLCIkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkOWY4YWM5NmFmNGIxYjJhZSIsInByb2Nlc3MiLCJjb25zb2xlIiwid2FybiIsIkZyYWdtZW50IiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGNhblVzZURPTSIsIkJvb2xlYW4iLCJ3aW5kb3ciLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkY29tcG9uZW50SWRzIiwiV2Vha01hcCIsImlzRGlzYWJsZWQiLCJjdHgiLCJyZWYiLCJfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRURfUmVhY3RDdXJyZW50T3duZXIiLCJfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJjdXJyZW50T3duZXIiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIlJlYWN0Q3VycmVudE93bmVyIiwicHJldkNvbXBvbmVudFZhbHVlIiwiZ2V0Iiwic2V0IiwiaWQiLCJzdGF0ZSIsIm1lbW9pemVkU3RhdGUiLCJkZWxldGUiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlTGVnYWN5U1NSU2FmZUlkIiwiZGVmYXVsdElkIiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZU1vZGVyblNTUlNhZmVJZCIsInVzZUlkIiwiZGlkU1NSIiwiJGI1ZTI1N2Q1Njk2ODhhYzYkZXhwb3J0JDUzNWJkNmNhN2Y5MGEyNzMiLCIkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNjE5NTAwOTU5ZmM0OGIyNiIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRnZXRTbmFwc2hvdCIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRnZXRTZXJ2ZXJTbmFwc2hvdCIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRzdWJzY3JpYmUiLCJvblN0b3JlQ2hhbmdlIiwiU1NSUHJvdmlkZXIiLCJ1c2VTU1JTYWZlSWQiLCJ1c2VJc1NTUiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-aria/ssr/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-aria/textfield/dist/import.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@react-aria/textfield/dist/import.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFormattedTextField: () => (/* binding */ $d841c8010a73d545$export$4f384c9210e583c3),\n/* harmony export */   useTextField: () => (/* binding */ $2d73ec29415bd339$export$712718f7aec83d5)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/./node_modules/@react-aria/utils/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var _react_aria_label__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-aria/label */ \"(ssr)/./node_modules/@react-aria/label/dist/import.mjs\");\n/* harmony import */ var _react_aria_focus__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/focus */ \"(ssr)/./node_modules/@react-aria/focus/dist/import.mjs\");\n/* harmony import */ var _react_aria_form__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @react-aria/form */ \"(ssr)/./node_modules/@react-aria/form/dist/import.mjs\");\n/* harmony import */ var _react_stately_form__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/form */ \"(ssr)/./node_modules/@react-stately/form/dist/import.mjs\");\n\n\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $2d73ec29415bd339$export$712718f7aec83d5(props, ref) {\n    let { inputElementType: inputElementType = \"input\", isDisabled: isDisabled = false, isRequired: isRequired = false, isReadOnly: isReadOnly = false, type: type = \"text\", validationBehavior: validationBehavior = \"aria\" } = props;\n    let [value, setValue] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(props.value, props.defaultValue || \"\", props.onChange);\n    let { focusableProps: focusableProps } = (0, _react_aria_focus__WEBPACK_IMPORTED_MODULE_2__.useFocusable)(props, ref);\n    let validationState = (0, _react_stately_form__WEBPACK_IMPORTED_MODULE_3__.useFormValidationState)({\n        ...props,\n        value: value\n    });\n    let { isInvalid: isInvalid, validationErrors: validationErrors, validationDetails: validationDetails } = validationState.displayValidation;\n    let { labelProps: labelProps, fieldProps: fieldProps, descriptionProps: descriptionProps, errorMessageProps: errorMessageProps } = (0, _react_aria_label__WEBPACK_IMPORTED_MODULE_4__.useField)({\n        ...props,\n        isInvalid: isInvalid,\n        errorMessage: props.errorMessage || validationErrors\n    });\n    let domProps = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_5__.filterDOMProps)(props, {\n        labelable: true\n    });\n    const inputOnlyProps = {\n        type: type,\n        pattern: props.pattern\n    };\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_5__.useFormReset)(ref, value, setValue);\n    (0, _react_aria_form__WEBPACK_IMPORTED_MODULE_6__.useFormValidation)(props, validationState, ref);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // This works around a React/Chrome bug that prevents textarea elements from validating when controlled.\n        // We prevent React from updating defaultValue (i.e. children) of textarea when `value` changes,\n        // which causes Chrome to skip validation. Only updating `value` is ok in our case since our\n        // textareas are always controlled. React is planning on removing this synchronization in a\n        // future major version.\n        // https://github.com/facebook/react/issues/19474\n        // https://github.com/facebook/react/issues/11896\n        if (ref.current instanceof (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_5__.getOwnerWindow)(ref.current).HTMLTextAreaElement) {\n            let input = ref.current;\n            Object.defineProperty(input, \"defaultValue\", {\n                get: ()=>input.value,\n                set: ()=>{},\n                configurable: true\n            });\n        }\n    }, [\n        ref\n    ]);\n    return {\n        labelProps: labelProps,\n        inputProps: (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_5__.mergeProps)(domProps, inputElementType === \"input\" && inputOnlyProps, {\n            disabled: isDisabled,\n            readOnly: isReadOnly,\n            required: isRequired && validationBehavior === \"native\",\n            \"aria-required\": isRequired && validationBehavior === \"aria\" || undefined,\n            \"aria-invalid\": isInvalid || undefined,\n            \"aria-errormessage\": props[\"aria-errormessage\"],\n            \"aria-activedescendant\": props[\"aria-activedescendant\"],\n            \"aria-autocomplete\": props[\"aria-autocomplete\"],\n            \"aria-haspopup\": props[\"aria-haspopup\"],\n            value: value,\n            onChange: (e)=>setValue(e.target.value),\n            autoComplete: props.autoComplete,\n            maxLength: props.maxLength,\n            minLength: props.minLength,\n            name: props.name,\n            placeholder: props.placeholder,\n            inputMode: props.inputMode,\n            // Clipboard events\n            onCopy: props.onCopy,\n            onCut: props.onCut,\n            onPaste: props.onPaste,\n            // Composition events\n            onCompositionEnd: props.onCompositionEnd,\n            onCompositionStart: props.onCompositionStart,\n            onCompositionUpdate: props.onCompositionUpdate,\n            // Selection events\n            onSelect: props.onSelect,\n            // Input events\n            onBeforeInput: props.onBeforeInput,\n            onInput: props.onInput,\n            ...focusableProps,\n            ...fieldProps\n        }),\n        descriptionProps: descriptionProps,\n        errorMessageProps: errorMessageProps,\n        isInvalid: isInvalid,\n        validationErrors: validationErrors,\n        validationDetails: validationDetails\n    };\n}\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $d841c8010a73d545$var$supportsNativeBeforeInputEvent() {\n    return  false && // @ts-ignore\n    0;\n}\nfunction $d841c8010a73d545$export$4f384c9210e583c3(props, state, inputRef) {\n    // All browsers implement the 'beforeinput' event natively except Firefox\n    // (currently behind a flag as of Firefox 84). React's polyfill does not\n    // run in all cases that the native event fires, e.g. when deleting text.\n    // Use the native event if available so that we can prevent invalid deletions.\n    // We do not attempt to polyfill this in Firefox since it would be very complicated,\n    // the benefit of doing so is fairly minor, and it's going to be natively supported soon.\n    let onBeforeInputFallback = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_5__.useEffectEvent)((e)=>{\n        let input = inputRef.current;\n        // Compute the next value of the input if the event is allowed to proceed.\n        // See https://www.w3.org/TR/input-events-2/#interface-InputEvent-Attributes for a full list of input types.\n        let nextValue;\n        switch(e.inputType){\n            case \"historyUndo\":\n            case \"historyRedo\":\n                // Explicitly allow undo/redo. e.data is null in this case, but there's no need to validate,\n                // because presumably the input would have already been validated previously.\n                return;\n            case \"deleteContent\":\n            case \"deleteByCut\":\n            case \"deleteByDrag\":\n                nextValue = input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n                break;\n            case \"deleteContentForward\":\n                // This is potentially incorrect, since the browser may actually delete more than a single UTF-16\n                // character. In reality, a full Unicode grapheme cluster consisting of multiple UTF-16 characters\n                // or code points may be deleted. However, in our currently supported locales, there are no such cases.\n                // If we support additional locales in the future, this may need to change.\n                nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd + 1) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n                break;\n            case \"deleteContentBackward\":\n                nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart - 1) + input.value.slice(input.selectionStart) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n                break;\n            case \"deleteSoftLineBackward\":\n            case \"deleteHardLineBackward\":\n                nextValue = input.value.slice(input.selectionStart);\n                break;\n            default:\n                if (e.data != null) nextValue = input.value.slice(0, input.selectionStart) + e.data + input.value.slice(input.selectionEnd);\n                break;\n        }\n        // If we did not compute a value, or the new value is invalid, prevent the event\n        // so that the browser does not update the input text, move the selection, or add to\n        // the undo/redo stack.\n        if (nextValue == null || !state.validate(nextValue)) e.preventDefault();\n    });\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!$d841c8010a73d545$var$supportsNativeBeforeInputEvent()) return;\n        let input = inputRef.current;\n        input.addEventListener(\"beforeinput\", onBeforeInputFallback, false);\n        return ()=>{\n            input.removeEventListener(\"beforeinput\", onBeforeInputFallback, false);\n        };\n    }, [\n        inputRef,\n        onBeforeInputFallback\n    ]);\n    let onBeforeInput = !$d841c8010a73d545$var$supportsNativeBeforeInputEvent() ? (e)=>{\n        let nextValue = e.target.value.slice(0, e.target.selectionStart) + e.data + e.target.value.slice(e.target.selectionEnd);\n        if (!state.validate(nextValue)) e.preventDefault();\n    } : null;\n    let { labelProps: labelProps, inputProps: textFieldProps, descriptionProps: descriptionProps, errorMessageProps: errorMessageProps, ...validation } = (0, $2d73ec29415bd339$export$712718f7aec83d5)(props, inputRef);\n    let compositionStartState = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    return {\n        inputProps: (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_5__.mergeProps)(textFieldProps, {\n            onBeforeInput: onBeforeInput,\n            onCompositionStart () {\n                // Chrome does not implement Input Events Level 2, which specifies the insertFromComposition\n                // and deleteByComposition inputType values for the beforeinput event. These are meant to occur\n                // at the end of a composition (e.g. Pinyin IME, Android auto correct, etc.), and crucially, are\n                // cancelable. The insertCompositionText and deleteCompositionText input types are not cancelable,\n                // nor would we want to cancel them because the input from the user is incomplete at that point.\n                // In Safari, insertFromComposition/deleteFromComposition will fire, however, allowing us to cancel\n                // the final composition result if it is invalid. As a fallback for Chrome and Firefox, which either\n                // don't support Input Events Level 2, or beforeinput at all, we store the state of the input when\n                // the compositionstart event fires, and undo the changes in compositionend (below) if it is invalid.\n                // Unfortunately, this messes up the undo/redo stack, but until insertFromComposition/deleteByComposition\n                // are implemented, there is no other way to prevent composed input.\n                // See https://bugs.chromium.org/p/chromium/issues/detail?id=1022204\n                let { value: value, selectionStart: selectionStart, selectionEnd: selectionEnd } = inputRef.current;\n                compositionStartState.current = {\n                    value: value,\n                    selectionStart: selectionStart,\n                    selectionEnd: selectionEnd\n                };\n            },\n            onCompositionEnd () {\n                if (!state.validate(inputRef.current.value)) {\n                    // Restore the input value in the DOM immediately so we can synchronously update the selection position.\n                    // But also update the value in React state as well so it is correct for future updates.\n                    let { value: value, selectionStart: selectionStart, selectionEnd: selectionEnd } = compositionStartState.current;\n                    inputRef.current.value = value;\n                    inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n                    state.setInputValue(value);\n                }\n            }\n        }),\n        labelProps: labelProps,\n        descriptionProps: descriptionProps,\n        errorMessageProps: errorMessageProps,\n        ...validation\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdGV4dGZpZWxkL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBNkU7QUFDcUo7QUFDN0k7QUFDdkI7QUFDUTtBQUNTO0FBQ2E7QUFFNUY7Ozs7Ozs7Ozs7Q0FVQyxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FPRCxTQUFTd0IseUNBQXlDQyxLQUFLLEVBQUVDLEdBQUc7SUFDeEQsSUFBSSxFQUFFQyxrQkFBa0JBLG1CQUFtQixPQUFPLEVBQUVDLFlBQVlBLGFBQWEsS0FBSyxFQUFFQyxZQUFZQSxhQUFhLEtBQUssRUFBRUMsWUFBWUEsYUFBYSxLQUFLLEVBQUVDLE1BQU1BLE9BQU8sTUFBTSxFQUFFQyxvQkFBb0JBLHFCQUFxQixNQUFNLEVBQUUsR0FBR1A7SUFDN04sSUFBSSxDQUFDUSxPQUFPQyxTQUFTLEdBQUcsQ0FBQyxHQUFHbkIsb0VBQXdCLEVBQUdVLE1BQU1RLEtBQUssRUFBRVIsTUFBTVUsWUFBWSxJQUFJLElBQUlWLE1BQU1XLFFBQVE7SUFDNUcsSUFBSSxFQUFFQyxnQkFBZ0JBLGNBQWMsRUFBRSxHQUFHLENBQUMsR0FBR2xCLDJEQUFrQixFQUFHTSxPQUFPQztJQUN6RSxJQUFJWSxrQkFBa0IsQ0FBQyxHQUFHZix1RUFBNEIsRUFBRztRQUNyRCxHQUFHRSxLQUFLO1FBQ1JRLE9BQU9BO0lBQ1g7SUFDQSxJQUFJLEVBQUVNLFdBQVdBLFNBQVMsRUFBRUMsa0JBQWtCQSxnQkFBZ0IsRUFBRUMsbUJBQW1CQSxpQkFBaUIsRUFBRSxHQUFHSCxnQkFBZ0JJLGlCQUFpQjtJQUMxSSxJQUFJLEVBQUVDLFlBQVlBLFVBQVUsRUFBRUMsWUFBWUEsVUFBVSxFQUFFQyxrQkFBa0JBLGdCQUFnQixFQUFFQyxtQkFBbUJBLGlCQUFpQixFQUFFLEdBQUcsQ0FBQyxHQUFHN0IsdURBQWMsRUFBRztRQUNwSixHQUFHUSxLQUFLO1FBQ1JjLFdBQVdBO1FBQ1hRLGNBQWN0QixNQUFNc0IsWUFBWSxJQUFJUDtJQUN4QztJQUNBLElBQUlRLFdBQVcsQ0FBQyxHQUFHM0MsNkRBQW9CLEVBQUdvQixPQUFPO1FBQzdDd0IsV0FBVztJQUNmO0lBQ0EsTUFBTUMsaUJBQWlCO1FBQ25CbkIsTUFBTUE7UUFDTm9CLFNBQVMxQixNQUFNMEIsT0FBTztJQUMxQjtJQUNDLElBQUc1QywyREFBa0IsRUFBR21CLEtBQUtPLE9BQU9DO0lBQ3BDLElBQUdiLCtEQUF1QixFQUFHSSxPQUFPYSxpQkFBaUJaO0lBQ3JELElBQUd6Qiw0Q0FBZSxFQUFHO1FBQ2xCLHdHQUF3RztRQUN4RyxnR0FBZ0c7UUFDaEcsNEZBQTRGO1FBQzVGLDJGQUEyRjtRQUMzRix3QkFBd0I7UUFDeEIsaURBQWlEO1FBQ2pELGlEQUFpRDtRQUNqRCxJQUFJeUIsSUFBSTBCLE9BQU8sWUFBWSxDQUFDLEdBQUczQyw2REFBb0IsRUFBR2lCLElBQUkwQixPQUFPLEVBQUVDLG1CQUFtQixFQUFFO1lBQ3BGLElBQUlDLFFBQVE1QixJQUFJMEIsT0FBTztZQUN2QkcsT0FBT0MsY0FBYyxDQUFDRixPQUFPLGdCQUFnQjtnQkFDekNHLEtBQUssSUFBSUgsTUFBTXJCLEtBQUs7Z0JBQ3BCeUIsS0FBSyxLQUFLO2dCQUNWQyxjQUFjO1lBQ2xCO1FBQ0o7SUFDSixHQUFHO1FBQ0NqQztLQUNIO0lBQ0QsT0FBTztRQUNIaUIsWUFBWUE7UUFDWmlCLFlBQVksQ0FBQyxHQUFHakQseURBQWdCLEVBQUdxQyxVQUFVckIscUJBQXFCLFdBQVd1QixnQkFBZ0I7WUFDekZXLFVBQVVqQztZQUNWa0MsVUFBVWhDO1lBQ1ZpQyxVQUFVbEMsY0FBY0csdUJBQXVCO1lBQy9DLGlCQUFpQkgsY0FBY0csdUJBQXVCLFVBQVVnQztZQUNoRSxnQkFBZ0J6QixhQUFheUI7WUFDN0IscUJBQXFCdkMsS0FBSyxDQUFDLG9CQUFvQjtZQUMvQyx5QkFBeUJBLEtBQUssQ0FBQyx3QkFBd0I7WUFDdkQscUJBQXFCQSxLQUFLLENBQUMsb0JBQW9CO1lBQy9DLGlCQUFpQkEsS0FBSyxDQUFDLGdCQUFnQjtZQUN2Q1EsT0FBT0E7WUFDUEcsVUFBVSxDQUFDNkIsSUFBSS9CLFNBQVMrQixFQUFFQyxNQUFNLENBQUNqQyxLQUFLO1lBQ3RDa0MsY0FBYzFDLE1BQU0wQyxZQUFZO1lBQ2hDQyxXQUFXM0MsTUFBTTJDLFNBQVM7WUFDMUJDLFdBQVc1QyxNQUFNNEMsU0FBUztZQUMxQkMsTUFBTTdDLE1BQU02QyxJQUFJO1lBQ2hCQyxhQUFhOUMsTUFBTThDLFdBQVc7WUFDOUJDLFdBQVcvQyxNQUFNK0MsU0FBUztZQUMxQixtQkFBbUI7WUFDbkJDLFFBQVFoRCxNQUFNZ0QsTUFBTTtZQUNwQkMsT0FBT2pELE1BQU1pRCxLQUFLO1lBQ2xCQyxTQUFTbEQsTUFBTWtELE9BQU87WUFDdEIscUJBQXFCO1lBQ3JCQyxrQkFBa0JuRCxNQUFNbUQsZ0JBQWdCO1lBQ3hDQyxvQkFBb0JwRCxNQUFNb0Qsa0JBQWtCO1lBQzVDQyxxQkFBcUJyRCxNQUFNcUQsbUJBQW1CO1lBQzlDLG1CQUFtQjtZQUNuQkMsVUFBVXRELE1BQU1zRCxRQUFRO1lBQ3hCLGVBQWU7WUFDZkMsZUFBZXZELE1BQU11RCxhQUFhO1lBQ2xDQyxTQUFTeEQsTUFBTXdELE9BQU87WUFDdEIsR0FBRzVDLGNBQWM7WUFDakIsR0FBR08sVUFBVTtRQUNqQjtRQUNBQyxrQkFBa0JBO1FBQ2xCQyxtQkFBbUJBO1FBQ25CUCxXQUFXQTtRQUNYQyxrQkFBa0JBO1FBQ2xCQyxtQkFBbUJBO0lBQ3ZCO0FBQ0o7QUFHQTs7Ozs7Ozs7OztDQVVDLEdBR0QsU0FBU3lDO0lBQ0wsT0FBTyxNQUFrRCxJQUFJLGFBQWE7SUFDMUUsQ0FBMEQ7QUFDOUQ7QUFDQSxTQUFTSywwQ0FBMEM5RCxLQUFLLEVBQUUrRCxLQUFLLEVBQUVDLFFBQVE7SUFDckUseUVBQXlFO0lBQ3pFLHdFQUF3RTtJQUN4RSx5RUFBeUU7SUFDekUsOEVBQThFO0lBQzlFLG9GQUFvRjtJQUNwRix5RkFBeUY7SUFDekYsSUFBSUMsd0JBQXdCLENBQUMsR0FBRzdFLDZEQUFvQixFQUFHLENBQUNvRDtRQUNwRCxJQUFJWCxRQUFRbUMsU0FBU3JDLE9BQU87UUFDNUIsMEVBQTBFO1FBQzFFLDRHQUE0RztRQUM1RyxJQUFJdUM7UUFDSixPQUFPMUIsRUFBRTJCLFNBQVM7WUFDZCxLQUFLO1lBQ0wsS0FBSztnQkFDRCw0RkFBNEY7Z0JBQzVGLDZFQUE2RTtnQkFDN0U7WUFDSixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0RELFlBQVlyQyxNQUFNckIsS0FBSyxDQUFDNEQsS0FBSyxDQUFDLEdBQUd2QyxNQUFNd0MsY0FBYyxJQUFJeEMsTUFBTXJCLEtBQUssQ0FBQzRELEtBQUssQ0FBQ3ZDLE1BQU15QyxZQUFZO2dCQUM3RjtZQUNKLEtBQUs7Z0JBQ0QsaUdBQWlHO2dCQUNqRyxrR0FBa0c7Z0JBQ2xHLHVHQUF1RztnQkFDdkcsMkVBQTJFO2dCQUMzRUosWUFBWXJDLE1BQU15QyxZQUFZLEtBQUt6QyxNQUFNd0MsY0FBYyxHQUFHeEMsTUFBTXJCLEtBQUssQ0FBQzRELEtBQUssQ0FBQyxHQUFHdkMsTUFBTXdDLGNBQWMsSUFBSXhDLE1BQU1yQixLQUFLLENBQUM0RCxLQUFLLENBQUN2QyxNQUFNeUMsWUFBWSxHQUFHLEtBQUt6QyxNQUFNckIsS0FBSyxDQUFDNEQsS0FBSyxDQUFDLEdBQUd2QyxNQUFNd0MsY0FBYyxJQUFJeEMsTUFBTXJCLEtBQUssQ0FBQzRELEtBQUssQ0FBQ3ZDLE1BQU15QyxZQUFZO2dCQUNwTztZQUNKLEtBQUs7Z0JBQ0RKLFlBQVlyQyxNQUFNeUMsWUFBWSxLQUFLekMsTUFBTXdDLGNBQWMsR0FBR3hDLE1BQU1yQixLQUFLLENBQUM0RCxLQUFLLENBQUMsR0FBR3ZDLE1BQU13QyxjQUFjLEdBQUcsS0FBS3hDLE1BQU1yQixLQUFLLENBQUM0RCxLQUFLLENBQUN2QyxNQUFNd0MsY0FBYyxJQUFJeEMsTUFBTXJCLEtBQUssQ0FBQzRELEtBQUssQ0FBQyxHQUFHdkMsTUFBTXdDLGNBQWMsSUFBSXhDLE1BQU1yQixLQUFLLENBQUM0RCxLQUFLLENBQUN2QyxNQUFNeUMsWUFBWTtnQkFDdE87WUFDSixLQUFLO1lBQ0wsS0FBSztnQkFDREosWUFBWXJDLE1BQU1yQixLQUFLLENBQUM0RCxLQUFLLENBQUN2QyxNQUFNd0MsY0FBYztnQkFDbEQ7WUFDSjtnQkFDSSxJQUFJN0IsRUFBRStCLElBQUksSUFBSSxNQUFNTCxZQUFZckMsTUFBTXJCLEtBQUssQ0FBQzRELEtBQUssQ0FBQyxHQUFHdkMsTUFBTXdDLGNBQWMsSUFBSTdCLEVBQUUrQixJQUFJLEdBQUcxQyxNQUFNckIsS0FBSyxDQUFDNEQsS0FBSyxDQUFDdkMsTUFBTXlDLFlBQVk7Z0JBQzFIO1FBQ1I7UUFDQSxnRkFBZ0Y7UUFDaEYsb0ZBQW9GO1FBQ3BGLHVCQUF1QjtRQUN2QixJQUFJSixhQUFhLFFBQVEsQ0FBQ0gsTUFBTVMsUUFBUSxDQUFDTixZQUFZMUIsRUFBRWlDLGNBQWM7SUFDekU7SUFDQyxJQUFHakcsNENBQWUsRUFBRztRQUNsQixJQUFJLENBQUNpRix3REFBd0Q7UUFDN0QsSUFBSTVCLFFBQVFtQyxTQUFTckMsT0FBTztRQUM1QkUsTUFBTTZDLGdCQUFnQixDQUFDLGVBQWVULHVCQUF1QjtRQUM3RCxPQUFPO1lBQ0hwQyxNQUFNOEMsbUJBQW1CLENBQUMsZUFBZVYsdUJBQXVCO1FBQ3BFO0lBQ0osR0FBRztRQUNDRDtRQUNBQztLQUNIO0lBQ0QsSUFBSVYsZ0JBQWdCLENBQUNFLHlEQUF5RCxDQUFDakI7UUFDM0UsSUFBSTBCLFlBQVkxQixFQUFFQyxNQUFNLENBQUNqQyxLQUFLLENBQUM0RCxLQUFLLENBQUMsR0FBRzVCLEVBQUVDLE1BQU0sQ0FBQzRCLGNBQWMsSUFBSTdCLEVBQUUrQixJQUFJLEdBQUcvQixFQUFFQyxNQUFNLENBQUNqQyxLQUFLLENBQUM0RCxLQUFLLENBQUM1QixFQUFFQyxNQUFNLENBQUM2QixZQUFZO1FBQ3RILElBQUksQ0FBQ1AsTUFBTVMsUUFBUSxDQUFDTixZQUFZMUIsRUFBRWlDLGNBQWM7SUFDcEQsSUFBSTtJQUNKLElBQUksRUFBRXZELFlBQVlBLFVBQVUsRUFBRWlCLFlBQVl5QyxjQUFjLEVBQUV4RCxrQkFBa0JBLGdCQUFnQixFQUFFQyxtQkFBbUJBLGlCQUFpQixFQUFFLEdBQUd3RCxZQUFZLEdBQUcsQ0FBQyxHQUFHOUUsd0NBQXVDLEVBQUdDLE9BQU9nRTtJQUMzTSxJQUFJYyx3QkFBd0IsQ0FBQyxHQUFHcEcseUNBQVksRUFBRztJQUMvQyxPQUFPO1FBQ0h5RCxZQUFZLENBQUMsR0FBR2pELHlEQUFnQixFQUFHMEYsZ0JBQWdCO1lBQy9DckIsZUFBZUE7WUFDZkg7Z0JBQ0ksNEZBQTRGO2dCQUM1RiwrRkFBK0Y7Z0JBQy9GLGdHQUFnRztnQkFDaEcsa0dBQWtHO2dCQUNsRyxnR0FBZ0c7Z0JBQ2hHLG1HQUFtRztnQkFDbkcsb0dBQW9HO2dCQUNwRyxrR0FBa0c7Z0JBQ2xHLHFHQUFxRztnQkFDckcseUdBQXlHO2dCQUN6RyxvRUFBb0U7Z0JBQ3BFLG9FQUFvRTtnQkFDcEUsSUFBSSxFQUFFNUMsT0FBT0EsS0FBSyxFQUFFNkQsZ0JBQWdCQSxjQUFjLEVBQUVDLGNBQWNBLFlBQVksRUFBRSxHQUFHTixTQUFTckMsT0FBTztnQkFDbkdtRCxzQkFBc0JuRCxPQUFPLEdBQUc7b0JBQzVCbkIsT0FBT0E7b0JBQ1A2RCxnQkFBZ0JBO29CQUNoQkMsY0FBY0E7Z0JBQ2xCO1lBQ0o7WUFDQW5CO2dCQUNJLElBQUksQ0FBQ1ksTUFBTVMsUUFBUSxDQUFDUixTQUFTckMsT0FBTyxDQUFDbkIsS0FBSyxHQUFHO29CQUN6Qyx3R0FBd0c7b0JBQ3hHLHdGQUF3RjtvQkFDeEYsSUFBSSxFQUFFQSxPQUFPQSxLQUFLLEVBQUU2RCxnQkFBZ0JBLGNBQWMsRUFBRUMsY0FBY0EsWUFBWSxFQUFFLEdBQUdRLHNCQUFzQm5ELE9BQU87b0JBQ2hIcUMsU0FBU3JDLE9BQU8sQ0FBQ25CLEtBQUssR0FBR0E7b0JBQ3pCd0QsU0FBU3JDLE9BQU8sQ0FBQ29ELGlCQUFpQixDQUFDVixnQkFBZ0JDO29CQUNuRFAsTUFBTWlCLGFBQWEsQ0FBQ3hFO2dCQUN4QjtZQUNKO1FBQ0o7UUFDQVUsWUFBWUE7UUFDWkUsa0JBQWtCQTtRQUNsQkMsbUJBQW1CQTtRQUNuQixHQUFHd0QsVUFBVTtJQUNqQjtBQUNKO0FBS3NJLENBQ3RJLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaWNlZmV0Y2gvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdGV4dGZpZWxkL2Rpc3QvaW1wb3J0Lm1qcz8yMmQ4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlRWZmZWN0IGFzICRrT3E1SyR1c2VFZmZlY3QsIHVzZVJlZiBhcyAka09xNUskdXNlUmVmfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7ZmlsdGVyRE9NUHJvcHMgYXMgJGtPcTVLJGZpbHRlckRPTVByb3BzLCB1c2VGb3JtUmVzZXQgYXMgJGtPcTVLJHVzZUZvcm1SZXNldCwgZ2V0T3duZXJXaW5kb3cgYXMgJGtPcTVLJGdldE93bmVyV2luZG93LCBtZXJnZVByb3BzIGFzICRrT3E1SyRtZXJnZVByb3BzLCB1c2VFZmZlY3RFdmVudCBhcyAka09xNUskdXNlRWZmZWN0RXZlbnR9IGZyb20gXCJAcmVhY3QtYXJpYS91dGlsc1wiO1xuaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJGtPcTVLJHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5pbXBvcnQge3VzZUZpZWxkIGFzICRrT3E1SyR1c2VGaWVsZH0gZnJvbSBcIkByZWFjdC1hcmlhL2xhYmVsXCI7XG5pbXBvcnQge3VzZUZvY3VzYWJsZSBhcyAka09xNUskdXNlRm9jdXNhYmxlfSBmcm9tIFwiQHJlYWN0LWFyaWEvZm9jdXNcIjtcbmltcG9ydCB7dXNlRm9ybVZhbGlkYXRpb24gYXMgJGtPcTVLJHVzZUZvcm1WYWxpZGF0aW9ufSBmcm9tIFwiQHJlYWN0LWFyaWEvZm9ybVwiO1xuaW1wb3J0IHt1c2VGb3JtVmFsaWRhdGlvblN0YXRlIGFzICRrT3E1SyR1c2VGb3JtVmFsaWRhdGlvblN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvZm9ybVwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cblxuXG5cblxuZnVuY3Rpb24gJDJkNzNlYzI5NDE1YmQzMzkkZXhwb3J0JDcxMjcxOGY3YWVjODNkNShwcm9wcywgcmVmKSB7XG4gICAgbGV0IHsgaW5wdXRFbGVtZW50VHlwZTogaW5wdXRFbGVtZW50VHlwZSA9IFwiaW5wdXRcIiwgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCA9IGZhbHNlLCBpc1JlcXVpcmVkOiBpc1JlcXVpcmVkID0gZmFsc2UsIGlzUmVhZE9ubHk6IGlzUmVhZE9ubHkgPSBmYWxzZSwgdHlwZTogdHlwZSA9IFwidGV4dFwiLCB2YWxpZGF0aW9uQmVoYXZpb3I6IHZhbGlkYXRpb25CZWhhdmlvciA9IFwiYXJpYVwiIH0gPSBwcm9wcztcbiAgICBsZXQgW3ZhbHVlLCBzZXRWYWx1ZV0gPSAoMCwgJGtPcTVLJHVzZUNvbnRyb2xsZWRTdGF0ZSkocHJvcHMudmFsdWUsIHByb3BzLmRlZmF1bHRWYWx1ZSB8fCBcIlwiLCBwcm9wcy5vbkNoYW5nZSk7XG4gICAgbGV0IHsgZm9jdXNhYmxlUHJvcHM6IGZvY3VzYWJsZVByb3BzIH0gPSAoMCwgJGtPcTVLJHVzZUZvY3VzYWJsZSkocHJvcHMsIHJlZik7XG4gICAgbGV0IHZhbGlkYXRpb25TdGF0ZSA9ICgwLCAka09xNUskdXNlRm9ybVZhbGlkYXRpb25TdGF0ZSkoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG4gICAgbGV0IHsgaXNJbnZhbGlkOiBpc0ludmFsaWQsIHZhbGlkYXRpb25FcnJvcnM6IHZhbGlkYXRpb25FcnJvcnMsIHZhbGlkYXRpb25EZXRhaWxzOiB2YWxpZGF0aW9uRGV0YWlscyB9ID0gdmFsaWRhdGlvblN0YXRlLmRpc3BsYXlWYWxpZGF0aW9uO1xuICAgIGxldCB7IGxhYmVsUHJvcHM6IGxhYmVsUHJvcHMsIGZpZWxkUHJvcHM6IGZpZWxkUHJvcHMsIGRlc2NyaXB0aW9uUHJvcHM6IGRlc2NyaXB0aW9uUHJvcHMsIGVycm9yTWVzc2FnZVByb3BzOiBlcnJvck1lc3NhZ2VQcm9wcyB9ID0gKDAsICRrT3E1SyR1c2VGaWVsZCkoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgaXNJbnZhbGlkOiBpc0ludmFsaWQsXG4gICAgICAgIGVycm9yTWVzc2FnZTogcHJvcHMuZXJyb3JNZXNzYWdlIHx8IHZhbGlkYXRpb25FcnJvcnNcbiAgICB9KTtcbiAgICBsZXQgZG9tUHJvcHMgPSAoMCwgJGtPcTVLJGZpbHRlckRPTVByb3BzKShwcm9wcywge1xuICAgICAgICBsYWJlbGFibGU6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBpbnB1dE9ubHlQcm9wcyA9IHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgcGF0dGVybjogcHJvcHMucGF0dGVyblxuICAgIH07XG4gICAgKDAsICRrT3E1SyR1c2VGb3JtUmVzZXQpKHJlZiwgdmFsdWUsIHNldFZhbHVlKTtcbiAgICAoMCwgJGtPcTVLJHVzZUZvcm1WYWxpZGF0aW9uKShwcm9wcywgdmFsaWRhdGlvblN0YXRlLCByZWYpO1xuICAgICgwLCAka09xNUskdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICAvLyBUaGlzIHdvcmtzIGFyb3VuZCBhIFJlYWN0L0Nocm9tZSBidWcgdGhhdCBwcmV2ZW50cyB0ZXh0YXJlYSBlbGVtZW50cyBmcm9tIHZhbGlkYXRpbmcgd2hlbiBjb250cm9sbGVkLlxuICAgICAgICAvLyBXZSBwcmV2ZW50IFJlYWN0IGZyb20gdXBkYXRpbmcgZGVmYXVsdFZhbHVlIChpLmUuIGNoaWxkcmVuKSBvZiB0ZXh0YXJlYSB3aGVuIGB2YWx1ZWAgY2hhbmdlcyxcbiAgICAgICAgLy8gd2hpY2ggY2F1c2VzIENocm9tZSB0byBza2lwIHZhbGlkYXRpb24uIE9ubHkgdXBkYXRpbmcgYHZhbHVlYCBpcyBvayBpbiBvdXIgY2FzZSBzaW5jZSBvdXJcbiAgICAgICAgLy8gdGV4dGFyZWFzIGFyZSBhbHdheXMgY29udHJvbGxlZC4gUmVhY3QgaXMgcGxhbm5pbmcgb24gcmVtb3ZpbmcgdGhpcyBzeW5jaHJvbml6YXRpb24gaW4gYVxuICAgICAgICAvLyBmdXR1cmUgbWFqb3IgdmVyc2lvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTQ3NFxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExODk2XG4gICAgICAgIGlmIChyZWYuY3VycmVudCBpbnN0YW5jZW9mICgwLCAka09xNUskZ2V0T3duZXJXaW5kb3cpKHJlZi5jdXJyZW50KS5IVE1MVGV4dEFyZWFFbGVtZW50KSB7XG4gICAgICAgICAgICBsZXQgaW5wdXQgPSByZWYuY3VycmVudDtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnB1dCwgXCJkZWZhdWx0VmFsdWVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogKCk9PmlucHV0LnZhbHVlLFxuICAgICAgICAgICAgICAgIHNldDogKCk9Pnt9LFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIHJlZlxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxhYmVsUHJvcHM6IGxhYmVsUHJvcHMsXG4gICAgICAgIGlucHV0UHJvcHM6ICgwLCAka09xNUskbWVyZ2VQcm9wcykoZG9tUHJvcHMsIGlucHV0RWxlbWVudFR5cGUgPT09IFwiaW5wdXRcIiAmJiBpbnB1dE9ubHlQcm9wcywge1xuICAgICAgICAgICAgZGlzYWJsZWQ6IGlzRGlzYWJsZWQsXG4gICAgICAgICAgICByZWFkT25seTogaXNSZWFkT25seSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBpc1JlcXVpcmVkICYmIHZhbGlkYXRpb25CZWhhdmlvciA9PT0gXCJuYXRpdmVcIixcbiAgICAgICAgICAgIFwiYXJpYS1yZXF1aXJlZFwiOiBpc1JlcXVpcmVkICYmIHZhbGlkYXRpb25CZWhhdmlvciA9PT0gXCJhcmlhXCIgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgXCJhcmlhLWludmFsaWRcIjogaXNJbnZhbGlkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIFwiYXJpYS1lcnJvcm1lc3NhZ2VcIjogcHJvcHNbXCJhcmlhLWVycm9ybWVzc2FnZVwiXSxcbiAgICAgICAgICAgIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCI6IHByb3BzW1wiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCJdLFxuICAgICAgICAgICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBwcm9wc1tcImFyaWEtYXV0b2NvbXBsZXRlXCJdLFxuICAgICAgICAgICAgXCJhcmlhLWhhc3BvcHVwXCI6IHByb3BzW1wiYXJpYS1oYXNwb3B1cFwiXSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiAoZSk9PnNldFZhbHVlKGUudGFyZ2V0LnZhbHVlKSxcbiAgICAgICAgICAgIGF1dG9Db21wbGV0ZTogcHJvcHMuYXV0b0NvbXBsZXRlLFxuICAgICAgICAgICAgbWF4TGVuZ3RoOiBwcm9wcy5tYXhMZW5ndGgsXG4gICAgICAgICAgICBtaW5MZW5ndGg6IHByb3BzLm1pbkxlbmd0aCxcbiAgICAgICAgICAgIG5hbWU6IHByb3BzLm5hbWUsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogcHJvcHMucGxhY2Vob2xkZXIsXG4gICAgICAgICAgICBpbnB1dE1vZGU6IHByb3BzLmlucHV0TW9kZSxcbiAgICAgICAgICAgIC8vIENsaXBib2FyZCBldmVudHNcbiAgICAgICAgICAgIG9uQ29weTogcHJvcHMub25Db3B5LFxuICAgICAgICAgICAgb25DdXQ6IHByb3BzLm9uQ3V0LFxuICAgICAgICAgICAgb25QYXN0ZTogcHJvcHMub25QYXN0ZSxcbiAgICAgICAgICAgIC8vIENvbXBvc2l0aW9uIGV2ZW50c1xuICAgICAgICAgICAgb25Db21wb3NpdGlvbkVuZDogcHJvcHMub25Db21wb3NpdGlvbkVuZCxcbiAgICAgICAgICAgIG9uQ29tcG9zaXRpb25TdGFydDogcHJvcHMub25Db21wb3NpdGlvblN0YXJ0LFxuICAgICAgICAgICAgb25Db21wb3NpdGlvblVwZGF0ZTogcHJvcHMub25Db21wb3NpdGlvblVwZGF0ZSxcbiAgICAgICAgICAgIC8vIFNlbGVjdGlvbiBldmVudHNcbiAgICAgICAgICAgIG9uU2VsZWN0OiBwcm9wcy5vblNlbGVjdCxcbiAgICAgICAgICAgIC8vIElucHV0IGV2ZW50c1xuICAgICAgICAgICAgb25CZWZvcmVJbnB1dDogcHJvcHMub25CZWZvcmVJbnB1dCxcbiAgICAgICAgICAgIG9uSW5wdXQ6IHByb3BzLm9uSW5wdXQsXG4gICAgICAgICAgICAuLi5mb2N1c2FibGVQcm9wcyxcbiAgICAgICAgICAgIC4uLmZpZWxkUHJvcHNcbiAgICAgICAgfSksXG4gICAgICAgIGRlc2NyaXB0aW9uUHJvcHM6IGRlc2NyaXB0aW9uUHJvcHMsXG4gICAgICAgIGVycm9yTWVzc2FnZVByb3BzOiBlcnJvck1lc3NhZ2VQcm9wcyxcbiAgICAgICAgaXNJbnZhbGlkOiBpc0ludmFsaWQsXG4gICAgICAgIHZhbGlkYXRpb25FcnJvcnM6IHZhbGlkYXRpb25FcnJvcnMsXG4gICAgICAgIHZhbGlkYXRpb25EZXRhaWxzOiB2YWxpZGF0aW9uRGV0YWlsc1xuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIxIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cbmZ1bmN0aW9uICRkODQxYzgwMTBhNzNkNTQ1JHZhciRzdXBwb3J0c05hdGl2ZUJlZm9yZUlucHV0RXZlbnQoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LklucHV0RXZlbnQgJiYgLy8gQHRzLWlnbm9yZVxuICAgIHR5cGVvZiBJbnB1dEV2ZW50LnByb3RvdHlwZS5nZXRUYXJnZXRSYW5nZXMgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uICRkODQxYzgwMTBhNzNkNTQ1JGV4cG9ydCQ0ZjM4NGM5MjEwZTU4M2MzKHByb3BzLCBzdGF0ZSwgaW5wdXRSZWYpIHtcbiAgICAvLyBBbGwgYnJvd3NlcnMgaW1wbGVtZW50IHRoZSAnYmVmb3JlaW5wdXQnIGV2ZW50IG5hdGl2ZWx5IGV4Y2VwdCBGaXJlZm94XG4gICAgLy8gKGN1cnJlbnRseSBiZWhpbmQgYSBmbGFnIGFzIG9mIEZpcmVmb3ggODQpLiBSZWFjdCdzIHBvbHlmaWxsIGRvZXMgbm90XG4gICAgLy8gcnVuIGluIGFsbCBjYXNlcyB0aGF0IHRoZSBuYXRpdmUgZXZlbnQgZmlyZXMsIGUuZy4gd2hlbiBkZWxldGluZyB0ZXh0LlxuICAgIC8vIFVzZSB0aGUgbmF0aXZlIGV2ZW50IGlmIGF2YWlsYWJsZSBzbyB0aGF0IHdlIGNhbiBwcmV2ZW50IGludmFsaWQgZGVsZXRpb25zLlxuICAgIC8vIFdlIGRvIG5vdCBhdHRlbXB0IHRvIHBvbHlmaWxsIHRoaXMgaW4gRmlyZWZveCBzaW5jZSBpdCB3b3VsZCBiZSB2ZXJ5IGNvbXBsaWNhdGVkLFxuICAgIC8vIHRoZSBiZW5lZml0IG9mIGRvaW5nIHNvIGlzIGZhaXJseSBtaW5vciwgYW5kIGl0J3MgZ29pbmcgdG8gYmUgbmF0aXZlbHkgc3VwcG9ydGVkIHNvb24uXG4gICAgbGV0IG9uQmVmb3JlSW5wdXRGYWxsYmFjayA9ICgwLCAka09xNUskdXNlRWZmZWN0RXZlbnQpKChlKT0+e1xuICAgICAgICBsZXQgaW5wdXQgPSBpbnB1dFJlZi5jdXJyZW50O1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBuZXh0IHZhbHVlIG9mIHRoZSBpbnB1dCBpZiB0aGUgZXZlbnQgaXMgYWxsb3dlZCB0byBwcm9jZWVkLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL2lucHV0LWV2ZW50cy0yLyNpbnRlcmZhY2UtSW5wdXRFdmVudC1BdHRyaWJ1dGVzIGZvciBhIGZ1bGwgbGlzdCBvZiBpbnB1dCB0eXBlcy5cbiAgICAgICAgbGV0IG5leHRWYWx1ZTtcbiAgICAgICAgc3dpdGNoKGUuaW5wdXRUeXBlKXtcbiAgICAgICAgICAgIGNhc2UgXCJoaXN0b3J5VW5kb1wiOlxuICAgICAgICAgICAgY2FzZSBcImhpc3RvcnlSZWRvXCI6XG4gICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBhbGxvdyB1bmRvL3JlZG8uIGUuZGF0YSBpcyBudWxsIGluIHRoaXMgY2FzZSwgYnV0IHRoZXJlJ3Mgbm8gbmVlZCB0byB2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHByZXN1bWFibHkgdGhlIGlucHV0IHdvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBwcmV2aW91c2x5LlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJkZWxldGVDb250ZW50XCI6XG4gICAgICAgICAgICBjYXNlIFwiZGVsZXRlQnlDdXRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkZWxldGVCeURyYWdcIjpcbiAgICAgICAgICAgICAgICBuZXh0VmFsdWUgPSBpbnB1dC52YWx1ZS5zbGljZSgwLCBpbnB1dC5zZWxlY3Rpb25TdGFydCkgKyBpbnB1dC52YWx1ZS5zbGljZShpbnB1dC5zZWxlY3Rpb25FbmQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRlbGV0ZUNvbnRlbnRGb3J3YXJkXCI6XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBwb3RlbnRpYWxseSBpbmNvcnJlY3QsIHNpbmNlIHRoZSBicm93c2VyIG1heSBhY3R1YWxseSBkZWxldGUgbW9yZSB0aGFuIGEgc2luZ2xlIFVURi0xNlxuICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlci4gSW4gcmVhbGl0eSwgYSBmdWxsIFVuaWNvZGUgZ3JhcGhlbWUgY2x1c3RlciBjb25zaXN0aW5nIG9mIG11bHRpcGxlIFVURi0xNiBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgLy8gb3IgY29kZSBwb2ludHMgbWF5IGJlIGRlbGV0ZWQuIEhvd2V2ZXIsIGluIG91ciBjdXJyZW50bHkgc3VwcG9ydGVkIGxvY2FsZXMsIHRoZXJlIGFyZSBubyBzdWNoIGNhc2VzLlxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHN1cHBvcnQgYWRkaXRpb25hbCBsb2NhbGVzIGluIHRoZSBmdXR1cmUsIHRoaXMgbWF5IG5lZWQgdG8gY2hhbmdlLlxuICAgICAgICAgICAgICAgIG5leHRWYWx1ZSA9IGlucHV0LnNlbGVjdGlvbkVuZCA9PT0gaW5wdXQuc2VsZWN0aW9uU3RhcnQgPyBpbnB1dC52YWx1ZS5zbGljZSgwLCBpbnB1dC5zZWxlY3Rpb25TdGFydCkgKyBpbnB1dC52YWx1ZS5zbGljZShpbnB1dC5zZWxlY3Rpb25FbmQgKyAxKSA6IGlucHV0LnZhbHVlLnNsaWNlKDAsIGlucHV0LnNlbGVjdGlvblN0YXJ0KSArIGlucHV0LnZhbHVlLnNsaWNlKGlucHV0LnNlbGVjdGlvbkVuZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCI6XG4gICAgICAgICAgICAgICAgbmV4dFZhbHVlID0gaW5wdXQuc2VsZWN0aW9uRW5kID09PSBpbnB1dC5zZWxlY3Rpb25TdGFydCA/IGlucHV0LnZhbHVlLnNsaWNlKDAsIGlucHV0LnNlbGVjdGlvblN0YXJ0IC0gMSkgKyBpbnB1dC52YWx1ZS5zbGljZShpbnB1dC5zZWxlY3Rpb25TdGFydCkgOiBpbnB1dC52YWx1ZS5zbGljZSgwLCBpbnB1dC5zZWxlY3Rpb25TdGFydCkgKyBpbnB1dC52YWx1ZS5zbGljZShpbnB1dC5zZWxlY3Rpb25FbmQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVNvZnRMaW5lQmFja3dhcmRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkZWxldGVIYXJkTGluZUJhY2t3YXJkXCI6XG4gICAgICAgICAgICAgICAgbmV4dFZhbHVlID0gaW5wdXQudmFsdWUuc2xpY2UoaW5wdXQuc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoZS5kYXRhICE9IG51bGwpIG5leHRWYWx1ZSA9IGlucHV0LnZhbHVlLnNsaWNlKDAsIGlucHV0LnNlbGVjdGlvblN0YXJ0KSArIGUuZGF0YSArIGlucHV0LnZhbHVlLnNsaWNlKGlucHV0LnNlbGVjdGlvbkVuZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZGlkIG5vdCBjb21wdXRlIGEgdmFsdWUsIG9yIHRoZSBuZXcgdmFsdWUgaXMgaW52YWxpZCwgcHJldmVudCB0aGUgZXZlbnRcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCB1cGRhdGUgdGhlIGlucHV0IHRleHQsIG1vdmUgdGhlIHNlbGVjdGlvbiwgb3IgYWRkIHRvXG4gICAgICAgIC8vIHRoZSB1bmRvL3JlZG8gc3RhY2suXG4gICAgICAgIGlmIChuZXh0VmFsdWUgPT0gbnVsbCB8fCAhc3RhdGUudmFsaWRhdGUobmV4dFZhbHVlKSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuICAgICgwLCAka09xNUskdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoISRkODQxYzgwMTBhNzNkNTQ1JHZhciRzdXBwb3J0c05hdGl2ZUJlZm9yZUlucHV0RXZlbnQoKSkgcmV0dXJuO1xuICAgICAgICBsZXQgaW5wdXQgPSBpbnB1dFJlZi5jdXJyZW50O1xuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgb25CZWZvcmVJbnB1dEZhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIG9uQmVmb3JlSW5wdXRGYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgaW5wdXRSZWYsXG4gICAgICAgIG9uQmVmb3JlSW5wdXRGYWxsYmFja1xuICAgIF0pO1xuICAgIGxldCBvbkJlZm9yZUlucHV0ID0gISRkODQxYzgwMTBhNzNkNTQ1JHZhciRzdXBwb3J0c05hdGl2ZUJlZm9yZUlucHV0RXZlbnQoKSA/IChlKT0+e1xuICAgICAgICBsZXQgbmV4dFZhbHVlID0gZS50YXJnZXQudmFsdWUuc2xpY2UoMCwgZS50YXJnZXQuc2VsZWN0aW9uU3RhcnQpICsgZS5kYXRhICsgZS50YXJnZXQudmFsdWUuc2xpY2UoZS50YXJnZXQuc2VsZWN0aW9uRW5kKTtcbiAgICAgICAgaWYgKCFzdGF0ZS52YWxpZGF0ZShuZXh0VmFsdWUpKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSA6IG51bGw7XG4gICAgbGV0IHsgbGFiZWxQcm9wczogbGFiZWxQcm9wcywgaW5wdXRQcm9wczogdGV4dEZpZWxkUHJvcHMsIGRlc2NyaXB0aW9uUHJvcHM6IGRlc2NyaXB0aW9uUHJvcHMsIGVycm9yTWVzc2FnZVByb3BzOiBlcnJvck1lc3NhZ2VQcm9wcywgLi4udmFsaWRhdGlvbiB9ID0gKDAsICQyZDczZWMyOTQxNWJkMzM5JGV4cG9ydCQ3MTI3MThmN2FlYzgzZDUpKHByb3BzLCBpbnB1dFJlZik7XG4gICAgbGV0IGNvbXBvc2l0aW9uU3RhcnRTdGF0ZSA9ICgwLCAka09xNUskdXNlUmVmKShudWxsKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnB1dFByb3BzOiAoMCwgJGtPcTVLJG1lcmdlUHJvcHMpKHRleHRGaWVsZFByb3BzLCB7XG4gICAgICAgICAgICBvbkJlZm9yZUlucHV0OiBvbkJlZm9yZUlucHV0LFxuICAgICAgICAgICAgb25Db21wb3NpdGlvblN0YXJ0ICgpIHtcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgZG9lcyBub3QgaW1wbGVtZW50IElucHV0IEV2ZW50cyBMZXZlbCAyLCB3aGljaCBzcGVjaWZpZXMgdGhlIGluc2VydEZyb21Db21wb3NpdGlvblxuICAgICAgICAgICAgICAgIC8vIGFuZCBkZWxldGVCeUNvbXBvc2l0aW9uIGlucHV0VHlwZSB2YWx1ZXMgZm9yIHRoZSBiZWZvcmVpbnB1dCBldmVudC4gVGhlc2UgYXJlIG1lYW50IHRvIG9jY3VyXG4gICAgICAgICAgICAgICAgLy8gYXQgdGhlIGVuZCBvZiBhIGNvbXBvc2l0aW9uIChlLmcuIFBpbnlpbiBJTUUsIEFuZHJvaWQgYXV0byBjb3JyZWN0LCBldGMuKSwgYW5kIGNydWNpYWxseSwgYXJlXG4gICAgICAgICAgICAgICAgLy8gY2FuY2VsYWJsZS4gVGhlIGluc2VydENvbXBvc2l0aW9uVGV4dCBhbmQgZGVsZXRlQ29tcG9zaXRpb25UZXh0IGlucHV0IHR5cGVzIGFyZSBub3QgY2FuY2VsYWJsZSxcbiAgICAgICAgICAgICAgICAvLyBub3Igd291bGQgd2Ugd2FudCB0byBjYW5jZWwgdGhlbSBiZWNhdXNlIHRoZSBpbnB1dCBmcm9tIHRoZSB1c2VyIGlzIGluY29tcGxldGUgYXQgdGhhdCBwb2ludC5cbiAgICAgICAgICAgICAgICAvLyBJbiBTYWZhcmksIGluc2VydEZyb21Db21wb3NpdGlvbi9kZWxldGVGcm9tQ29tcG9zaXRpb24gd2lsbCBmaXJlLCBob3dldmVyLCBhbGxvd2luZyB1cyB0byBjYW5jZWxcbiAgICAgICAgICAgICAgICAvLyB0aGUgZmluYWwgY29tcG9zaXRpb24gcmVzdWx0IGlmIGl0IGlzIGludmFsaWQuIEFzIGEgZmFsbGJhY2sgZm9yIENocm9tZSBhbmQgRmlyZWZveCwgd2hpY2ggZWl0aGVyXG4gICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCBJbnB1dCBFdmVudHMgTGV2ZWwgMiwgb3IgYmVmb3JlaW5wdXQgYXQgYWxsLCB3ZSBzdG9yZSB0aGUgc3RhdGUgb2YgdGhlIGlucHV0IHdoZW5cbiAgICAgICAgICAgICAgICAvLyB0aGUgY29tcG9zaXRpb25zdGFydCBldmVudCBmaXJlcywgYW5kIHVuZG8gdGhlIGNoYW5nZXMgaW4gY29tcG9zaXRpb25lbmQgKGJlbG93KSBpZiBpdCBpcyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIHRoaXMgbWVzc2VzIHVwIHRoZSB1bmRvL3JlZG8gc3RhY2ssIGJ1dCB1bnRpbCBpbnNlcnRGcm9tQ29tcG9zaXRpb24vZGVsZXRlQnlDb21wb3NpdGlvblxuICAgICAgICAgICAgICAgIC8vIGFyZSBpbXBsZW1lbnRlZCwgdGhlcmUgaXMgbm8gb3RoZXIgd2F5IHRvIHByZXZlbnQgY29tcG9zZWQgaW5wdXQuXG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwMjIyMDRcbiAgICAgICAgICAgICAgICBsZXQgeyB2YWx1ZTogdmFsdWUsIHNlbGVjdGlvblN0YXJ0OiBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kOiBzZWxlY3Rpb25FbmQgfSA9IGlucHV0UmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgY29tcG9zaXRpb25TdGFydFN0YXRlLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQ6IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQ6IHNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Db21wb3NpdGlvbkVuZCAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS52YWxpZGF0ZShpbnB1dFJlZi5jdXJyZW50LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBpbnB1dCB2YWx1ZSBpbiB0aGUgRE9NIGltbWVkaWF0ZWx5IHNvIHdlIGNhbiBzeW5jaHJvbm91c2x5IHVwZGF0ZSB0aGUgc2VsZWN0aW9uIHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgICAgICAvLyBCdXQgYWxzbyB1cGRhdGUgdGhlIHZhbHVlIGluIFJlYWN0IHN0YXRlIGFzIHdlbGwgc28gaXQgaXMgY29ycmVjdCBmb3IgZnV0dXJlIHVwZGF0ZXMuXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHZhbHVlOiB2YWx1ZSwgc2VsZWN0aW9uU3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQ6IHNlbGVjdGlvbkVuZCB9ID0gY29tcG9zaXRpb25TdGFydFN0YXRlLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0UmVmLmN1cnJlbnQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRSZWYuY3VycmVudC5zZXRTZWxlY3Rpb25SYW5nZShzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2V0SW5wdXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgbGFiZWxQcm9wczogbGFiZWxQcm9wcyxcbiAgICAgICAgZGVzY3JpcHRpb25Qcm9wczogZGVzY3JpcHRpb25Qcm9wcyxcbiAgICAgICAgZXJyb3JNZXNzYWdlUHJvcHM6IGVycm9yTWVzc2FnZVByb3BzLFxuICAgICAgICAuLi52YWxpZGF0aW9uXG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IHskMmQ3M2VjMjk0MTViZDMzOSRleHBvcnQkNzEyNzE4ZjdhZWM4M2Q1IGFzIHVzZVRleHRGaWVsZCwgJGQ4NDFjODAxMGE3M2Q1NDUkZXhwb3J0JDRmMzg0YzkyMTBlNTgzYzMgYXMgdXNlRm9ybWF0dGVkVGV4dEZpZWxkfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCIka09xNUskdXNlRWZmZWN0IiwidXNlUmVmIiwiJGtPcTVLJHVzZVJlZiIsImZpbHRlckRPTVByb3BzIiwiJGtPcTVLJGZpbHRlckRPTVByb3BzIiwidXNlRm9ybVJlc2V0IiwiJGtPcTVLJHVzZUZvcm1SZXNldCIsImdldE93bmVyV2luZG93IiwiJGtPcTVLJGdldE93bmVyV2luZG93IiwibWVyZ2VQcm9wcyIsIiRrT3E1SyRtZXJnZVByb3BzIiwidXNlRWZmZWN0RXZlbnQiLCIka09xNUskdXNlRWZmZWN0RXZlbnQiLCJ1c2VDb250cm9sbGVkU3RhdGUiLCIka09xNUskdXNlQ29udHJvbGxlZFN0YXRlIiwidXNlRmllbGQiLCIka09xNUskdXNlRmllbGQiLCJ1c2VGb2N1c2FibGUiLCIka09xNUskdXNlRm9jdXNhYmxlIiwidXNlRm9ybVZhbGlkYXRpb24iLCIka09xNUskdXNlRm9ybVZhbGlkYXRpb24iLCJ1c2VGb3JtVmFsaWRhdGlvblN0YXRlIiwiJGtPcTVLJHVzZUZvcm1WYWxpZGF0aW9uU3RhdGUiLCIkMmQ3M2VjMjk0MTViZDMzOSRleHBvcnQkNzEyNzE4ZjdhZWM4M2Q1IiwicHJvcHMiLCJyZWYiLCJpbnB1dEVsZW1lbnRUeXBlIiwiaXNEaXNhYmxlZCIsImlzUmVxdWlyZWQiLCJpc1JlYWRPbmx5IiwidHlwZSIsInZhbGlkYXRpb25CZWhhdmlvciIsInZhbHVlIiwic2V0VmFsdWUiLCJkZWZhdWx0VmFsdWUiLCJvbkNoYW5nZSIsImZvY3VzYWJsZVByb3BzIiwidmFsaWRhdGlvblN0YXRlIiwiaXNJbnZhbGlkIiwidmFsaWRhdGlvbkVycm9ycyIsInZhbGlkYXRpb25EZXRhaWxzIiwiZGlzcGxheVZhbGlkYXRpb24iLCJsYWJlbFByb3BzIiwiZmllbGRQcm9wcyIsImRlc2NyaXB0aW9uUHJvcHMiLCJlcnJvck1lc3NhZ2VQcm9wcyIsImVycm9yTWVzc2FnZSIsImRvbVByb3BzIiwibGFiZWxhYmxlIiwiaW5wdXRPbmx5UHJvcHMiLCJwYXR0ZXJuIiwiY3VycmVudCIsIkhUTUxUZXh0QXJlYUVsZW1lbnQiLCJpbnB1dCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0Iiwic2V0IiwiY29uZmlndXJhYmxlIiwiaW5wdXRQcm9wcyIsImRpc2FibGVkIiwicmVhZE9ubHkiLCJyZXF1aXJlZCIsInVuZGVmaW5lZCIsImUiLCJ0YXJnZXQiLCJhdXRvQ29tcGxldGUiLCJtYXhMZW5ndGgiLCJtaW5MZW5ndGgiLCJuYW1lIiwicGxhY2Vob2xkZXIiLCJpbnB1dE1vZGUiLCJvbkNvcHkiLCJvbkN1dCIsIm9uUGFzdGUiLCJvbkNvbXBvc2l0aW9uRW5kIiwib25Db21wb3NpdGlvblN0YXJ0Iiwib25Db21wb3NpdGlvblVwZGF0ZSIsIm9uU2VsZWN0Iiwib25CZWZvcmVJbnB1dCIsIm9uSW5wdXQiLCIkZDg0MWM4MDEwYTczZDU0NSR2YXIkc3VwcG9ydHNOYXRpdmVCZWZvcmVJbnB1dEV2ZW50Iiwid2luZG93IiwiSW5wdXRFdmVudCIsInByb3RvdHlwZSIsImdldFRhcmdldFJhbmdlcyIsIiRkODQxYzgwMTBhNzNkNTQ1JGV4cG9ydCQ0ZjM4NGM5MjEwZTU4M2MzIiwic3RhdGUiLCJpbnB1dFJlZiIsIm9uQmVmb3JlSW5wdXRGYWxsYmFjayIsIm5leHRWYWx1ZSIsImlucHV0VHlwZSIsInNsaWNlIiwic2VsZWN0aW9uU3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJkYXRhIiwidmFsaWRhdGUiLCJwcmV2ZW50RGVmYXVsdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidGV4dEZpZWxkUHJvcHMiLCJ2YWxpZGF0aW9uIiwiY29tcG9zaXRpb25TdGFydFN0YXRlIiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJzZXRJbnB1dFZhbHVlIiwidXNlVGV4dEZpZWxkIiwidXNlRm9ybWF0dGVkVGV4dEZpZWxkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-aria/textfield/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-aria/utils/dist/import.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@react-aria/utils/dist/import.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RouterProvider: () => (/* binding */ $ea8dcbcb9ea1b556$export$323e4fc2fa4753fb),\n/* harmony export */   chain: () => (/* binding */ $ff5963eb1fccf552$export$e08e3b67e392101e),\n/* harmony export */   clamp: () => (/* reexport safe */ _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.clamp),\n/* harmony export */   filterDOMProps: () => (/* binding */ $65484d02dcb7eb3e$export$457c3d6518dd4c6f),\n/* harmony export */   focusWithoutScrolling: () => (/* binding */ $7215afc6de606d6b$export$de79e2c695e052f3),\n/* harmony export */   getOffset: () => (/* binding */ $ab71dadb03a6fb2e$export$622cea445a1c5b7d),\n/* harmony export */   getOwnerDocument: () => (/* binding */ $431fbd86ca7dc216$export$b204af158042fbac),\n/* harmony export */   getOwnerWindow: () => (/* binding */ $431fbd86ca7dc216$export$f21a1ffae260145a),\n/* harmony export */   getScrollParent: () => (/* binding */ $62d8ded9296f3872$export$cfa2225e87938781),\n/* harmony export */   getSyntheticLinkProps: () => (/* binding */ $ea8dcbcb9ea1b556$export$51437d503373d223),\n/* harmony export */   isAndroid: () => (/* binding */ $c87311424ea30a05$export$a11b0059900ceec8),\n/* harmony export */   isAppleDevice: () => (/* binding */ $c87311424ea30a05$export$e1865c3bedcd822b),\n/* harmony export */   isChrome: () => (/* binding */ $c87311424ea30a05$export$6446a186d09e379e),\n/* harmony export */   isIOS: () => (/* binding */ $c87311424ea30a05$export$fedb369cb70207f1),\n/* harmony export */   isIPad: () => (/* binding */ $c87311424ea30a05$export$7bef049ce92e4224),\n/* harmony export */   isIPhone: () => (/* binding */ $c87311424ea30a05$export$186c6964ca17d99),\n/* harmony export */   isMac: () => (/* binding */ $c87311424ea30a05$export$9ac100e40613ea10),\n/* harmony export */   isScrollable: () => (/* binding */ $62d8ded9296f3872$export$2bb74740c4e19def),\n/* harmony export */   isVirtualClick: () => (/* binding */ $6a7db85432448f7f$export$60278871457622de),\n/* harmony export */   isVirtualPointerEvent: () => (/* binding */ $6a7db85432448f7f$export$29bf1b5f2c56cf63),\n/* harmony export */   isWebKit: () => (/* binding */ $c87311424ea30a05$export$78551043582a6a98),\n/* harmony export */   mergeIds: () => (/* binding */ $bdb11010cef70236$export$cd8c9cb68f842629),\n/* harmony export */   mergeProps: () => (/* binding */ $3ef42575df84b30b$export$9d1611c77c2fe928),\n/* harmony export */   mergeRefs: () => (/* binding */ $5dc95899b306f630$export$c9058316764c140e),\n/* harmony export */   openLink: () => (/* binding */ $ea8dcbcb9ea1b556$export$95185d699e05d4d7),\n/* harmony export */   runAfterTransition: () => (/* binding */ $bbed8b41f857bcc0$export$24490316f764c430),\n/* harmony export */   scrollIntoView: () => (/* binding */ $2f04cbc44ee30ce0$export$53a0910f038337bd),\n/* harmony export */   scrollIntoViewport: () => (/* binding */ $2f04cbc44ee30ce0$export$c826860796309d1b),\n/* harmony export */   shouldClientNavigate: () => (/* binding */ $ea8dcbcb9ea1b556$export$efa8c9099e530235),\n/* harmony export */   snapValueToStep: () => (/* reexport safe */ _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__.snapValueToStep),\n/* harmony export */   useDeepMemo: () => (/* binding */ $5a387cc49350e6db$export$722debc0e56fea39),\n/* harmony export */   useDescription: () => (/* binding */ $ef06256079686ba0$export$f8aeda7b10753fa1),\n/* harmony export */   useDrag1D: () => (/* binding */ $9cc09df9fd7676be$export$7bbed75feba39706),\n/* harmony export */   useEffectEvent: () => (/* binding */ $8ae05eaa5c114e9c$export$7f54fc3180508a52),\n/* harmony export */   useEvent: () => (/* binding */ $e9faafb641e167db$export$90fc3a17d93f704c),\n/* harmony export */   useFormReset: () => (/* binding */ $99facab73266f662$export$5add1d006293d136),\n/* harmony export */   useGlobalListeners: () => (/* binding */ $03deb23ff14920c4$export$4eaf04e54aa8eed6),\n/* harmony export */   useId: () => (/* binding */ $bdb11010cef70236$export$f680877a34711e37),\n/* harmony export */   useLabels: () => (/* binding */ $313b98861ee5dd6c$export$d6875122194c7b44),\n/* harmony export */   useLayoutEffect: () => (/* binding */ $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c),\n/* harmony export */   useObjectRef: () => (/* binding */ $df56164dff5785e2$export$4338b53315abf666),\n/* harmony export */   useResizeObserver: () => (/* binding */ $9daab02d461809db$export$683480f191c0e3ea),\n/* harmony export */   useRouter: () => (/* binding */ $ea8dcbcb9ea1b556$export$9a302a45f65d0572),\n/* harmony export */   useSlotId: () => (/* binding */ $bdb11010cef70236$export$b4cc09c592e8fdb8),\n/* harmony export */   useSyncRef: () => (/* binding */ $e7801be82b4b2a53$export$4debdb1a3f0fa79e),\n/* harmony export */   useUpdateEffect: () => (/* binding */ $4f58c5f72bcf79f7$export$496315a1608d9602),\n/* harmony export */   useValueEffect: () => (/* binding */ $1dbecbe27a04f9af$export$14d238f342723f25),\n/* harmony export */   useViewportSize: () => (/* binding */ $5df64b3807dc15ee$export$d699905dd57c73ca)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_ssr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/ssr */ \"(ssr)/./node_modules/@react-aria/ssr/dist/import.mjs\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.m.js\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document !== \"undefined\" ? (0, react__WEBPACK_IMPORTED_MODULE_0__).useLayoutEffect : ()=>{};\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn) {\n    const ref = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        ref.current = fn;\n    }, [\n        fn\n    ]);\n    // @ts-ignore\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        const f = ref.current;\n        return f(...args);\n    }, []);\n}\nfunction $1dbecbe27a04f9af$export$14d238f342723f25(defaultValue) {\n    let [value1, setValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultValue);\n    let effect = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Store the function in a ref so we can always access the current version\n    // which has the proper `value` in scope.\n    let nextRef = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(()=>{\n        // Run the generator to the next yield.\n        let newValue = effect.current.next();\n        // If the generator is done, reset the effect.\n        if (newValue.done) {\n            effect.current = null;\n            return;\n        }\n        // If the value is the same as the current value,\n        // then continue to the next yield. Otherwise,\n        // set the value in state and wait for the next layout effect.\n        if (value1 === newValue.value) nextRef();\n        else setValue(newValue.value);\n    });\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        // If there is an effect currently running, continue to the next yield.\n        if (effect.current) nextRef();\n    });\n    let queue = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((fn)=>{\n        effect.current = fn(value1);\n        nextRef();\n    });\n    return [\n        value1,\n        queue\n    ];\n}\n// copied from SSRProvider.tsx to reduce exports, if needed again, consider sharing\nlet $bdb11010cef70236$var$canUseDOM = Boolean( false && 0);\nlet $bdb11010cef70236$var$idsUpdaterMap = new Map();\nfunction $bdb11010cef70236$export$f680877a34711e37(defaultId) {\n    let [value1, setValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(defaultId);\n    let nextId = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let res = (0, _react_aria_ssr__WEBPACK_IMPORTED_MODULE_2__.useSSRSafeId)(value1);\n    let updateValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((val)=>{\n        nextId.current = val;\n    }, []);\n    if ($bdb11010cef70236$var$canUseDOM) $bdb11010cef70236$var$idsUpdaterMap.set(res, updateValue);\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        let r = res;\n        return ()=>{\n            $bdb11010cef70236$var$idsUpdaterMap.delete(r);\n        };\n    }, [\n        res\n    ]);\n    // This cannot cause an infinite loop because the ref is updated first.\n    // eslint-disable-next-line\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let newId = nextId.current;\n        if (newId) {\n            nextId.current = null;\n            setValue(newId);\n        }\n    });\n    return res;\n}\nfunction $bdb11010cef70236$export$cd8c9cb68f842629(idA, idB) {\n    if (idA === idB) return idA;\n    let setIdA = $bdb11010cef70236$var$idsUpdaterMap.get(idA);\n    if (setIdA) {\n        setIdA(idB);\n        return idB;\n    }\n    let setIdB = $bdb11010cef70236$var$idsUpdaterMap.get(idB);\n    if (setIdB) {\n        setIdB(idA);\n        return idA;\n    }\n    return idB;\n}\nfunction $bdb11010cef70236$export$b4cc09c592e8fdb8(depArray = []) {\n    let id = $bdb11010cef70236$export$f680877a34711e37();\n    let [resolvedId, setResolvedId] = (0, $1dbecbe27a04f9af$export$14d238f342723f25)(id);\n    let updateId = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setResolvedId(function*() {\n            yield id;\n            yield document.getElementById(id) ? id : undefined;\n        });\n    }, [\n        id,\n        setResolvedId\n    ]);\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(updateId, [\n        id,\n        updateId,\n        ...depArray\n    ]);\n    return resolvedId;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /**\n * Calls all functions in the order they were chained with the same arguments.\n */ function $ff5963eb1fccf552$export$e08e3b67e392101e(...callbacks) {\n    return (...args)=>{\n        for (let callback of callbacks)if (typeof callback === \"function\") callback(...args);\n    };\n}\nconst $431fbd86ca7dc216$export$b204af158042fbac = (el)=>{\n    var _el_ownerDocument;\n    return (_el_ownerDocument = el === null || el === void 0 ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;\n};\nconst $431fbd86ca7dc216$export$f21a1ffae260145a = (el)=>{\n    if (el && \"window\" in el && el.window === el) return el;\n    const doc = $431fbd86ca7dc216$export$b204af158042fbac(el);\n    return doc.defaultView || window;\n};\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $3ef42575df84b30b$export$9d1611c77c2fe928(...args) {\n    // Start with a base clone of the first argument. This is a lot faster than starting\n    // with an empty object and adding properties as we go.\n    let result = {\n        ...args[0]\n    };\n    for(let i = 1; i < args.length; i++){\n        let props = args[i];\n        for(let key in props){\n            let a = result[key];\n            let b = props[key];\n            // Chain events\n            if (typeof a === \"function\" && typeof b === \"function\" && // This is a lot faster than a regex.\n            key[0] === \"o\" && key[1] === \"n\" && key.charCodeAt(2) >= /* 'A' */ 65 && key.charCodeAt(2) <= /* 'Z' */ 90) result[key] = (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(a, b);\n            else if ((key === \"className\" || key === \"UNSAFE_className\") && typeof a === \"string\" && typeof b === \"string\") result[key] = (0, clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(a, b);\n            else if (key === \"id\" && a && b) result.id = (0, $bdb11010cef70236$export$cd8c9cb68f842629)(a, b);\n            else result[key] = b !== undefined ? b : a;\n        }\n    }\n    return result;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $5dc95899b306f630$export$c9058316764c140e(...refs) {\n    if (refs.length === 1) return refs[0];\n    return (value1)=>{\n        for (let ref of refs){\n            if (typeof ref === \"function\") ref(value1);\n            else if (ref != null) ref.current = value1;\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $65484d02dcb7eb3e$var$DOMPropNames = new Set([\n    \"id\"\n]);\nconst $65484d02dcb7eb3e$var$labelablePropNames = new Set([\n    \"aria-label\",\n    \"aria-labelledby\",\n    \"aria-describedby\",\n    \"aria-details\"\n]);\n// See LinkDOMProps in dom.d.ts.\nconst $65484d02dcb7eb3e$var$linkPropNames = new Set([\n    \"href\",\n    \"target\",\n    \"rel\",\n    \"download\",\n    \"ping\",\n    \"referrerPolicy\"\n]);\nconst $65484d02dcb7eb3e$var$propRe = /^(data-.*)$/;\nfunction $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, opts = {}) {\n    let { labelable: labelable, isLink: isLink, propNames: propNames } = opts;\n    let filteredProps = {};\n    for(const prop in props)if (Object.prototype.hasOwnProperty.call(props, prop) && ($65484d02dcb7eb3e$var$DOMPropNames.has(prop) || labelable && $65484d02dcb7eb3e$var$labelablePropNames.has(prop) || isLink && $65484d02dcb7eb3e$var$linkPropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $65484d02dcb7eb3e$var$propRe.test(prop))) filteredProps[prop] = props[prop];\n    return filteredProps;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $7215afc6de606d6b$export$de79e2c695e052f3(element) {\n    if ($7215afc6de606d6b$var$supportsPreventScroll()) element.focus({\n        preventScroll: true\n    });\n    else {\n        let scrollableElements = $7215afc6de606d6b$var$getScrollableElements(element);\n        element.focus();\n        $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements);\n    }\n}\nlet $7215afc6de606d6b$var$supportsPreventScrollCached = null;\nfunction $7215afc6de606d6b$var$supportsPreventScroll() {\n    if ($7215afc6de606d6b$var$supportsPreventScrollCached == null) {\n        $7215afc6de606d6b$var$supportsPreventScrollCached = false;\n        try {\n            var focusElem = document.createElement(\"div\");\n            focusElem.focus({\n                get preventScroll () {\n                    $7215afc6de606d6b$var$supportsPreventScrollCached = true;\n                    return true;\n                }\n            });\n        } catch (e) {\n        // Ignore\n        }\n    }\n    return $7215afc6de606d6b$var$supportsPreventScrollCached;\n}\nfunction $7215afc6de606d6b$var$getScrollableElements(element) {\n    var parent = element.parentNode;\n    var scrollableElements = [];\n    var rootScrollingElement = document.scrollingElement || document.documentElement;\n    while(parent instanceof HTMLElement && parent !== rootScrollingElement){\n        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({\n            element: parent,\n            scrollTop: parent.scrollTop,\n            scrollLeft: parent.scrollLeft\n        });\n        parent = parent.parentNode;\n    }\n    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({\n        element: rootScrollingElement,\n        scrollTop: rootScrollingElement.scrollTop,\n        scrollLeft: rootScrollingElement.scrollLeft\n    });\n    return scrollableElements;\n}\nfunction $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements) {\n    for (let { element: element, scrollTop: scrollTop, scrollLeft: scrollLeft } of scrollableElements){\n        element.scrollTop = scrollTop;\n        element.scrollLeft = scrollLeft;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $ab71dadb03a6fb2e$export$622cea445a1c5b7d(element, reverse, orientation = \"horizontal\") {\n    let rect = element.getBoundingClientRect();\n    if (reverse) return orientation === \"horizontal\" ? rect.right : rect.bottom;\n    return orientation === \"horizontal\" ? rect.left : rect.top;\n}\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $c87311424ea30a05$var$testUserAgent(re) {\n    var _window_navigator_userAgentData;\n    if (true) return false;\n    return ((_window_navigator_userAgentData = window.navigator[\"userAgentData\"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand)=>re.test(brand.brand))) || re.test(window.navigator.userAgent);\n}\nfunction $c87311424ea30a05$var$testPlatform(re) {\n    var _window_navigator_userAgentData;\n    return  false ? 0 : false;\n}\nfunction $c87311424ea30a05$export$9ac100e40613ea10() {\n    return $c87311424ea30a05$var$testPlatform(/^Mac/i);\n}\nfunction $c87311424ea30a05$export$186c6964ca17d99() {\n    return $c87311424ea30a05$var$testPlatform(/^iPhone/i);\n}\nfunction $c87311424ea30a05$export$7bef049ce92e4224() {\n    return $c87311424ea30a05$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n    $c87311424ea30a05$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;\n}\nfunction $c87311424ea30a05$export$fedb369cb70207f1() {\n    return $c87311424ea30a05$export$186c6964ca17d99() || $c87311424ea30a05$export$7bef049ce92e4224();\n}\nfunction $c87311424ea30a05$export$e1865c3bedcd822b() {\n    return $c87311424ea30a05$export$9ac100e40613ea10() || $c87311424ea30a05$export$fedb369cb70207f1();\n}\nfunction $c87311424ea30a05$export$78551043582a6a98() {\n    return $c87311424ea30a05$var$testUserAgent(/AppleWebKit/i) && !$c87311424ea30a05$export$6446a186d09e379e();\n}\nfunction $c87311424ea30a05$export$6446a186d09e379e() {\n    return $c87311424ea30a05$var$testUserAgent(/Chrome/i);\n}\nfunction $c87311424ea30a05$export$a11b0059900ceec8() {\n    return $c87311424ea30a05$var$testUserAgent(/Android/i);\n}\nfunction $c87311424ea30a05$export$b7d78993b74f766d() {\n    return $c87311424ea30a05$var$testUserAgent(/Firefox/i);\n}\nconst $ea8dcbcb9ea1b556$var$RouterContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    isNative: true,\n    open: $ea8dcbcb9ea1b556$var$openSyntheticLink\n});\nfunction $ea8dcbcb9ea1b556$export$323e4fc2fa4753fb(props) {\n    let { children: children, navigate: navigate } = props;\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            isNative: false,\n            open: (target, modifiers)=>{\n                $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link)=>{\n                    if ($ea8dcbcb9ea1b556$export$efa8c9099e530235(link, modifiers)) navigate(link.pathname + link.search + link.hash);\n                    else $ea8dcbcb9ea1b556$export$95185d699e05d4d7(link, modifiers);\n                });\n            }\n        }), [\n        navigate\n    ]);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($ea8dcbcb9ea1b556$var$RouterContext.Provider, {\n        value: ctx\n    }, children);\n}\nfunction $ea8dcbcb9ea1b556$export$9a302a45f65d0572() {\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($ea8dcbcb9ea1b556$var$RouterContext);\n}\nfunction $ea8dcbcb9ea1b556$export$efa8c9099e530235(link, modifiers) {\n    // Use getAttribute here instead of link.target. Firefox will default link.target to \"_parent\" when inside an iframe.\n    let target = link.getAttribute(\"target\");\n    return (!target || target === \"_self\") && link.origin === location.origin && !link.hasAttribute(\"download\") && !modifiers.metaKey && // open in new tab (mac)\n    !modifiers.ctrlKey && // open in new tab (windows)\n    !modifiers.altKey && // download\n    !modifiers.shiftKey;\n}\nfunction $ea8dcbcb9ea1b556$export$95185d699e05d4d7(target, modifiers, setOpening = true) {\n    var _window_event_type, _window_event;\n    let { metaKey: metaKey, ctrlKey: ctrlKey, altKey: altKey, shiftKey: shiftKey } = modifiers;\n    // Firefox does not recognize keyboard events as a user action by default, and the popup blocker\n    // will prevent links with target=\"_blank\" from opening. However, it does allow the event if the\n    // Command/Control key is held, which opens the link in a background tab. This seems like the best we can do.\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=257870 and https://bugzilla.mozilla.org/show_bug.cgi?id=746640.\n    if ((0, $c87311424ea30a05$export$b7d78993b74f766d)() && ((_window_event = window.event) === null || _window_event === void 0 ? void 0 : (_window_event_type = _window_event.type) === null || _window_event_type === void 0 ? void 0 : _window_event_type.startsWith(\"key\")) && target.target === \"_blank\") {\n        if ((0, $c87311424ea30a05$export$9ac100e40613ea10)()) metaKey = true;\n        else ctrlKey = true;\n    }\n    // WebKit does not support firing click events with modifier keys, but does support keyboard events.\n    // https://github.com/WebKit/WebKit/blob/c03d0ac6e6db178f90923a0a63080b5ca210d25f/Source/WebCore/html/HTMLAnchorElement.cpp#L184\n    let event = (0, $c87311424ea30a05$export$78551043582a6a98)() && (0, $c87311424ea30a05$export$9ac100e40613ea10)() && !(0, $c87311424ea30a05$export$7bef049ce92e4224)() && true ? new KeyboardEvent(\"keydown\", {\n        keyIdentifier: \"Enter\",\n        metaKey: metaKey,\n        ctrlKey: ctrlKey,\n        altKey: altKey,\n        shiftKey: shiftKey\n    }) : new MouseEvent(\"click\", {\n        metaKey: metaKey,\n        ctrlKey: ctrlKey,\n        altKey: altKey,\n        shiftKey: shiftKey,\n        bubbles: true,\n        cancelable: true\n    });\n    $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = setOpening;\n    (0, $7215afc6de606d6b$export$de79e2c695e052f3)(target);\n    target.dispatchEvent(event);\n    $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;\n}\n// https://github.com/parcel-bundler/parcel/issues/8724\n$ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;\nfunction $ea8dcbcb9ea1b556$var$getSyntheticLink(target, open) {\n    if (target instanceof HTMLAnchorElement) open(target);\n    else if (target.hasAttribute(\"data-href\")) {\n        let link = document.createElement(\"a\");\n        link.href = target.getAttribute(\"data-href\");\n        if (target.hasAttribute(\"data-target\")) link.target = target.getAttribute(\"data-target\");\n        if (target.hasAttribute(\"data-rel\")) link.rel = target.getAttribute(\"data-rel\");\n        if (target.hasAttribute(\"data-download\")) link.download = target.getAttribute(\"data-download\");\n        if (target.hasAttribute(\"data-ping\")) link.ping = target.getAttribute(\"data-ping\");\n        if (target.hasAttribute(\"data-referrer-policy\")) link.referrerPolicy = target.getAttribute(\"data-referrer-policy\");\n        target.appendChild(link);\n        open(link);\n        target.removeChild(link);\n    }\n}\nfunction $ea8dcbcb9ea1b556$var$openSyntheticLink(target, modifiers) {\n    $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link)=>$ea8dcbcb9ea1b556$export$95185d699e05d4d7(link, modifiers));\n}\nfunction $ea8dcbcb9ea1b556$export$51437d503373d223(props) {\n    return {\n        \"data-href\": props.href,\n        \"data-target\": props.target,\n        \"data-rel\": props.rel,\n        \"data-download\": props.download,\n        \"data-ping\": props.ping,\n        \"data-referrer-policy\": props.referrerPolicy\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // We store a global list of elements that are currently transitioning,\n// mapped to a set of CSS properties that are transitioning for that element.\n// This is necessary rather than a simple count of transitions because of browser\n// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather\n// than one or the other. So we need to track what's actually transitioning so that\n// we can ignore these duplicate events.\nlet $bbed8b41f857bcc0$var$transitionsByElement = new Map();\n// A list of callbacks to call once there are no transitioning elements.\nlet $bbed8b41f857bcc0$var$transitionCallbacks = new Set();\nfunction $bbed8b41f857bcc0$var$setupGlobalEvents() {\n    if (true) return;\n    let onTransitionStart = (e)=>{\n        // Add the transitioning property to the list for this element.\n        let transitions = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n        if (!transitions) {\n            transitions = new Set();\n            $bbed8b41f857bcc0$var$transitionsByElement.set(e.target, transitions);\n            // The transitioncancel event must be registered on the element itself, rather than as a global\n            // event. This enables us to handle when the node is deleted from the document while it is transitioning.\n            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.\n            e.target.addEventListener(\"transitioncancel\", onTransitionEnd);\n        }\n        transitions.add(e.propertyName);\n    };\n    let onTransitionEnd = (e)=>{\n        // Remove property from list of transitioning properties.\n        let properties = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n        if (!properties) return;\n        properties.delete(e.propertyName);\n        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.\n        if (properties.size === 0) {\n            e.target.removeEventListener(\"transitioncancel\", onTransitionEnd);\n            $bbed8b41f857bcc0$var$transitionsByElement.delete(e.target);\n        }\n        // If no transitioning elements, call all of the queued callbacks.\n        if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) {\n            for (let cb of $bbed8b41f857bcc0$var$transitionCallbacks)cb();\n            $bbed8b41f857bcc0$var$transitionCallbacks.clear();\n        }\n    };\n    document.body.addEventListener(\"transitionrun\", onTransitionStart);\n    document.body.addEventListener(\"transitionend\", onTransitionEnd);\n}\nif (typeof document !== \"undefined\") {\n    if (document.readyState !== \"loading\") $bbed8b41f857bcc0$var$setupGlobalEvents();\n    else document.addEventListener(\"DOMContentLoaded\", $bbed8b41f857bcc0$var$setupGlobalEvents);\n}\nfunction $bbed8b41f857bcc0$export$24490316f764c430(fn) {\n    // Wait one frame to see if an animation starts, e.g. a transition on mount.\n    requestAnimationFrame(()=>{\n        // If no transitions are running, call the function immediately.\n        // Otherwise, add it to a list of callbacks to run at the end of the animation.\n        if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) fn();\n        else $bbed8b41f857bcc0$var$transitionCallbacks.add(fn);\n    });\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /* eslint-disable rulesdir/pure-render */ // Keep track of elements that we are currently handling dragging for via useDrag1D.\n// If there's an ancestor and a descendant both using useDrag1D(), and the user starts\n// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.\nconst $9cc09df9fd7676be$var$draggingElements = [];\nfunction $9cc09df9fd7676be$export$7bbed75feba39706(props) {\n    console.warn(\"useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html\");\n    let { containerRef: containerRef, reverse: reverse, orientation: orientation, onHover: onHover, onDrag: onDrag, onPositionChange: onPositionChange, onIncrement: onIncrement, onDecrement: onDecrement, onIncrementToMax: onIncrementToMax, onDecrementToMin: onDecrementToMin, onCollapseToggle: onCollapseToggle } = props;\n    let getPosition = (e)=>orientation === \"horizontal\" ? e.clientX : e.clientY;\n    let getNextOffset = (e)=>{\n        let containerOffset = (0, $ab71dadb03a6fb2e$export$622cea445a1c5b7d)(containerRef.current, reverse, orientation);\n        let mouseOffset = getPosition(e);\n        let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;\n        return nextOffset;\n    };\n    let dragging = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let prevPosition = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    // Keep track of the current handlers in a ref so that the events can access them.\n    let handlers = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        onPositionChange: onPositionChange,\n        onDrag: onDrag\n    });\n    handlers.current.onDrag = onDrag;\n    handlers.current.onPositionChange = onPositionChange;\n    let onMouseDragged = (e)=>{\n        e.preventDefault();\n        let nextOffset = getNextOffset(e);\n        if (!dragging.current) {\n            dragging.current = true;\n            if (handlers.current.onDrag) handlers.current.onDrag(true);\n            if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);\n        }\n        if (prevPosition.current === nextOffset) return;\n        prevPosition.current = nextOffset;\n        if (onPositionChange) onPositionChange(nextOffset);\n    };\n    let onMouseUp = (e)=>{\n        const target = e.target;\n        dragging.current = false;\n        let nextOffset = getNextOffset(e);\n        if (handlers.current.onDrag) handlers.current.onDrag(false);\n        if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);\n        $9cc09df9fd7676be$var$draggingElements.splice($9cc09df9fd7676be$var$draggingElements.indexOf(target), 1);\n        window.removeEventListener(\"mouseup\", onMouseUp, false);\n        window.removeEventListener(\"mousemove\", onMouseDragged, false);\n    };\n    let onMouseDown = (e)=>{\n        const target = e.currentTarget;\n        // If we're already handling dragging on a descendant with useDrag1D, then\n        // we don't want to handle the drag motion on this target as well.\n        if ($9cc09df9fd7676be$var$draggingElements.some((elt)=>target.contains(elt))) return;\n        $9cc09df9fd7676be$var$draggingElements.push(target);\n        window.addEventListener(\"mousemove\", onMouseDragged, false);\n        window.addEventListener(\"mouseup\", onMouseUp, false);\n    };\n    let onMouseEnter = ()=>{\n        if (onHover) onHover(true);\n    };\n    let onMouseOut = ()=>{\n        if (onHover) onHover(false);\n    };\n    let onKeyDown = (e)=>{\n        switch(e.key){\n            case \"Left\":\n            case \"ArrowLeft\":\n                if (orientation === \"horizontal\") {\n                    e.preventDefault();\n                    if (onDecrement && !reverse) onDecrement();\n                    else if (onIncrement && reverse) onIncrement();\n                }\n                break;\n            case \"Up\":\n            case \"ArrowUp\":\n                if (orientation === \"vertical\") {\n                    e.preventDefault();\n                    if (onDecrement && !reverse) onDecrement();\n                    else if (onIncrement && reverse) onIncrement();\n                }\n                break;\n            case \"Right\":\n            case \"ArrowRight\":\n                if (orientation === \"horizontal\") {\n                    e.preventDefault();\n                    if (onIncrement && !reverse) onIncrement();\n                    else if (onDecrement && reverse) onDecrement();\n                }\n                break;\n            case \"Down\":\n            case \"ArrowDown\":\n                if (orientation === \"vertical\") {\n                    e.preventDefault();\n                    if (onIncrement && !reverse) onIncrement();\n                    else if (onDecrement && reverse) onDecrement();\n                }\n                break;\n            case \"Home\":\n                e.preventDefault();\n                if (onDecrementToMin) onDecrementToMin();\n                break;\n            case \"End\":\n                e.preventDefault();\n                if (onIncrementToMax) onIncrementToMax();\n                break;\n            case \"Enter\":\n                e.preventDefault();\n                if (onCollapseToggle) onCollapseToggle();\n                break;\n        }\n    };\n    return {\n        onMouseDown: onMouseDown,\n        onMouseEnter: onMouseEnter,\n        onMouseOut: onMouseOut,\n        onKeyDown: onKeyDown\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {\n    let globalListeners = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    let addGlobalListener = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((eventTarget, type, listener, options)=>{\n        // Make sure we remove the listener after it is called with the `once` option.\n        let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args)=>{\n            globalListeners.current.delete(listener);\n            listener(...args);\n        } : listener;\n        globalListeners.current.set(listener, {\n            type: type,\n            eventTarget: eventTarget,\n            fn: fn,\n            options: options\n        });\n        eventTarget.addEventListener(type, listener, options);\n    }, []);\n    let removeGlobalListener = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((eventTarget, type, listener, options)=>{\n        var _globalListeners_current_get;\n        let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;\n        eventTarget.removeEventListener(type, fn, options);\n        globalListeners.current.delete(listener);\n    }, []);\n    let removeAllGlobalListeners = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        globalListeners.current.forEach((value1, key)=>{\n            removeGlobalListener(value1.eventTarget, value1.type, key, value1.options);\n        });\n    }, [\n        removeGlobalListener\n    ]);\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return removeAllGlobalListeners;\n    }, [\n        removeAllGlobalListeners\n    ]);\n    return {\n        addGlobalListener: addGlobalListener,\n        removeGlobalListener: removeGlobalListener,\n        removeAllGlobalListeners: removeAllGlobalListeners\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $313b98861ee5dd6c$export$d6875122194c7b44(props, defaultLabel) {\n    let { id: id, \"aria-label\": label, \"aria-labelledby\": labelledBy } = props;\n    // If there is both an aria-label and aria-labelledby,\n    // combine them by pointing to the element itself.\n    id = (0, $bdb11010cef70236$export$f680877a34711e37)(id);\n    if (labelledBy && label) {\n        let ids = new Set([\n            id,\n            ...labelledBy.trim().split(/\\s+/)\n        ]);\n        labelledBy = [\n            ...ids\n        ].join(\" \");\n    } else if (labelledBy) labelledBy = labelledBy.trim().split(/\\s+/).join(\" \");\n    // If no labels are provided, use the default\n    if (!label && !labelledBy && defaultLabel) label = defaultLabel;\n    return {\n        id: id,\n        \"aria-label\": label,\n        \"aria-labelledby\": labelledBy\n    };\n}\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $df56164dff5785e2$export$4338b53315abf666(forwardedRef) {\n    const objRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            get current () {\n                return objRef.current;\n            },\n            set current (value){\n                objRef.current = value;\n                if (typeof forwardedRef === \"function\") forwardedRef(value);\n                else if (forwardedRef) forwardedRef.current = value;\n            }\n        }), [\n        forwardedRef\n    ]);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $4f58c5f72bcf79f7$export$496315a1608d9602(effect, dependencies) {\n    const isInitialMount = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const lastDeps = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        isInitialMount.current = true;\n        return ()=>{\n            isInitialMount.current = false;\n        };\n    }, []);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isInitialMount.current) isInitialMount.current = false;\n        else if (!lastDeps.current || dependencies.some((dep, i)=>!Object.is(dep, lastDeps[i]))) effect();\n        lastDeps.current = dependencies;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, dependencies);\n}\nfunction $9daab02d461809db$var$hasResizeObserver() {\n    return typeof window.ResizeObserver !== \"undefined\";\n}\nfunction $9daab02d461809db$export$683480f191c0e3ea(options) {\n    const { ref: ref, onResize: onResize } = options;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let element = ref === null || ref === void 0 ? void 0 : ref.current;\n        if (!element) return;\n        if (!$9daab02d461809db$var$hasResizeObserver()) {\n            window.addEventListener(\"resize\", onResize, false);\n            return ()=>{\n                window.removeEventListener(\"resize\", onResize, false);\n            };\n        } else {\n            const resizeObserverInstance = new window.ResizeObserver((entries)=>{\n                if (!entries.length) return;\n                onResize();\n            });\n            resizeObserverInstance.observe(element);\n            return ()=>{\n                if (element) resizeObserverInstance.unobserve(element);\n            };\n        }\n    }, [\n        onResize,\n        ref\n    ]);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $e7801be82b4b2a53$export$4debdb1a3f0fa79e(context, ref) {\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        if (context && context.ref && ref) {\n            context.ref.current = ref.current;\n            return ()=>{\n                context.ref.current = null;\n            };\n        }\n    });\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $62d8ded9296f3872$export$cfa2225e87938781(node) {\n    if ($62d8ded9296f3872$export$2bb74740c4e19def(node)) node = node.parentElement;\n    while(node && !$62d8ded9296f3872$export$2bb74740c4e19def(node))node = node.parentElement;\n    return node || document.scrollingElement || document.documentElement;\n}\nfunction $62d8ded9296f3872$export$2bb74740c4e19def(node) {\n    let style = window.getComputedStyle(node);\n    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // @ts-ignore\nlet $5df64b3807dc15ee$var$visualViewport = typeof document !== \"undefined\" && window.visualViewport;\nfunction $5df64b3807dc15ee$export$d699905dd57c73ca() {\n    let isSSR = (0, _react_aria_ssr__WEBPACK_IMPORTED_MODULE_2__.useIsSSR)();\n    let [size, setSize] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>isSSR ? {\n            width: 0,\n            height: 0\n        } : $5df64b3807dc15ee$var$getViewportSize());\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Use visualViewport api to track available height even on iOS virtual keyboard opening\n        let onResize = ()=>{\n            setSize((size)=>{\n                let newSize = $5df64b3807dc15ee$var$getViewportSize();\n                if (newSize.width === size.width && newSize.height === size.height) return size;\n                return newSize;\n            });\n        };\n        if (!$5df64b3807dc15ee$var$visualViewport) window.addEventListener(\"resize\", onResize);\n        else $5df64b3807dc15ee$var$visualViewport.addEventListener(\"resize\", onResize);\n        return ()=>{\n            if (!$5df64b3807dc15ee$var$visualViewport) window.removeEventListener(\"resize\", onResize);\n            else $5df64b3807dc15ee$var$visualViewport.removeEventListener(\"resize\", onResize);\n        };\n    }, []);\n    return size;\n}\nfunction $5df64b3807dc15ee$var$getViewportSize() {\n    return {\n        width: ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.width) || window.innerWidth,\n        height: ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.height) || window.innerHeight\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $ef06256079686ba0$var$descriptionId = 0;\nconst $ef06256079686ba0$var$descriptionNodes = new Map();\nfunction $ef06256079686ba0$export$f8aeda7b10753fa1(description) {\n    let [id, setId] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(undefined);\n    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{\n        if (!description) return;\n        let desc = $ef06256079686ba0$var$descriptionNodes.get(description);\n        if (!desc) {\n            let id = `react-aria-description-${$ef06256079686ba0$var$descriptionId++}`;\n            setId(id);\n            let node = document.createElement(\"div\");\n            node.id = id;\n            node.style.display = \"none\";\n            node.textContent = description;\n            document.body.appendChild(node);\n            desc = {\n                refCount: 0,\n                element: node\n            };\n            $ef06256079686ba0$var$descriptionNodes.set(description, desc);\n        } else setId(desc.element.id);\n        desc.refCount++;\n        return ()=>{\n            if (--desc.refCount === 0) {\n                desc.element.remove();\n                $ef06256079686ba0$var$descriptionNodes.delete(description);\n            }\n        };\n    }, [\n        description\n    ]);\n    return {\n        \"aria-describedby\": description ? id : undefined\n    };\n}\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $e9faafb641e167db$export$90fc3a17d93f704c(ref, event, handler, options) {\n    let handleEvent = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(handler);\n    let isDisabled = handler == null;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isDisabled) return;\n        let element = ref.current;\n        element.addEventListener(event, handleEvent, options);\n        return ()=>{\n            element.removeEventListener(event, handleEvent, options);\n        };\n    }, [\n        ref,\n        event,\n        options,\n        isDisabled,\n        handleEvent\n    ]);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $2f04cbc44ee30ce0$export$53a0910f038337bd(scrollView, element) {\n    let offsetX = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element, \"left\");\n    let offsetY = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element, \"top\");\n    let width = element.offsetWidth;\n    let height = element.offsetHeight;\n    let x = scrollView.scrollLeft;\n    let y = scrollView.scrollTop;\n    // Account for top/left border offsetting the scroll top/Left\n    let { borderTopWidth: borderTopWidth, borderLeftWidth: borderLeftWidth } = getComputedStyle(scrollView);\n    let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);\n    let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);\n    // Ignore end/bottom border via clientHeight/Width instead of offsetHeight/Width\n    let maxX = borderAdjustedX + scrollView.clientWidth;\n    let maxY = borderAdjustedY + scrollView.clientHeight;\n    if (offsetX <= x) x = offsetX - parseInt(borderLeftWidth, 10);\n    else if (offsetX + width > maxX) x += offsetX + width - maxX;\n    if (offsetY <= borderAdjustedY) y = offsetY - parseInt(borderTopWidth, 10);\n    else if (offsetY + height > maxY) y += offsetY + height - maxY;\n    scrollView.scrollLeft = x;\n    scrollView.scrollTop = y;\n}\n/**\n * Computes the offset left or top from child to ancestor by accumulating\n * offsetLeft or offsetTop through intervening offsetParents.\n */ function $2f04cbc44ee30ce0$var$relativeOffset(ancestor, child, axis) {\n    const prop = axis === \"left\" ? \"offsetLeft\" : \"offsetTop\";\n    let sum = 0;\n    while(child.offsetParent){\n        sum += child[prop];\n        if (child.offsetParent === ancestor) break;\n        else if (child.offsetParent.contains(ancestor)) {\n            // If the ancestor is not `position:relative`, then we stop at\n            // _its_ offset parent, and we subtract off _its_ offset, so that\n            // we end up with the proper offset from child to ancestor.\n            sum -= ancestor[prop];\n            break;\n        }\n        child = child.offsetParent;\n    }\n    return sum;\n}\nfunction $2f04cbc44ee30ce0$export$c826860796309d1b(targetElement, opts) {\n    if (document.contains(targetElement)) {\n        let root = document.scrollingElement || document.documentElement;\n        let isScrollPrevented = window.getComputedStyle(root).overflow === \"hidden\";\n        // If scrolling is not currently prevented then we aren’t in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view\n        if (!isScrollPrevented) {\n            var // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically\n            _targetElement_scrollIntoView;\n            let { left: originalLeft, top: originalTop } = targetElement.getBoundingClientRect();\n            targetElement === null || targetElement === void 0 ? void 0 : (_targetElement_scrollIntoView = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView === void 0 ? void 0 : _targetElement_scrollIntoView.call(targetElement, {\n                block: \"nearest\"\n            });\n            let { left: newLeft, top: newTop } = targetElement.getBoundingClientRect();\n            // Account for sub pixel differences from rounding\n            if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {\n                var _opts_containingElement_scrollIntoView, _opts_containingElement, _targetElement_scrollIntoView1;\n                opts === null || opts === void 0 ? void 0 : (_opts_containingElement = opts.containingElement) === null || _opts_containingElement === void 0 ? void 0 : (_opts_containingElement_scrollIntoView = _opts_containingElement.scrollIntoView) === null || _opts_containingElement_scrollIntoView === void 0 ? void 0 : _opts_containingElement_scrollIntoView.call(_opts_containingElement, {\n                    block: \"center\",\n                    inline: \"center\"\n                });\n                (_targetElement_scrollIntoView1 = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView1 === void 0 ? void 0 : _targetElement_scrollIntoView1.call(targetElement, {\n                    block: \"nearest\"\n                });\n            }\n        } else {\n            let scrollParent = (0, $62d8ded9296f3872$export$cfa2225e87938781)(targetElement);\n            // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.\n            while(targetElement && scrollParent && targetElement !== root && scrollParent !== root){\n                $2f04cbc44ee30ce0$export$53a0910f038337bd(scrollParent, targetElement);\n                targetElement = scrollParent;\n                scrollParent = (0, $62d8ded9296f3872$export$cfa2225e87938781)(targetElement);\n            }\n        }\n    }\n}\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $6a7db85432448f7f$export$60278871457622de(event) {\n    // JAWS/NVDA with Firefox.\n    if (event.mozInputSource === 0 && event.isTrusted) return true;\n    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead\n    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check\n    // to detect TalkBack virtual clicks.\n    if ((0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.pointerType) return event.type === \"click\" && event.buttons === 1;\n    return event.detail === 0 && !event.pointerType;\n}\nfunction $6a7db85432448f7f$export$29bf1b5f2c56cf63(event) {\n    // If the pointer size is zero, then we assume it's from a screen reader.\n    // Android TalkBack double tap will sometimes return a event with width and height of 1\n    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.\n    // Cannot use \"event.pressure === 0\" as the sole check due to Safari pointer events always returning pressure === 0\n    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush\n    // Talkback double tap from Windows Firefox touch screen press\n    return !(0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === \"mouse\";\n}\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /* eslint-disable rulesdir/pure-render */ function $5a387cc49350e6db$export$722debc0e56fea39(value1, isEqual) {\n    // Using a ref during render is ok here because it's only an optimization – both values are equivalent.\n    // If a render is thrown away, it'll still work the same no matter if the next render is the same or not.\n    let lastValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    if (value1 && lastValue.current && isEqual(value1, lastValue.current)) value1 = lastValue.current;\n    lastValue.current = value1;\n    return value1;\n}\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $99facab73266f662$export$5add1d006293d136(ref, initialValue, onReset) {\n    let resetValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialValue);\n    let handleReset = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(()=>{\n        if (onReset) onReset(resetValue.current);\n    });\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _ref_current;\n        let form = ref === null || ref === void 0 ? void 0 : (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.form;\n        form === null || form === void 0 ? void 0 : form.addEventListener(\"reset\", handleReset);\n        return ()=>{\n            form === null || form === void 0 ? void 0 : form.removeEventListener(\"reset\", handleReset);\n        };\n    }, [\n        ref,\n        handleReset\n    ]);\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdXRpbHMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0o7QUFDOEc7QUFDN0o7QUFDbEU7QUFFL0I7Ozs7Ozs7Ozs7Q0FVQyxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FDRDs7Ozs7Ozs7OztDQVVDLEdBQ0QsTUFBTXdCLDRDQUE0QyxPQUFPQyxhQUFhLGNBQWMsQ0FBQyxHQUFHckIsa0NBQVcsRUFBR3NCLGVBQWUsR0FBRyxLQUFLO0FBSTdIOzs7Ozs7Ozs7O0NBVUMsR0FDRDs7Ozs7Ozs7OztDQVVDLEdBRUQsU0FBU0MsMENBQTBDQyxFQUFFO0lBQ2pELE1BQU1DLE1BQU0sQ0FBQyxHQUFHckIseUNBQVksRUFBRztJQUM5QixJQUFHZ0IseUNBQXdDLEVBQUc7UUFDM0NLLElBQUlDLE9BQU8sR0FBR0Y7SUFDbEIsR0FBRztRQUNDQTtLQUNIO0lBQ0QsYUFBYTtJQUNiLE9BQU8sQ0FBQyxHQUFHbEIsOENBQWlCLEVBQUcsQ0FBQyxHQUFHcUI7UUFDL0IsTUFBTUMsSUFBSUgsSUFBSUMsT0FBTztRQUNyQixPQUFPRSxLQUFLRDtJQUNoQixHQUFHLEVBQUU7QUFDVDtBQUdBLFNBQVNFLDBDQUEwQ0MsWUFBWTtJQUMzRCxJQUFJLENBQUNDLFFBQU9DLFNBQVMsR0FBRyxDQUFDLEdBQUc5QiwyQ0FBYyxFQUFHNEI7SUFDN0MsSUFBSUcsU0FBUyxDQUFDLEdBQUc3Qix5Q0FBWSxFQUFHO0lBQ2hDLDBFQUEwRTtJQUMxRSx5Q0FBeUM7SUFDekMsSUFBSThCLFVBQVUsQ0FBQyxHQUFHWCx5Q0FBd0MsRUFBRztRQUN6RCx1Q0FBdUM7UUFDdkMsSUFBSVksV0FBV0YsT0FBT1AsT0FBTyxDQUFDVSxJQUFJO1FBQ2xDLDhDQUE4QztRQUM5QyxJQUFJRCxTQUFTRSxJQUFJLEVBQUU7WUFDZkosT0FBT1AsT0FBTyxH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LHlDQUFZLEVBQUc7SUFDbkMsSUFBSTJCLFVBQVNrVyxVQUFVdlcsT0FBTyxJQUFJc1csUUFBUWpXLFFBQU9rVyxVQUFVdlcsT0FBTyxHQUFHSyxTQUFRa1csVUFBVXZXLE9BQU87SUFDOUZ1VyxVQUFVdlcsT0FBTyxHQUFHSztJQUNwQixPQUFPQTtBQUNYO0FBR0E7Ozs7Ozs7Ozs7Q0FVQyxHQUVELFNBQVNtVywwQ0FBMEN6VyxHQUFHLEVBQUUwVyxZQUFZLEVBQUVDLE9BQU87SUFDekUsSUFBSUMsYUFBYSxDQUFDLEdBQUdqWSx5Q0FBWSxFQUFHK1g7SUFDcEMsSUFBSUcsY0FBYyxDQUFDLEdBQUcvVyx5Q0FBd0MsRUFBRztRQUM3RCxJQUFJNlcsU0FBU0EsUUFBUUMsV0FBVzNXLE9BQU87SUFDM0M7SUFDQyxJQUFHbEIsNENBQWUsRUFBRztRQUNsQixJQUFJK1g7UUFDSixJQUFJQyxPQUFPL1csUUFBUSxRQUFRQSxRQUFRLEtBQUssSUFBSSxLQUFLLElBQUksQ0FBQzhXLGVBQWU5VyxJQUFJQyxPQUFPLE1BQU0sUUFBUTZXLGlCQUFpQixLQUFLLElBQUksS0FBSyxJQUFJQSxhQUFhQyxJQUFJO1FBQ2xKQSxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBS2pMLGdCQUFnQixDQUFDLFNBQVMrSztRQUMzRSxPQUFPO1lBQ0hFLFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLM0ssbUJBQW1CLENBQUMsU0FBU3lLO1FBQ2xGO0lBQ0osR0FBRztRQUNDN1c7UUFDQTZXO0tBQ0g7QUFDTDtBQUtveEYsQ0FDcHhGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaWNlZmV0Y2gvLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdXRpbHMvZGlzdC9pbXBvcnQubWpzPzQ0OTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtjbGFtcCBhcyAkNDUwNzQ2MWExYjg3MDEyMyRyZV9leHBvcnQkY2xhbXAsIHNuYXBWYWx1ZVRvU3RlcCBhcyAkNDUwNzQ2MWExYjg3MDEyMyRyZV9leHBvcnQkc25hcFZhbHVlVG9TdGVwfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcbmltcG9ydCAkMTJ1R3AkcmVhY3QsIHt1c2VTdGF0ZSBhcyAkMTJ1R3AkdXNlU3RhdGUsIHVzZVJlZiBhcyAkMTJ1R3AkdXNlUmVmLCB1c2VDYWxsYmFjayBhcyAkMTJ1R3AkdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCBhcyAkMTJ1R3AkdXNlRWZmZWN0LCBjcmVhdGVDb250ZXh0IGFzICQxMnVHcCRjcmVhdGVDb250ZXh0LCB1c2VNZW1vIGFzICQxMnVHcCR1c2VNZW1vLCB1c2VDb250ZXh0IGFzICQxMnVHcCR1c2VDb250ZXh0fSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7dXNlU1NSU2FmZUlkIGFzICQxMnVHcCR1c2VTU1JTYWZlSWQsIHVzZUlzU1NSIGFzICQxMnVHcCR1c2VJc1NTUn0gZnJvbSBcIkByZWFjdC1hcmlhL3NzclwiO1xuaW1wb3J0ICQxMnVHcCRjbHN4IGZyb20gXCJjbHN4XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5jb25zdCAkZjBhMDRjY2Q4ZGJkZDgzYiRleHBvcnQkZTVjNWE1ZjkxN2E1ODcxYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/ICgwLCAkMTJ1R3AkcmVhY3QpLnVzZUxheW91dEVmZmVjdCA6ICgpPT57fTtcblxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuZnVuY3Rpb24gJDhhZTA1ZWFhNWMxMTRlOWMkZXhwb3J0JDdmNTRmYzMxODA1MDhhNTIoZm4pIHtcbiAgICBjb25zdCByZWYgPSAoMCwgJDEydUdwJHVzZVJlZikobnVsbCk7XG4gICAgKDAsICRmMGEwNGNjZDhkYmRkODNiJGV4cG9ydCRlNWM1YTVmOTE3YTU4NzFjKSgoKT0+e1xuICAgICAgICByZWYuY3VycmVudCA9IGZuO1xuICAgIH0sIFtcbiAgICAgICAgZm5cbiAgICBdKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuICgwLCAkMTJ1R3AkdXNlQ2FsbGJhY2spKCguLi5hcmdzKT0+e1xuICAgICAgICBjb25zdCBmID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIHJldHVybiBmKC4uLmFyZ3MpO1xuICAgIH0sIFtdKTtcbn1cblxuXG5mdW5jdGlvbiAkMWRiZWNiZTI3YTA0ZjlhZiRleHBvcnQkMTRkMjM4ZjM0MjcyM2YyNShkZWZhdWx0VmFsdWUpIHtcbiAgICBsZXQgW3ZhbHVlLCBzZXRWYWx1ZV0gPSAoMCwgJDEydUdwJHVzZVN0YXRlKShkZWZhdWx0VmFsdWUpO1xuICAgIGxldCBlZmZlY3QgPSAoMCwgJDEydUdwJHVzZVJlZikobnVsbCk7XG4gICAgLy8gU3RvcmUgdGhlIGZ1bmN0aW9uIGluIGEgcmVmIHNvIHdlIGNhbiBhbHdheXMgYWNjZXNzIHRoZSBjdXJyZW50IHZlcnNpb25cbiAgICAvLyB3aGljaCBoYXMgdGhlIHByb3BlciBgdmFsdWVgIGluIHNjb3BlLlxuICAgIGxldCBuZXh0UmVmID0gKDAsICQ4YWUwNWVhYTVjMTE0ZTljJGV4cG9ydCQ3ZjU0ZmMzMTgwNTA4YTUyKSgoKT0+e1xuICAgICAgICAvLyBSdW4gdGhlIGdlbmVyYXRvciB0byB0aGUgbmV4dCB5aWVsZC5cbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gZWZmZWN0LmN1cnJlbnQubmV4dCgpO1xuICAgICAgICAvLyBJZiB0aGUgZ2VuZXJhdG9yIGlzIGRvbmUsIHJlc2V0IHRoZSBlZmZlY3QuXG4gICAgICAgIGlmIChuZXdWYWx1ZS5kb25lKSB7XG4gICAgICAgICAgICBlZmZlY3QuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50IHZhbHVlLFxuICAgICAgICAvLyB0aGVuIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHlpZWxkLiBPdGhlcndpc2UsXG4gICAgICAgIC8vIHNldCB0aGUgdmFsdWUgaW4gc3RhdGUgYW5kIHdhaXQgZm9yIHRoZSBuZXh0IGxheW91dCBlZmZlY3QuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbmV3VmFsdWUudmFsdWUpIG5leHRSZWYoKTtcbiAgICAgICAgZWxzZSBzZXRWYWx1ZShuZXdWYWx1ZS52YWx1ZSk7XG4gICAgfSk7XG4gICAgKDAsICRmMGEwNGNjZDhkYmRkODNiJGV4cG9ydCRlNWM1YTVmOTE3YTU4NzFjKSgoKT0+e1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBlZmZlY3QgY3VycmVudGx5IHJ1bm5pbmcsIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHlpZWxkLlxuICAgICAgICBpZiAoZWZmZWN0LmN1cnJlbnQpIG5leHRSZWYoKTtcbiAgICB9KTtcbiAgICBsZXQgcXVldWUgPSAoMCwgJDhhZTA1ZWFhNWMxMTRlOWMkZXhwb3J0JDdmNTRmYzMxODA1MDhhNTIpKChmbik9PntcbiAgICAgICAgZWZmZWN0LmN1cnJlbnQgPSBmbih2YWx1ZSk7XG4gICAgICAgIG5leHRSZWYoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgcXVldWVcbiAgICBdO1xufVxuXG5cbi8vIGNvcGllZCBmcm9tIFNTUlByb3ZpZGVyLnRzeCB0byByZWR1Y2UgZXhwb3J0cywgaWYgbmVlZGVkIGFnYWluLCBjb25zaWRlciBzaGFyaW5nXG5sZXQgJGJkYjExMDEwY2VmNzAyMzYkdmFyJGNhblVzZURPTSA9IEJvb2xlYW4odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubGV0ICRiZGIxMTAxMGNlZjcwMjM2JHZhciRpZHNVcGRhdGVyTWFwID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gJGJkYjExMDEwY2VmNzAyMzYkZXhwb3J0JGY2ODA4NzdhMzQ3MTFlMzcoZGVmYXVsdElkKSB7XG4gICAgbGV0IFt2YWx1ZSwgc2V0VmFsdWVdID0gKDAsICQxMnVHcCR1c2VTdGF0ZSkoZGVmYXVsdElkKTtcbiAgICBsZXQgbmV4dElkID0gKDAsICQxMnVHcCR1c2VSZWYpKG51bGwpO1xuICAgIGxldCByZXMgPSAoMCwgJDEydUdwJHVzZVNTUlNhZmVJZCkodmFsdWUpO1xuICAgIGxldCB1cGRhdGVWYWx1ZSA9ICgwLCAkMTJ1R3AkdXNlQ2FsbGJhY2spKCh2YWwpPT57XG4gICAgICAgIG5leHRJZC5jdXJyZW50ID0gdmFsO1xuICAgIH0sIFtdKTtcbiAgICBpZiAoJGJkYjExMDEwY2VmNzAyMzYkdmFyJGNhblVzZURPTSkgJGJkYjExMDEwY2VmNzAyMzYkdmFyJGlkc1VwZGF0ZXJNYXAuc2V0KHJlcywgdXBkYXRlVmFsdWUpO1xuICAgICgwLCAkZjBhMDRjY2Q4ZGJkZDgzYiRleHBvcnQkZTVjNWE1ZjkxN2E1ODcxYykoKCk9PntcbiAgICAgICAgbGV0IHIgPSByZXM7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgJGJkYjExMDEwY2VmNzAyMzYkdmFyJGlkc1VwZGF0ZXJNYXAuZGVsZXRlKHIpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgcmVzXG4gICAgXSk7XG4gICAgLy8gVGhpcyBjYW5ub3QgY2F1c2UgYW4gaW5maW5pdGUgbG9vcCBiZWNhdXNlIHRoZSByZWYgaXMgdXBkYXRlZCBmaXJzdC5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAoMCwgJDEydUdwJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgbGV0IG5ld0lkID0gbmV4dElkLmN1cnJlbnQ7XG4gICAgICAgIGlmIChuZXdJZCkge1xuICAgICAgICAgICAgbmV4dElkLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgc2V0VmFsdWUobmV3SWQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uICRiZGIxMTAxMGNlZjcwMjM2JGV4cG9ydCRjZDhjOWNiNjhmODQyNjI5KGlkQSwgaWRCKSB7XG4gICAgaWYgKGlkQSA9PT0gaWRCKSByZXR1cm4gaWRBO1xuICAgIGxldCBzZXRJZEEgPSAkYmRiMTEwMTBjZWY3MDIzNiR2YXIkaWRzVXBkYXRlck1hcC5nZXQoaWRBKTtcbiAgICBpZiAoc2V0SWRBKSB7XG4gICAgICAgIHNldElkQShpZEIpO1xuICAgICAgICByZXR1cm4gaWRCO1xuICAgIH1cbiAgICBsZXQgc2V0SWRCID0gJGJkYjExMDEwY2VmNzAyMzYkdmFyJGlkc1VwZGF0ZXJNYXAuZ2V0KGlkQik7XG4gICAgaWYgKHNldElkQikge1xuICAgICAgICBzZXRJZEIoaWRBKTtcbiAgICAgICAgcmV0dXJuIGlkQTtcbiAgICB9XG4gICAgcmV0dXJuIGlkQjtcbn1cbmZ1bmN0aW9uICRiZGIxMTAxMGNlZjcwMjM2JGV4cG9ydCRiNGNjMDljNTkyZThmZGI4KGRlcEFycmF5ID0gW10pIHtcbiAgICBsZXQgaWQgPSAkYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkZjY4MDg3N2EzNDcxMWUzNygpO1xuICAgIGxldCBbcmVzb2x2ZWRJZCwgc2V0UmVzb2x2ZWRJZF0gPSAoMCwgJDFkYmVjYmUyN2EwNGY5YWYkZXhwb3J0JDE0ZDIzOGYzNDI3MjNmMjUpKGlkKTtcbiAgICBsZXQgdXBkYXRlSWQgPSAoMCwgJDEydUdwJHVzZUNhbGxiYWNrKSgoKT0+e1xuICAgICAgICBzZXRSZXNvbHZlZElkKGZ1bmN0aW9uKigpIHtcbiAgICAgICAgICAgIHlpZWxkIGlkO1xuICAgICAgICAgICAgeWllbGQgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpID8gaWQgOiB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgaWQsXG4gICAgICAgIHNldFJlc29sdmVkSWRcbiAgICBdKTtcbiAgICAoMCwgJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMpKHVwZGF0ZUlkLCBbXG4gICAgICAgIGlkLFxuICAgICAgICB1cGRhdGVJZCxcbiAgICAgICAgLi4uZGVwQXJyYXlcbiAgICBdKTtcbiAgICByZXR1cm4gcmVzb2x2ZWRJZDtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLyoqXG4gKiBDYWxscyBhbGwgZnVuY3Rpb25zIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgY2hhaW5lZCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50cy5cbiAqLyBmdW5jdGlvbiAkZmY1OTYzZWIxZmNjZjU1MiRleHBvcnQkZTA4ZTNiNjdlMzkyMTAxZSguLi5jYWxsYmFja3MpIHtcbiAgICByZXR1cm4gKC4uLmFyZ3MpPT57XG4gICAgICAgIGZvciAobGV0IGNhbGxiYWNrIG9mIGNhbGxiYWNrcylpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgIH07XG59XG5cblxuY29uc3QgJDQzMWZiZDg2Y2E3ZGMyMTYkZXhwb3J0JGIyMDRhZjE1ODA0MmZiYWMgPSAoZWwpPT57XG4gICAgdmFyIF9lbF9vd25lckRvY3VtZW50O1xuICAgIHJldHVybiAoX2VsX293bmVyRG9jdW1lbnQgPSBlbCA9PT0gbnVsbCB8fCBlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWwub3duZXJEb2N1bWVudCkgIT09IG51bGwgJiYgX2VsX293bmVyRG9jdW1lbnQgIT09IHZvaWQgMCA/IF9lbF9vd25lckRvY3VtZW50IDogZG9jdW1lbnQ7XG59O1xuY29uc3QgJDQzMWZiZDg2Y2E3ZGMyMTYkZXhwb3J0JGYyMWExZmZhZTI2MDE0NWEgPSAoZWwpPT57XG4gICAgaWYgKGVsICYmIFwid2luZG93XCIgaW4gZWwgJiYgZWwud2luZG93ID09PSBlbCkgcmV0dXJuIGVsO1xuICAgIGNvbnN0IGRvYyA9ICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRiMjA0YWYxNTgwNDJmYmFjKGVsKTtcbiAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbn07XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5cbmZ1bmN0aW9uICQzZWY0MjU3NWRmODRiMzBiJGV4cG9ydCQ5ZDE2MTFjNzdjMmZlOTI4KC4uLmFyZ3MpIHtcbiAgICAvLyBTdGFydCB3aXRoIGEgYmFzZSBjbG9uZSBvZiB0aGUgZmlyc3QgYXJndW1lbnQuIFRoaXMgaXMgYSBsb3QgZmFzdGVyIHRoYW4gc3RhcnRpbmdcbiAgICAvLyB3aXRoIGFuIGVtcHR5IG9iamVjdCBhbmQgYWRkaW5nIHByb3BlcnRpZXMgYXMgd2UgZ28uXG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgLi4uYXJnc1swXVxuICAgIH07XG4gICAgZm9yKGxldCBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspe1xuICAgICAgICBsZXQgcHJvcHMgPSBhcmdzW2ldO1xuICAgICAgICBmb3IobGV0IGtleSBpbiBwcm9wcyl7XG4gICAgICAgICAgICBsZXQgYSA9IHJlc3VsdFtrZXldO1xuICAgICAgICAgICAgbGV0IGIgPSBwcm9wc1trZXldO1xuICAgICAgICAgICAgLy8gQ2hhaW4gZXZlbnRzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGEgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgYiA9PT0gXCJmdW5jdGlvblwiICYmIC8vIFRoaXMgaXMgYSBsb3QgZmFzdGVyIHRoYW4gYSByZWdleC5cbiAgICAgICAgICAgIGtleVswXSA9PT0gXCJvXCIgJiYga2V5WzFdID09PSBcIm5cIiAmJiBrZXkuY2hhckNvZGVBdCgyKSA+PSAvKiAnQScgKi8gNjUgJiYga2V5LmNoYXJDb2RlQXQoMikgPD0gLyogJ1onICovIDkwKSByZXN1bHRba2V5XSA9ICgwLCAkZmY1OTYzZWIxZmNjZjU1MiRleHBvcnQkZTA4ZTNiNjdlMzkyMTAxZSkoYSwgYik7XG4gICAgICAgICAgICBlbHNlIGlmICgoa2V5ID09PSBcImNsYXNzTmFtZVwiIHx8IGtleSA9PT0gXCJVTlNBRkVfY2xhc3NOYW1lXCIpICYmIHR5cGVvZiBhID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBiID09PSBcInN0cmluZ1wiKSByZXN1bHRba2V5XSA9ICgwLCAkMTJ1R3AkY2xzeCkoYSwgYik7XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiaWRcIiAmJiBhICYmIGIpIHJlc3VsdC5pZCA9ICgwLCAkYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkY2Q4YzljYjY4Zjg0MjYyOSkoYSwgYik7XG4gICAgICAgICAgICBlbHNlIHJlc3VsdFtrZXldID0gYiAhPT0gdW5kZWZpbmVkID8gYiA6IGE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJDVkYzk1ODk5YjMwNmY2MzAkZXhwb3J0JGM5MDU4MzE2NzY0YzE0MGUoLi4ucmVmcykge1xuICAgIGlmIChyZWZzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHJlZnNbMF07XG4gICAgcmV0dXJuICh2YWx1ZSk9PntcbiAgICAgICAgZm9yIChsZXQgcmVmIG9mIHJlZnMpe1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikgcmVmKHZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHJlZiAhPSBudWxsKSByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY29uc3QgJDY1NDg0ZDAyZGNiN2ViM2UkdmFyJERPTVByb3BOYW1lcyA9IG5ldyBTZXQoW1xuICAgIFwiaWRcIlxuXSk7XG5jb25zdCAkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkbGFiZWxhYmxlUHJvcE5hbWVzID0gbmV3IFNldChbXG4gICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgXCJhcmlhLWxhYmVsbGVkYnlcIixcbiAgICBcImFyaWEtZGVzY3JpYmVkYnlcIixcbiAgICBcImFyaWEtZGV0YWlsc1wiXG5dKTtcbi8vIFNlZSBMaW5rRE9NUHJvcHMgaW4gZG9tLmQudHMuXG5jb25zdCAkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkbGlua1Byb3BOYW1lcyA9IG5ldyBTZXQoW1xuICAgIFwiaHJlZlwiLFxuICAgIFwidGFyZ2V0XCIsXG4gICAgXCJyZWxcIixcbiAgICBcImRvd25sb2FkXCIsXG4gICAgXCJwaW5nXCIsXG4gICAgXCJyZWZlcnJlclBvbGljeVwiXG5dKTtcbmNvbnN0ICQ2NTQ4NGQwMmRjYjdlYjNlJHZhciRwcm9wUmUgPSAvXihkYXRhLS4qKSQvO1xuZnVuY3Rpb24gJDY1NDg0ZDAyZGNiN2ViM2UkZXhwb3J0JDQ1N2MzZDY1MThkZDRjNmYocHJvcHMsIG9wdHMgPSB7fSkge1xuICAgIGxldCB7IGxhYmVsYWJsZTogbGFiZWxhYmxlLCBpc0xpbms6IGlzTGluaywgcHJvcE5hbWVzOiBwcm9wTmFtZXMgfSA9IG9wdHM7XG4gICAgbGV0IGZpbHRlcmVkUHJvcHMgPSB7fTtcbiAgICBmb3IoY29uc3QgcHJvcCBpbiBwcm9wcylpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wKSAmJiAoJDY1NDg0ZDAyZGNiN2ViM2UkdmFyJERPTVByb3BOYW1lcy5oYXMocHJvcCkgfHwgbGFiZWxhYmxlICYmICQ2NTQ4NGQwMmRjYjdlYjNlJHZhciRsYWJlbGFibGVQcm9wTmFtZXMuaGFzKHByb3ApIHx8IGlzTGluayAmJiAkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkbGlua1Byb3BOYW1lcy5oYXMocHJvcCkgfHwgKHByb3BOYW1lcyA9PT0gbnVsbCB8fCBwcm9wTmFtZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BOYW1lcy5oYXMocHJvcCkpIHx8ICQ2NTQ4NGQwMmRjYjdlYjNlJHZhciRwcm9wUmUudGVzdChwcm9wKSkpIGZpbHRlcmVkUHJvcHNbcHJvcF0gPSBwcm9wc1twcm9wXTtcbiAgICByZXR1cm4gZmlsdGVyZWRQcm9wcztcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJDcyMTVhZmM2ZGU2MDZkNmIkZXhwb3J0JGRlNzllMmM2OTVlMDUyZjMoZWxlbWVudCkge1xuICAgIGlmICgkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkc3VwcG9ydHNQcmV2ZW50U2Nyb2xsKCkpIGVsZW1lbnQuZm9jdXMoe1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgfSk7XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBzY3JvbGxhYmxlRWxlbWVudHMgPSAkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkZ2V0U2Nyb2xsYWJsZUVsZW1lbnRzKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRyZXN0b3JlU2Nyb2xsUG9zaXRpb24oc2Nyb2xsYWJsZUVsZW1lbnRzKTtcbiAgICB9XG59XG5sZXQgJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbENhY2hlZCA9IG51bGw7XG5mdW5jdGlvbiAkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkc3VwcG9ydHNQcmV2ZW50U2Nyb2xsKCkge1xuICAgIGlmICgkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkc3VwcG9ydHNQcmV2ZW50U2Nyb2xsQ2FjaGVkID09IG51bGwpIHtcbiAgICAgICAgJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbENhY2hlZCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGZvY3VzRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBmb2N1c0VsZW0uZm9jdXMoe1xuICAgICAgICAgICAgICAgIGdldCBwcmV2ZW50U2Nyb2xsICgpIHtcbiAgICAgICAgICAgICAgICAgICAgJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbENhY2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElnbm9yZVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkc3VwcG9ydHNQcmV2ZW50U2Nyb2xsQ2FjaGVkO1xufVxuZnVuY3Rpb24gJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJGdldFNjcm9sbGFibGVFbGVtZW50cyhlbGVtZW50KSB7XG4gICAgdmFyIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB2YXIgc2Nyb2xsYWJsZUVsZW1lbnRzID0gW107XG4gICAgdmFyIHJvb3RTY3JvbGxpbmdFbGVtZW50ID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgd2hpbGUocGFyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgcGFyZW50ICE9PSByb290U2Nyb2xsaW5nRWxlbWVudCl7XG4gICAgICAgIGlmIChwYXJlbnQub2Zmc2V0SGVpZ2h0IDwgcGFyZW50LnNjcm9sbEhlaWdodCB8fCBwYXJlbnQub2Zmc2V0V2lkdGggPCBwYXJlbnQuc2Nyb2xsV2lkdGgpIHNjcm9sbGFibGVFbGVtZW50cy5wdXNoKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHBhcmVudCxcbiAgICAgICAgICAgIHNjcm9sbFRvcDogcGFyZW50LnNjcm9sbFRvcCxcbiAgICAgICAgICAgIHNjcm9sbExlZnQ6IHBhcmVudC5zY3JvbGxMZWZ0XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgaWYgKHJvb3RTY3JvbGxpbmdFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHNjcm9sbGFibGVFbGVtZW50cy5wdXNoKHtcbiAgICAgICAgZWxlbWVudDogcm9vdFNjcm9sbGluZ0VsZW1lbnQsXG4gICAgICAgIHNjcm9sbFRvcDogcm9vdFNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wLFxuICAgICAgICBzY3JvbGxMZWZ0OiByb290U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0XG4gICAgfSk7XG4gICAgcmV0dXJuIHNjcm9sbGFibGVFbGVtZW50cztcbn1cbmZ1bmN0aW9uICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRyZXN0b3JlU2Nyb2xsUG9zaXRpb24oc2Nyb2xsYWJsZUVsZW1lbnRzKSB7XG4gICAgZm9yIChsZXQgeyBlbGVtZW50OiBlbGVtZW50LCBzY3JvbGxUb3A6IHNjcm9sbFRvcCwgc2Nyb2xsTGVmdDogc2Nyb2xsTGVmdCB9IG9mIHNjcm9sbGFibGVFbGVtZW50cyl7XG4gICAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICBlbGVtZW50LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgIH1cbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJGFiNzFkYWRiMDNhNmZiMmUkZXhwb3J0JDYyMmNlYTQ0NWExYzViN2QoZWxlbWVudCwgcmV2ZXJzZSwgb3JpZW50YXRpb24gPSBcImhvcml6b250YWxcIikge1xuICAgIGxldCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAocmV2ZXJzZSkgcmV0dXJuIG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IHJlY3QucmlnaHQgOiByZWN0LmJvdHRvbTtcbiAgICByZXR1cm4gb3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gcmVjdC5sZWZ0IDogcmVjdC50b3A7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIzIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBmdW5jdGlvbiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFVzZXJBZ2VudChyZSkge1xuICAgIHZhciBfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHdpbmRvdy5uYXZpZ2F0b3IgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAoKF93aW5kb3dfbmF2aWdhdG9yX3VzZXJBZ2VudERhdGEgPSB3aW5kb3cubmF2aWdhdG9yW1widXNlckFnZW50RGF0YVwiXSkgPT09IG51bGwgfHwgX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YS5icmFuZHMuc29tZSgoYnJhbmQpPT5yZS50ZXN0KGJyYW5kLmJyYW5kKSkpIHx8IHJlLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RQbGF0Zm9ybShyZSkge1xuICAgIHZhciBfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhO1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5uYXZpZ2F0b3IgIT0gbnVsbCA/IHJlLnRlc3QoKChfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhID0gd2luZG93Lm5hdmlnYXRvcltcInVzZXJBZ2VudERhdGFcIl0pID09PSBudWxsIHx8IF93aW5kb3dfbmF2aWdhdG9yX3VzZXJBZ2VudERhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93aW5kb3dfbmF2aWdhdG9yX3VzZXJBZ2VudERhdGEucGxhdGZvcm0pIHx8IHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0pIDogZmFsc2U7XG59XG5mdW5jdGlvbiAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkOWFjMTAwZTQwNjEzZWExMCgpIHtcbiAgICByZXR1cm4gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RQbGF0Zm9ybSgvXk1hYy9pKTtcbn1cbmZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQxODZjNjk2NGNhMTdkOTkoKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0UGxhdGZvcm0oL15pUGhvbmUvaSk7XG59XG5mdW5jdGlvbiAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkN2JlZjA0OWNlOTJlNDIyNCgpIHtcbiAgICByZXR1cm4gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RQbGF0Zm9ybSgvXmlQYWQvaSkgfHwgLy8gaVBhZE9TIDEzIGxpZXMgYW5kIHNheXMgaXQncyBhIE1hYywgYnV0IHdlIGNhbiBkaXN0aW5ndWlzaCBieSBkZXRlY3RpbmcgdG91Y2ggc3VwcG9ydC5cbiAgICAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkOWFjMTAwZTQwNjEzZWExMCgpICYmIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDE7XG59XG5mdW5jdGlvbiAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkZmVkYjM2OWNiNzAyMDdmMSgpIHtcbiAgICByZXR1cm4gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDE4NmM2OTY0Y2ExN2Q5OSgpIHx8ICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ3YmVmMDQ5Y2U5MmU0MjI0KCk7XG59XG5mdW5jdGlvbiAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkZTE4NjVjM2JlZGNkODIyYigpIHtcbiAgICByZXR1cm4gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDlhYzEwMGU0MDYxM2VhMTAoKSB8fCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkZmVkYjM2OWNiNzAyMDdmMSgpO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDc4NTUxMDQzNTgyYTZhOTgoKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0VXNlckFnZW50KC9BcHBsZVdlYktpdC9pKSAmJiAhJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDY0NDZhMTg2ZDA5ZTM3OWUoKTtcbn1cbmZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ2NDQ2YTE4NmQwOWUzNzllKCkge1xuICAgIHJldHVybiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFVzZXJBZ2VudCgvQ2hyb21lL2kpO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGExMWIwMDU5OTAwY2VlYzgoKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0VXNlckFnZW50KC9BbmRyb2lkL2kpO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGI3ZDc4OTkzYjc0Zjc2NmQoKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0VXNlckFnZW50KC9GaXJlZm94L2kpO1xufVxuXG5cblxuXG5jb25zdCAkZWE4ZGNiY2I5ZWExYjU1NiR2YXIkUm91dGVyQ29udGV4dCA9IC8qI19fUFVSRV9fKi8gKDAsICQxMnVHcCRjcmVhdGVDb250ZXh0KSh7XG4gICAgaXNOYXRpdmU6IHRydWUsXG4gICAgb3BlbjogJGVhOGRjYmNiOWVhMWI1NTYkdmFyJG9wZW5TeW50aGV0aWNMaW5rXG59KTtcbmZ1bmN0aW9uICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQzMjNlNGZjMmZhNDc1M2ZiKHByb3BzKSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCBuYXZpZ2F0ZTogbmF2aWdhdGUgfSA9IHByb3BzO1xuICAgIGxldCBjdHggPSAoMCwgJDEydUdwJHVzZU1lbW8pKCgpPT4oe1xuICAgICAgICAgICAgaXNOYXRpdmU6IGZhbHNlLFxuICAgICAgICAgICAgb3BlbjogKHRhcmdldCwgbW9kaWZpZXJzKT0+e1xuICAgICAgICAgICAgICAgICRlYThkY2JjYjllYTFiNTU2JHZhciRnZXRTeW50aGV0aWNMaW5rKHRhcmdldCwgKGxpbmspPT57XG4gICAgICAgICAgICAgICAgICAgIGlmICgkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkZWZhOGM5MDk5ZTUzMDIzNShsaW5rLCBtb2RpZmllcnMpKSBuYXZpZ2F0ZShsaW5rLnBhdGhuYW1lICsgbGluay5zZWFyY2ggKyBsaW5rLmhhc2gpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5NTE4NWQ2OTllMDVkNGQ3KGxpbmssIG1vZGlmaWVycyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBbXG4gICAgICAgIG5hdmlnYXRlXG4gICAgXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsICQxMnVHcCRyZWFjdCkuY3JlYXRlRWxlbWVudCgkZWE4ZGNiY2I5ZWExYjU1NiR2YXIkUm91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogY3R4XG4gICAgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDlhMzAyYTQ1ZjY1ZDA1NzIoKSB7XG4gICAgcmV0dXJuICgwLCAkMTJ1R3AkdXNlQ29udGV4dCkoJGVhOGRjYmNiOWVhMWI1NTYkdmFyJFJvdXRlckNvbnRleHQpO1xufVxuZnVuY3Rpb24gJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JGVmYThjOTA5OWU1MzAyMzUobGluaywgbW9kaWZpZXJzKSB7XG4gICAgLy8gVXNlIGdldEF0dHJpYnV0ZSBoZXJlIGluc3RlYWQgb2YgbGluay50YXJnZXQuIEZpcmVmb3ggd2lsbCBkZWZhdWx0IGxpbmsudGFyZ2V0IHRvIFwiX3BhcmVudFwiIHdoZW4gaW5zaWRlIGFuIGlmcmFtZS5cbiAgICBsZXQgdGFyZ2V0ID0gbGluay5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIik7XG4gICAgcmV0dXJuICghdGFyZ2V0IHx8IHRhcmdldCA9PT0gXCJfc2VsZlwiKSAmJiBsaW5rLm9yaWdpbiA9PT0gbG9jYXRpb24ub3JpZ2luICYmICFsaW5rLmhhc0F0dHJpYnV0ZShcImRvd25sb2FkXCIpICYmICFtb2RpZmllcnMubWV0YUtleSAmJiAvLyBvcGVuIGluIG5ldyB0YWIgKG1hYylcbiAgICAhbW9kaWZpZXJzLmN0cmxLZXkgJiYgLy8gb3BlbiBpbiBuZXcgdGFiICh3aW5kb3dzKVxuICAgICFtb2RpZmllcnMuYWx0S2V5ICYmIC8vIGRvd25sb2FkXG4gICAgIW1vZGlmaWVycy5zaGlmdEtleTtcbn1cbmZ1bmN0aW9uICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5NTE4NWQ2OTllMDVkNGQ3KHRhcmdldCwgbW9kaWZpZXJzLCBzZXRPcGVuaW5nID0gdHJ1ZSkge1xuICAgIHZhciBfd2luZG93X2V2ZW50X3R5cGUsIF93aW5kb3dfZXZlbnQ7XG4gICAgbGV0IHsgbWV0YUtleTogbWV0YUtleSwgY3RybEtleTogY3RybEtleSwgYWx0S2V5OiBhbHRLZXksIHNoaWZ0S2V5OiBzaGlmdEtleSB9ID0gbW9kaWZpZXJzO1xuICAgIC8vIEZpcmVmb3ggZG9lcyBub3QgcmVjb2duaXplIGtleWJvYXJkIGV2ZW50cyBhcyBhIHVzZXIgYWN0aW9uIGJ5IGRlZmF1bHQsIGFuZCB0aGUgcG9wdXAgYmxvY2tlclxuICAgIC8vIHdpbGwgcHJldmVudCBsaW5rcyB3aXRoIHRhcmdldD1cIl9ibGFua1wiIGZyb20gb3BlbmluZy4gSG93ZXZlciwgaXQgZG9lcyBhbGxvdyB0aGUgZXZlbnQgaWYgdGhlXG4gICAgLy8gQ29tbWFuZC9Db250cm9sIGtleSBpcyBoZWxkLCB3aGljaCBvcGVucyB0aGUgbGluayBpbiBhIGJhY2tncm91bmQgdGFiLiBUaGlzIHNlZW1zIGxpa2UgdGhlIGJlc3Qgd2UgY2FuIGRvLlxuICAgIC8vIFNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yNTc4NzAgYW5kIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc0NjY0MC5cbiAgICBpZiAoKDAsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRiN2Q3ODk5M2I3NGY3NjZkKSgpICYmICgoX3dpbmRvd19ldmVudCA9IHdpbmRvdy5ldmVudCkgPT09IG51bGwgfHwgX3dpbmRvd19ldmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF93aW5kb3dfZXZlbnRfdHlwZSA9IF93aW5kb3dfZXZlbnQudHlwZSkgPT09IG51bGwgfHwgX3dpbmRvd19ldmVudF90eXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2luZG93X2V2ZW50X3R5cGUuc3RhcnRzV2l0aChcImtleVwiKSkgJiYgdGFyZ2V0LnRhcmdldCA9PT0gXCJfYmxhbmtcIikge1xuICAgICAgICBpZiAoKDAsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ5YWMxMDBlNDA2MTNlYTEwKSgpKSBtZXRhS2V5ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBjdHJsS2V5ID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gV2ViS2l0IGRvZXMgbm90IHN1cHBvcnQgZmlyaW5nIGNsaWNrIGV2ZW50cyB3aXRoIG1vZGlmaWVyIGtleXMsIGJ1dCBkb2VzIHN1cHBvcnQga2V5Ym9hcmQgZXZlbnRzLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJLaXQvV2ViS2l0L2Jsb2IvYzAzZDBhYzZlNmRiMTc4ZjkwOTIzYTBhNjMwODBiNWNhMjEwZDI1Zi9Tb3VyY2UvV2ViQ29yZS9odG1sL0hUTUxBbmNob3JFbGVtZW50LmNwcCNMMTg0XG4gICAgbGV0IGV2ZW50ID0gKDAsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ3ODU1MTA0MzU4MmE2YTk4KSgpICYmICgwLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkOWFjMTAwZTQwNjEzZWExMCkoKSAmJiAhKDAsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ3YmVmMDQ5Y2U5MmU0MjI0KSgpICYmIHRydWUgPyBuZXcgS2V5Ym9hcmRFdmVudChcImtleWRvd25cIiwge1xuICAgICAgICBrZXlJZGVudGlmaWVyOiBcIkVudGVyXCIsXG4gICAgICAgIG1ldGFLZXk6IG1ldGFLZXksXG4gICAgICAgIGN0cmxLZXk6IGN0cmxLZXksXG4gICAgICAgIGFsdEtleTogYWx0S2V5LFxuICAgICAgICBzaGlmdEtleTogc2hpZnRLZXlcbiAgICB9KSA6IG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIiwge1xuICAgICAgICBtZXRhS2V5OiBtZXRhS2V5LFxuICAgICAgICBjdHJsS2V5OiBjdHJsS2V5LFxuICAgICAgICBhbHRLZXk6IGFsdEtleSxcbiAgICAgICAgc2hpZnRLZXk6IHNoaWZ0S2V5LFxuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDk1MTg1ZDY5OWUwNWQ0ZDcuaXNPcGVuaW5nID0gc2V0T3BlbmluZztcbiAgICAoMCwgJDcyMTVhZmM2ZGU2MDZkNmIkZXhwb3J0JGRlNzllMmM2OTVlMDUyZjMpKHRhcmdldCk7XG4gICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5NTE4NWQ2OTllMDVkNGQ3LmlzT3BlbmluZyA9IGZhbHNlO1xufVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3BhcmNlbC1idW5kbGVyL3BhcmNlbC9pc3N1ZXMvODcyNFxuJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDk1MTg1ZDY5OWUwNWQ0ZDcuaXNPcGVuaW5nID0gZmFsc2U7XG5mdW5jdGlvbiAkZWE4ZGNiY2I5ZWExYjU1NiR2YXIkZ2V0U3ludGhldGljTGluayh0YXJnZXQsIG9wZW4pIHtcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQpIG9wZW4odGFyZ2V0KTtcbiAgICBlbHNlIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlKFwiZGF0YS1ocmVmXCIpKSB7XG4gICAgICAgIGxldCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgIGxpbmsuaHJlZiA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWhyZWZcIik7XG4gICAgICAgIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlKFwiZGF0YS10YXJnZXRcIikpIGxpbmsudGFyZ2V0ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtdGFyZ2V0XCIpO1xuICAgICAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRhdGEtcmVsXCIpKSBsaW5rLnJlbCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlbFwiKTtcbiAgICAgICAgaWYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoXCJkYXRhLWRvd25sb2FkXCIpKSBsaW5rLmRvd25sb2FkID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtZG93bmxvYWRcIik7XG4gICAgICAgIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlKFwiZGF0YS1waW5nXCIpKSBsaW5rLnBpbmcgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1waW5nXCIpO1xuICAgICAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRhdGEtcmVmZXJyZXItcG9saWN5XCIpKSBsaW5rLnJlZmVycmVyUG9saWN5ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtcmVmZXJyZXItcG9saWN5XCIpO1xuICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgICAgIG9wZW4obGluayk7XG4gICAgICAgIHRhcmdldC5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICB9XG59XG5mdW5jdGlvbiAkZWE4ZGNiY2I5ZWExYjU1NiR2YXIkb3BlblN5bnRoZXRpY0xpbmsodGFyZ2V0LCBtb2RpZmllcnMpIHtcbiAgICAkZWE4ZGNiY2I5ZWExYjU1NiR2YXIkZ2V0U3ludGhldGljTGluayh0YXJnZXQsIChsaW5rKT0+JGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDk1MTg1ZDY5OWUwNWQ0ZDcobGluaywgbW9kaWZpZXJzKSk7XG59XG5mdW5jdGlvbiAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkNTE0MzdkNTAzMzczZDIyMyhwcm9wcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIFwiZGF0YS1ocmVmXCI6IHByb3BzLmhyZWYsXG4gICAgICAgIFwiZGF0YS10YXJnZXRcIjogcHJvcHMudGFyZ2V0LFxuICAgICAgICBcImRhdGEtcmVsXCI6IHByb3BzLnJlbCxcbiAgICAgICAgXCJkYXRhLWRvd25sb2FkXCI6IHByb3BzLmRvd25sb2FkLFxuICAgICAgICBcImRhdGEtcGluZ1wiOiBwcm9wcy5waW5nLFxuICAgICAgICBcImRhdGEtcmVmZXJyZXItcG9saWN5XCI6IHByb3BzLnJlZmVycmVyUG9saWN5XG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gV2Ugc3RvcmUgYSBnbG9iYWwgbGlzdCBvZiBlbGVtZW50cyB0aGF0IGFyZSBjdXJyZW50bHkgdHJhbnNpdGlvbmluZyxcbi8vIG1hcHBlZCB0byBhIHNldCBvZiBDU1MgcHJvcGVydGllcyB0aGF0IGFyZSB0cmFuc2l0aW9uaW5nIGZvciB0aGF0IGVsZW1lbnQuXG4vLyBUaGlzIGlzIG5lY2Vzc2FyeSByYXRoZXIgdGhhbiBhIHNpbXBsZSBjb3VudCBvZiB0cmFuc2l0aW9ucyBiZWNhdXNlIG9mIGJyb3dzZXJcbi8vIGJ1Z3MsIGUuZy4gQ2hyb21lIHNvbWV0aW1lcyBmaXJlcyBib3RoIHRyYW5zaXRpb25lbmQgYW5kIHRyYW5zaXRpb25jYW5jZWwgcmF0aGVyXG4vLyB0aGFuIG9uZSBvciB0aGUgb3RoZXIuIFNvIHdlIG5lZWQgdG8gdHJhY2sgd2hhdCdzIGFjdHVhbGx5IHRyYW5zaXRpb25pbmcgc28gdGhhdFxuLy8gd2UgY2FuIGlnbm9yZSB0aGVzZSBkdXBsaWNhdGUgZXZlbnRzLlxubGV0ICRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uc0J5RWxlbWVudCA9IG5ldyBNYXAoKTtcbi8vIEEgbGlzdCBvZiBjYWxsYmFja3MgdG8gY2FsbCBvbmNlIHRoZXJlIGFyZSBubyB0cmFuc2l0aW9uaW5nIGVsZW1lbnRzLlxubGV0ICRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uQ2FsbGJhY2tzID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHNldHVwR2xvYmFsRXZlbnRzKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47XG4gICAgbGV0IG9uVHJhbnNpdGlvblN0YXJ0ID0gKGUpPT57XG4gICAgICAgIC8vIEFkZCB0aGUgdHJhbnNpdGlvbmluZyBwcm9wZXJ0eSB0byB0aGUgbGlzdCBmb3IgdGhpcyBlbGVtZW50LlxuICAgICAgICBsZXQgdHJhbnNpdGlvbnMgPSAkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbnNCeUVsZW1lbnQuZ2V0KGUudGFyZ2V0KTtcbiAgICAgICAgaWYgKCF0cmFuc2l0aW9ucykge1xuICAgICAgICAgICAgdHJhbnNpdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbnNCeUVsZW1lbnQuc2V0KGUudGFyZ2V0LCB0cmFuc2l0aW9ucyk7XG4gICAgICAgICAgICAvLyBUaGUgdHJhbnNpdGlvbmNhbmNlbCBldmVudCBtdXN0IGJlIHJlZ2lzdGVyZWQgb24gdGhlIGVsZW1lbnQgaXRzZWxmLCByYXRoZXIgdGhhbiBhcyBhIGdsb2JhbFxuICAgICAgICAgICAgLy8gZXZlbnQuIFRoaXMgZW5hYmxlcyB1cyB0byBoYW5kbGUgd2hlbiB0aGUgbm9kZSBpcyBkZWxldGVkIGZyb20gdGhlIGRvY3VtZW50IHdoaWxlIGl0IGlzIHRyYW5zaXRpb25pbmcuXG4gICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHRoZSBjYW5jZWwgZXZlbnQgd291bGQgaGF2ZSBub3doZXJlIHRvIGJ1YmJsZSB0byBzbyB3ZSBuZWVkIHRvIGhhbmRsZSBpdCBkaXJlY3RseS5cbiAgICAgICAgICAgIGUudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uY2FuY2VsXCIsIG9uVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNpdGlvbnMuYWRkKGUucHJvcGVydHlOYW1lKTtcbiAgICB9O1xuICAgIGxldCBvblRyYW5zaXRpb25FbmQgPSAoZSk9PntcbiAgICAgICAgLy8gUmVtb3ZlIHByb3BlcnR5IGZyb20gbGlzdCBvZiB0cmFuc2l0aW9uaW5nIHByb3BlcnRpZXMuXG4gICAgICAgIGxldCBwcm9wZXJ0aWVzID0gJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25zQnlFbGVtZW50LmdldChlLnRhcmdldCk7XG4gICAgICAgIGlmICghcHJvcGVydGllcykgcmV0dXJuO1xuICAgICAgICBwcm9wZXJ0aWVzLmRlbGV0ZShlLnByb3BlcnR5TmFtZSk7XG4gICAgICAgIC8vIElmIGVtcHR5LCByZW1vdmUgdHJhbnNpdGlvbmNhbmNlbCBldmVudCwgYW5kIHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIHRoZSBsaXN0IG9mIHRyYW5zaXRpb25pbmcgZWxlbWVudHMuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIGUudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uY2FuY2VsXCIsIG9uVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgICAkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbnNCeUVsZW1lbnQuZGVsZXRlKGUudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyB0cmFuc2l0aW9uaW5nIGVsZW1lbnRzLCBjYWxsIGFsbCBvZiB0aGUgcXVldWVkIGNhbGxiYWNrcy5cbiAgICAgICAgaWYgKCRiYmVkOGI0MWY4NTdiY2MwJHZhciR0cmFuc2l0aW9uc0J5RWxlbWVudC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjYiBvZiAkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbkNhbGxiYWNrcyljYigpO1xuICAgICAgICAgICAgJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25DYWxsYmFja3MuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbnJ1blwiLCBvblRyYW5zaXRpb25TdGFydCk7XG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBvblRyYW5zaXRpb25FbmQpO1xufVxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIikgJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHNldHVwR2xvYmFsRXZlbnRzKCk7XG4gICAgZWxzZSBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAkYmJlZDhiNDFmODU3YmNjMCR2YXIkc2V0dXBHbG9iYWxFdmVudHMpO1xufVxuZnVuY3Rpb24gJGJiZWQ4YjQxZjg1N2JjYzAkZXhwb3J0JDI0NDkwMzE2Zjc2NGM0MzAoZm4pIHtcbiAgICAvLyBXYWl0IG9uZSBmcmFtZSB0byBzZWUgaWYgYW4gYW5pbWF0aW9uIHN0YXJ0cywgZS5nLiBhIHRyYW5zaXRpb24gb24gbW91bnQuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57XG4gICAgICAgIC8vIElmIG5vIHRyYW5zaXRpb25zIGFyZSBydW5uaW5nLCBjYWxsIHRoZSBmdW5jdGlvbiBpbW1lZGlhdGVseS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBhZGQgaXQgdG8gYSBsaXN0IG9mIGNhbGxiYWNrcyB0byBydW4gYXQgdGhlIGVuZCBvZiB0aGUgYW5pbWF0aW9uLlxuICAgICAgICBpZiAoJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25zQnlFbGVtZW50LnNpemUgPT09IDApIGZuKCk7XG4gICAgICAgIGVsc2UgJGJiZWQ4YjQxZjg1N2JjYzAkdmFyJHRyYW5zaXRpb25DYWxsYmFja3MuYWRkKGZuKTtcbiAgICB9KTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLyogZXNsaW50LWRpc2FibGUgcnVsZXNkaXIvcHVyZS1yZW5kZXIgKi8gXG5cbi8vIEtlZXAgdHJhY2sgb2YgZWxlbWVudHMgdGhhdCB3ZSBhcmUgY3VycmVudGx5IGhhbmRsaW5nIGRyYWdnaW5nIGZvciB2aWEgdXNlRHJhZzFELlxuLy8gSWYgdGhlcmUncyBhbiBhbmNlc3RvciBhbmQgYSBkZXNjZW5kYW50IGJvdGggdXNpbmcgdXNlRHJhZzFEKCksIGFuZCB0aGUgdXNlciBzdGFydHNcbi8vIGRyYWdnaW5nIHRoZSBkZXNjZW5kYW50LCB3ZSBkb24ndCB3YW50IHVzZURyYWcxRCBldmVudHMgdG8gZmlyZSBmb3IgdGhlIGFuY2VzdG9yLlxuY29uc3QgJDljYzA5ZGY5ZmQ3Njc2YmUkdmFyJGRyYWdnaW5nRWxlbWVudHMgPSBbXTtcbmZ1bmN0aW9uICQ5Y2MwOWRmOWZkNzY3NmJlJGV4cG9ydCQ3YmJlZDc1ZmViYTM5NzA2KHByb3BzKSB7XG4gICAgY29uc29sZS53YXJuKFwidXNlRHJhZzFEIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYHVzZU1vdmVgIGluc3RlYWQgaHR0cHM6Ly9yZWFjdC1zcGVjdHJ1bS5hZG9iZS5jb20vcmVhY3QtYXJpYS91c2VNb3ZlLmh0bWxcIik7XG4gICAgbGV0IHsgY29udGFpbmVyUmVmOiBjb250YWluZXJSZWYsIHJldmVyc2U6IHJldmVyc2UsIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvbiwgb25Ib3Zlcjogb25Ib3Zlciwgb25EcmFnOiBvbkRyYWcsIG9uUG9zaXRpb25DaGFuZ2U6IG9uUG9zaXRpb25DaGFuZ2UsIG9uSW5jcmVtZW50OiBvbkluY3JlbWVudCwgb25EZWNyZW1lbnQ6IG9uRGVjcmVtZW50LCBvbkluY3JlbWVudFRvTWF4OiBvbkluY3JlbWVudFRvTWF4LCBvbkRlY3JlbWVudFRvTWluOiBvbkRlY3JlbWVudFRvTWluLCBvbkNvbGxhcHNlVG9nZ2xlOiBvbkNvbGxhcHNlVG9nZ2xlIH0gPSBwcm9wcztcbiAgICBsZXQgZ2V0UG9zaXRpb24gPSAoZSk9Pm9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IGUuY2xpZW50WCA6IGUuY2xpZW50WTtcbiAgICBsZXQgZ2V0TmV4dE9mZnNldCA9IChlKT0+e1xuICAgICAgICBsZXQgY29udGFpbmVyT2Zmc2V0ID0gKDAsICRhYjcxZGFkYjAzYTZmYjJlJGV4cG9ydCQ2MjJjZWE0NDVhMWM1YjdkKShjb250YWluZXJSZWYuY3VycmVudCwgcmV2ZXJzZSwgb3JpZW50YXRpb24pO1xuICAgICAgICBsZXQgbW91c2VPZmZzZXQgPSBnZXRQb3NpdGlvbihlKTtcbiAgICAgICAgbGV0IG5leHRPZmZzZXQgPSByZXZlcnNlID8gY29udGFpbmVyT2Zmc2V0IC0gbW91c2VPZmZzZXQgOiBtb3VzZU9mZnNldCAtIGNvbnRhaW5lck9mZnNldDtcbiAgICAgICAgcmV0dXJuIG5leHRPZmZzZXQ7XG4gICAgfTtcbiAgICBsZXQgZHJhZ2dpbmcgPSAoMCwgJDEydUdwJHVzZVJlZikoZmFsc2UpO1xuICAgIGxldCBwcmV2UG9zaXRpb24gPSAoMCwgJDEydUdwJHVzZVJlZikoMCk7XG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBoYW5kbGVycyBpbiBhIHJlZiBzbyB0aGF0IHRoZSBldmVudHMgY2FuIGFjY2VzcyB0aGVtLlxuICAgIGxldCBoYW5kbGVycyA9ICgwLCAkMTJ1R3AkdXNlUmVmKSh7XG4gICAgICAgIG9uUG9zaXRpb25DaGFuZ2U6IG9uUG9zaXRpb25DaGFuZ2UsXG4gICAgICAgIG9uRHJhZzogb25EcmFnXG4gICAgfSk7XG4gICAgaGFuZGxlcnMuY3VycmVudC5vbkRyYWcgPSBvbkRyYWc7XG4gICAgaGFuZGxlcnMuY3VycmVudC5vblBvc2l0aW9uQ2hhbmdlID0gb25Qb3NpdGlvbkNoYW5nZTtcbiAgICBsZXQgb25Nb3VzZURyYWdnZWQgPSAoZSk9PntcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBsZXQgbmV4dE9mZnNldCA9IGdldE5leHRPZmZzZXQoZSk7XG4gICAgICAgIGlmICghZHJhZ2dpbmcuY3VycmVudCkge1xuICAgICAgICAgICAgZHJhZ2dpbmcuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcnMuY3VycmVudC5vbkRyYWcpIGhhbmRsZXJzLmN1cnJlbnQub25EcmFnKHRydWUpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXJzLmN1cnJlbnQub25Qb3NpdGlvbkNoYW5nZSkgaGFuZGxlcnMuY3VycmVudC5vblBvc2l0aW9uQ2hhbmdlKG5leHRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2UG9zaXRpb24uY3VycmVudCA9PT0gbmV4dE9mZnNldCkgcmV0dXJuO1xuICAgICAgICBwcmV2UG9zaXRpb24uY3VycmVudCA9IG5leHRPZmZzZXQ7XG4gICAgICAgIGlmIChvblBvc2l0aW9uQ2hhbmdlKSBvblBvc2l0aW9uQ2hhbmdlKG5leHRPZmZzZXQpO1xuICAgIH07XG4gICAgbGV0IG9uTW91c2VVcCA9IChlKT0+e1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgZHJhZ2dpbmcuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBsZXQgbmV4dE9mZnNldCA9IGdldE5leHRPZmZzZXQoZSk7XG4gICAgICAgIGlmIChoYW5kbGVycy5jdXJyZW50Lm9uRHJhZykgaGFuZGxlcnMuY3VycmVudC5vbkRyYWcoZmFsc2UpO1xuICAgICAgICBpZiAoaGFuZGxlcnMuY3VycmVudC5vblBvc2l0aW9uQ2hhbmdlKSBoYW5kbGVycy5jdXJyZW50Lm9uUG9zaXRpb25DaGFuZ2UobmV4dE9mZnNldCk7XG4gICAgICAgICQ5Y2MwOWRmOWZkNzY3NmJlJHZhciRkcmFnZ2luZ0VsZW1lbnRzLnNwbGljZSgkOWNjMDlkZjlmZDc2NzZiZSR2YXIkZHJhZ2dpbmdFbGVtZW50cy5pbmRleE9mKHRhcmdldCksIDEpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uTW91c2VEcmFnZ2VkLCBmYWxzZSk7XG4gICAgfTtcbiAgICBsZXQgb25Nb3VzZURvd24gPSAoZSk9PntcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAvLyBJZiB3ZSdyZSBhbHJlYWR5IGhhbmRsaW5nIGRyYWdnaW5nIG9uIGEgZGVzY2VuZGFudCB3aXRoIHVzZURyYWcxRCwgdGhlblxuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIGhhbmRsZSB0aGUgZHJhZyBtb3Rpb24gb24gdGhpcyB0YXJnZXQgYXMgd2VsbC5cbiAgICAgICAgaWYgKCQ5Y2MwOWRmOWZkNzY3NmJlJHZhciRkcmFnZ2luZ0VsZW1lbnRzLnNvbWUoKGVsdCk9PnRhcmdldC5jb250YWlucyhlbHQpKSkgcmV0dXJuO1xuICAgICAgICAkOWNjMDlkZjlmZDc2NzZiZSR2YXIkZHJhZ2dpbmdFbGVtZW50cy5wdXNoKHRhcmdldCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uTW91c2VEcmFnZ2VkLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBvbk1vdXNlVXAsIGZhbHNlKTtcbiAgICB9O1xuICAgIGxldCBvbk1vdXNlRW50ZXIgPSAoKT0+e1xuICAgICAgICBpZiAob25Ib3Zlcikgb25Ib3Zlcih0cnVlKTtcbiAgICB9O1xuICAgIGxldCBvbk1vdXNlT3V0ID0gKCk9PntcbiAgICAgICAgaWYgKG9uSG92ZXIpIG9uSG92ZXIoZmFsc2UpO1xuICAgIH07XG4gICAgbGV0IG9uS2V5RG93biA9IChlKT0+e1xuICAgICAgICBzd2l0Y2goZS5rZXkpe1xuICAgICAgICAgICAgY2FzZSBcIkxlZnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uRGVjcmVtZW50ICYmICFyZXZlcnNlKSBvbkRlY3JlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvbkluY3JlbWVudCAmJiByZXZlcnNlKSBvbkluY3JlbWVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJVcFwiOlxuICAgICAgICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkRlY3JlbWVudCAmJiAhcmV2ZXJzZSkgb25EZWNyZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob25JbmNyZW1lbnQgJiYgcmV2ZXJzZSkgb25JbmNyZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUmlnaHRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkluY3JlbWVudCAmJiAhcmV2ZXJzZSkgb25JbmNyZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob25EZWNyZW1lbnQgJiYgcmV2ZXJzZSkgb25EZWNyZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRG93blwiOlxuICAgICAgICAgICAgY2FzZSBcIkFycm93RG93blwiOlxuICAgICAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uSW5jcmVtZW50ICYmICFyZXZlcnNlKSBvbkluY3JlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvbkRlY3JlbWVudCAmJiByZXZlcnNlKSBvbkRlY3JlbWVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJIb21lXCI6XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmIChvbkRlY3JlbWVudFRvTWluKSBvbkRlY3JlbWVudFRvTWluKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRW5kXCI6XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmIChvbkluY3JlbWVudFRvTWF4KSBvbkluY3JlbWVudFRvTWF4KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRW50ZXJcIjpcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKG9uQ29sbGFwc2VUb2dnbGUpIG9uQ29sbGFwc2VUb2dnbGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb25Nb3VzZURvd246IG9uTW91c2VEb3duLFxuICAgICAgICBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlcixcbiAgICAgICAgb25Nb3VzZU91dDogb25Nb3VzZU91dCxcbiAgICAgICAgb25LZXlEb3duOiBvbktleURvd25cbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQwM2RlYjIzZmYxNDkyMGM0JGV4cG9ydCQ0ZWFmMDRlNTRhYThlZWQ2KCkge1xuICAgIGxldCBnbG9iYWxMaXN0ZW5lcnMgPSAoMCwgJDEydUdwJHVzZVJlZikobmV3IE1hcCgpKTtcbiAgICBsZXQgYWRkR2xvYmFsTGlzdGVuZXIgPSAoMCwgJDEydUdwJHVzZUNhbGxiYWNrKSgoZXZlbnRUYXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKT0+e1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgcmVtb3ZlIHRoZSBsaXN0ZW5lciBhZnRlciBpdCBpcyBjYWxsZWQgd2l0aCB0aGUgYG9uY2VgIG9wdGlvbi5cbiAgICAgICAgbGV0IGZuID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vbmNlKSA/ICguLi5hcmdzKT0+e1xuICAgICAgICAgICAgZ2xvYmFsTGlzdGVuZXJzLmN1cnJlbnQuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGxpc3RlbmVyKC4uLmFyZ3MpO1xuICAgICAgICB9IDogbGlzdGVuZXI7XG4gICAgICAgIGdsb2JhbExpc3RlbmVycy5jdXJyZW50LnNldChsaXN0ZW5lciwge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGV2ZW50VGFyZ2V0OiBldmVudFRhcmdldCxcbiAgICAgICAgICAgIGZuOiBmbixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIH0sIFtdKTtcbiAgICBsZXQgcmVtb3ZlR2xvYmFsTGlzdGVuZXIgPSAoMCwgJDEydUdwJHVzZUNhbGxiYWNrKSgoZXZlbnRUYXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKT0+e1xuICAgICAgICB2YXIgX2dsb2JhbExpc3RlbmVyc19jdXJyZW50X2dldDtcbiAgICAgICAgbGV0IGZuID0gKChfZ2xvYmFsTGlzdGVuZXJzX2N1cnJlbnRfZ2V0ID0gZ2xvYmFsTGlzdGVuZXJzLmN1cnJlbnQuZ2V0KGxpc3RlbmVyKSkgPT09IG51bGwgfHwgX2dsb2JhbExpc3RlbmVyc19jdXJyZW50X2dldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dsb2JhbExpc3RlbmVyc19jdXJyZW50X2dldC5mbikgfHwgbGlzdGVuZXI7XG4gICAgICAgIGV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnMpO1xuICAgICAgICBnbG9iYWxMaXN0ZW5lcnMuY3VycmVudC5kZWxldGUobGlzdGVuZXIpO1xuICAgIH0sIFtdKTtcbiAgICBsZXQgcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzID0gKDAsICQxMnVHcCR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgZ2xvYmFsTGlzdGVuZXJzLmN1cnJlbnQuZm9yRWFjaCgodmFsdWUsIGtleSk9PntcbiAgICAgICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyKHZhbHVlLmV2ZW50VGFyZ2V0LCB2YWx1ZS50eXBlLCBrZXksIHZhbHVlLm9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyXG4gICAgXSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycm93LWJvZHktc3R5bGVcbiAgICAoMCwgJDEydUdwJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgcmV0dXJuIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVycztcbiAgICB9LCBbXG4gICAgICAgIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVyc1xuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZEdsb2JhbExpc3RlbmVyOiBhZGRHbG9iYWxMaXN0ZW5lcixcbiAgICAgICAgcmVtb3ZlR2xvYmFsTGlzdGVuZXI6IHJlbW92ZUdsb2JhbExpc3RlbmVyLFxuICAgICAgICByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnM6IHJlbW92ZUFsbEdsb2JhbExpc3RlbmVyc1xuICAgIH07XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDMxM2I5ODg2MWVlNWRkNmMkZXhwb3J0JGQ2ODc1MTIyMTk0YzdiNDQocHJvcHMsIGRlZmF1bHRMYWJlbCkge1xuICAgIGxldCB7IGlkOiBpZCwgXCJhcmlhLWxhYmVsXCI6IGxhYmVsLCBcImFyaWEtbGFiZWxsZWRieVwiOiBsYWJlbGxlZEJ5IH0gPSBwcm9wcztcbiAgICAvLyBJZiB0aGVyZSBpcyBib3RoIGFuIGFyaWEtbGFiZWwgYW5kIGFyaWEtbGFiZWxsZWRieSxcbiAgICAvLyBjb21iaW5lIHRoZW0gYnkgcG9pbnRpbmcgdG8gdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgIGlkID0gKDAsICRiZGIxMTAxMGNlZjcwMjM2JGV4cG9ydCRmNjgwODc3YTM0NzExZTM3KShpZCk7XG4gICAgaWYgKGxhYmVsbGVkQnkgJiYgbGFiZWwpIHtcbiAgICAgICAgbGV0IGlkcyA9IG5ldyBTZXQoW1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAuLi5sYWJlbGxlZEJ5LnRyaW0oKS5zcGxpdCgvXFxzKy8pXG4gICAgICAgIF0pO1xuICAgICAgICBsYWJlbGxlZEJ5ID0gW1xuICAgICAgICAgICAgLi4uaWRzXG4gICAgICAgIF0uam9pbihcIiBcIik7XG4gICAgfSBlbHNlIGlmIChsYWJlbGxlZEJ5KSBsYWJlbGxlZEJ5ID0gbGFiZWxsZWRCeS50cmltKCkuc3BsaXQoL1xccysvKS5qb2luKFwiIFwiKTtcbiAgICAvLyBJZiBubyBsYWJlbHMgYXJlIHByb3ZpZGVkLCB1c2UgdGhlIGRlZmF1bHRcbiAgICBpZiAoIWxhYmVsICYmICFsYWJlbGxlZEJ5ICYmIGRlZmF1bHRMYWJlbCkgbGFiZWwgPSBkZWZhdWx0TGFiZWw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogbGFiZWwsXG4gICAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGxhYmVsbGVkQnlcbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICRkZjU2MTY0ZGZmNTc4NWUyJGV4cG9ydCQ0MzM4YjUzMzE1YWJmNjY2KGZvcndhcmRlZFJlZikge1xuICAgIGNvbnN0IG9ialJlZiA9ICgwLCAkMTJ1R3AkdXNlUmVmKSgpO1xuICAgIHJldHVybiAoMCwgJDEydUdwJHVzZU1lbW8pKCgpPT4oe1xuICAgICAgICAgICAgZ2V0IGN1cnJlbnQgKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmpSZWYuY3VycmVudDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgY3VycmVudCAodmFsdWUpe1xuICAgICAgICAgICAgICAgIG9ialJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3J3YXJkZWRSZWYgPT09IFwiZnVuY3Rpb25cIikgZm9yd2FyZGVkUmVmKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3J3YXJkZWRSZWYpIGZvcndhcmRlZFJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBbXG4gICAgICAgIGZvcndhcmRlZFJlZlxuICAgIF0pO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQ0ZjU4YzVmNzJiY2Y3OWY3JGV4cG9ydCQ0OTYzMTVhMTYwOGQ5NjAyKGVmZmVjdCwgZGVwZW5kZW5jaWVzKSB7XG4gICAgY29uc3QgaXNJbml0aWFsTW91bnQgPSAoMCwgJDEydUdwJHVzZVJlZikodHJ1ZSk7XG4gICAgY29uc3QgbGFzdERlcHMgPSAoMCwgJDEydUdwJHVzZVJlZikobnVsbCk7XG4gICAgKDAsICQxMnVHcCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlzSW5pdGlhbE1vdW50LmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGlzSW5pdGlhbE1vdW50LmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgKDAsICQxMnVHcCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmIChpc0luaXRpYWxNb3VudC5jdXJyZW50KSBpc0luaXRpYWxNb3VudC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYgKCFsYXN0RGVwcy5jdXJyZW50IHx8IGRlcGVuZGVuY2llcy5zb21lKChkZXAsIGkpPT4hT2JqZWN0LmlzKGRlcCwgbGFzdERlcHNbaV0pKSkgZWZmZWN0KCk7XG4gICAgICAgIGxhc3REZXBzLmN1cnJlbnQgPSBkZXBlbmRlbmNpZXM7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIGRlcGVuZGVuY2llcyk7XG59XG5cblxuXG5cbmZ1bmN0aW9uICQ5ZGFhYjAyZDQ2MTgwOWRiJHZhciRoYXNSZXNpemVPYnNlcnZlcigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdy5SZXNpemVPYnNlcnZlciAhPT0gXCJ1bmRlZmluZWRcIjtcbn1cbmZ1bmN0aW9uICQ5ZGFhYjAyZDQ2MTgwOWRiJGV4cG9ydCQ2ODM0ODBmMTkxYzBlM2VhKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHJlZjogcmVmLCBvblJlc2l6ZTogb25SZXNpemUgfSA9IG9wdGlvbnM7XG4gICAgKDAsICQxMnVHcCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGxldCBlbGVtZW50ID0gcmVmID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xuICAgICAgICBpZiAoISQ5ZGFhYjAyZDQ2MTgwOWRiJHZhciRoYXNSZXNpemVPYnNlcnZlcigpKSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBvblJlc2l6ZSwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgb25SZXNpemUsIGZhbHNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlckluc3RhbmNlID0gbmV3IHdpbmRvdy5SZXNpemVPYnNlcnZlcigoZW50cmllcyk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWVudHJpZXMubGVuZ3RoKSByZXR1cm47XG4gICAgICAgICAgICAgICAgb25SZXNpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXJJbnN0YW5jZS5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHJlc2l6ZU9ic2VydmVySW5zdGFuY2UudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgb25SZXNpemUsXG4gICAgICAgIHJlZlxuICAgIF0pO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICRlNzgwMWJlODJiNGIyYTUzJGV4cG9ydCQ0ZGViZGIxYTNmMGZhNzllKGNvbnRleHQsIHJlZikge1xuICAgICgwLCAkZjBhMDRjY2Q4ZGJkZDgzYiRleHBvcnQkZTVjNWE1ZjkxN2E1ODcxYykoKCk9PntcbiAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5yZWYgJiYgcmVmKSB7XG4gICAgICAgICAgICBjb250ZXh0LnJlZi5jdXJyZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJDYyZDhkZWQ5Mjk2ZjM4NzIkZXhwb3J0JGNmYTIyMjVlODc5Mzg3ODEobm9kZSkge1xuICAgIGlmICgkNjJkOGRlZDkyOTZmMzg3MiRleHBvcnQkMmJiNzQ3NDBjNGUxOWRlZihub2RlKSkgbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICB3aGlsZShub2RlICYmICEkNjJkOGRlZDkyOTZmMzg3MiRleHBvcnQkMmJiNzQ3NDBjNGUxOWRlZihub2RlKSlub2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIHJldHVybiBub2RlIHx8IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gJDYyZDhkZWQ5Mjk2ZjM4NzIkZXhwb3J0JDJiYjc0NzQwYzRlMTlkZWYobm9kZSkge1xuICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIHJldHVybiAvKGF1dG98c2Nyb2xsKS8udGVzdChzdHlsZS5vdmVyZmxvdyArIHN0eWxlLm92ZXJmbG93WCArIHN0eWxlLm92ZXJmbG93WSk7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG4vLyBAdHMtaWdub3JlXG5sZXQgJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0ID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy52aXN1YWxWaWV3cG9ydDtcbmZ1bmN0aW9uICQ1ZGY2NGIzODA3ZGMxNWVlJGV4cG9ydCRkNjk5OTA1ZGQ1N2M3M2NhKCkge1xuICAgIGxldCBpc1NTUiA9ICgwLCAkMTJ1R3AkdXNlSXNTU1IpKCk7XG4gICAgbGV0IFtzaXplLCBzZXRTaXplXSA9ICgwLCAkMTJ1R3AkdXNlU3RhdGUpKCgpPT5pc1NTUiA/IHtcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH0gOiAkNWRmNjRiMzgwN2RjMTVlZSR2YXIkZ2V0Vmlld3BvcnRTaXplKCkpO1xuICAgICgwLCAkMTJ1R3AkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICAvLyBVc2UgdmlzdWFsVmlld3BvcnQgYXBpIHRvIHRyYWNrIGF2YWlsYWJsZSBoZWlnaHQgZXZlbiBvbiBpT1MgdmlydHVhbCBrZXlib2FyZCBvcGVuaW5nXG4gICAgICAgIGxldCBvblJlc2l6ZSA9ICgpPT57XG4gICAgICAgICAgICBzZXRTaXplKChzaXplKT0+e1xuICAgICAgICAgICAgICAgIGxldCBuZXdTaXplID0gJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJGdldFZpZXdwb3J0U2l6ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdTaXplLndpZHRoID09PSBzaXplLndpZHRoICYmIG5ld1NpemUuaGVpZ2h0ID09PSBzaXplLmhlaWdodCkgcmV0dXJuIHNpemU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1NpemU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCEkNWRmNjRiMzgwN2RjMTVlZSR2YXIkdmlzdWFsVmlld3BvcnQpIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG9uUmVzaXplKTtcbiAgICAgICAgZWxzZSAkNWRmNjRiMzgwN2RjMTVlZSR2YXIkdmlzdWFsVmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBvblJlc2l6ZSk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgaWYgKCEkNWRmNjRiMzgwN2RjMTVlZSR2YXIkdmlzdWFsVmlld3BvcnQpIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG9uUmVzaXplKTtcbiAgICAgICAgICAgIGVsc2UgJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgb25SZXNpemUpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gc2l6ZTtcbn1cbmZ1bmN0aW9uICQ1ZGY2NGIzODA3ZGMxNWVlJHZhciRnZXRWaWV3cG9ydFNpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6ICgkNWRmNjRiMzgwN2RjMTVlZSR2YXIkdmlzdWFsVmlld3BvcnQgPT09IG51bGwgfHwgJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAkNWRmNjRiMzgwN2RjMTVlZSR2YXIkdmlzdWFsVmlld3BvcnQud2lkdGgpIHx8IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICBoZWlnaHQ6ICgkNWRmNjRiMzgwN2RjMTVlZSR2YXIkdmlzdWFsVmlld3BvcnQgPT09IG51bGwgfHwgJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAkNWRmNjRiMzgwN2RjMTVlZSR2YXIkdmlzdWFsVmlld3BvcnQuaGVpZ2h0KSB8fCB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxubGV0ICRlZjA2MjU2MDc5Njg2YmEwJHZhciRkZXNjcmlwdGlvbklkID0gMDtcbmNvbnN0ICRlZjA2MjU2MDc5Njg2YmEwJHZhciRkZXNjcmlwdGlvbk5vZGVzID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gJGVmMDYyNTYwNzk2ODZiYTAkZXhwb3J0JGY4YWVkYTdiMTA3NTNmYTEoZGVzY3JpcHRpb24pIHtcbiAgICBsZXQgW2lkLCBzZXRJZF0gPSAoMCwgJDEydUdwJHVzZVN0YXRlKSh1bmRlZmluZWQpO1xuICAgICgwLCAkZjBhMDRjY2Q4ZGJkZDgzYiRleHBvcnQkZTVjNWE1ZjkxN2E1ODcxYykoKCk9PntcbiAgICAgICAgaWYgKCFkZXNjcmlwdGlvbikgcmV0dXJuO1xuICAgICAgICBsZXQgZGVzYyA9ICRlZjA2MjU2MDc5Njg2YmEwJHZhciRkZXNjcmlwdGlvbk5vZGVzLmdldChkZXNjcmlwdGlvbik7XG4gICAgICAgIGlmICghZGVzYykge1xuICAgICAgICAgICAgbGV0IGlkID0gYHJlYWN0LWFyaWEtZGVzY3JpcHRpb24tJHskZWYwNjI1NjA3OTY4NmJhMCR2YXIkZGVzY3JpcHRpb25JZCsrfWA7XG4gICAgICAgICAgICBzZXRJZChpZCk7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBub2RlLmlkID0gaWQ7XG4gICAgICAgICAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIHJlZkNvdW50OiAwLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG5vZGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAkZWYwNjI1NjA3OTY4NmJhMCR2YXIkZGVzY3JpcHRpb25Ob2Rlcy5zZXQoZGVzY3JpcHRpb24sIGRlc2MpO1xuICAgICAgICB9IGVsc2Ugc2V0SWQoZGVzYy5lbGVtZW50LmlkKTtcbiAgICAgICAgZGVzYy5yZWZDb3VudCsrO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGlmICgtLWRlc2MucmVmQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZXNjLmVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgJGVmMDYyNTYwNzk2ODZiYTAkdmFyJGRlc2NyaXB0aW9uTm9kZXMuZGVsZXRlKGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGRlc2NyaXB0aW9uXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGRlc2NyaXB0aW9uID8gaWQgOiB1bmRlZmluZWRcbiAgICB9O1xufVxuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIxIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5mdW5jdGlvbiAkZTlmYWFmYjY0MWUxNjdkYiRleHBvcnQkOTBmYzNhMTdkOTNmNzA0YyhyZWYsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgbGV0IGhhbmRsZUV2ZW50ID0gKDAsICQ4YWUwNWVhYTVjMTE0ZTljJGV4cG9ydCQ3ZjU0ZmMzMTgwNTA4YTUyKShoYW5kbGVyKTtcbiAgICBsZXQgaXNEaXNhYmxlZCA9IGhhbmRsZXIgPT0gbnVsbDtcbiAgICAoMCwgJDEydUdwJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSByZWYuY3VycmVudDtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVFdmVudCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVFdmVudCwgb3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICByZWYsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBpc0Rpc2FibGVkLFxuICAgICAgICBoYW5kbGVFdmVudFxuICAgIF0pO1xufVxuXG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDJmMDRjYmM0NGVlMzBjZTAkZXhwb3J0JDUzYTA5MTBmMDM4MzM3YmQoc2Nyb2xsVmlldywgZWxlbWVudCkge1xuICAgIGxldCBvZmZzZXRYID0gJDJmMDRjYmM0NGVlMzBjZTAkdmFyJHJlbGF0aXZlT2Zmc2V0KHNjcm9sbFZpZXcsIGVsZW1lbnQsIFwibGVmdFwiKTtcbiAgICBsZXQgb2Zmc2V0WSA9ICQyZjA0Y2JjNDRlZTMwY2UwJHZhciRyZWxhdGl2ZU9mZnNldChzY3JvbGxWaWV3LCBlbGVtZW50LCBcInRvcFwiKTtcbiAgICBsZXQgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgIGxldCBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICBsZXQgeCA9IHNjcm9sbFZpZXcuc2Nyb2xsTGVmdDtcbiAgICBsZXQgeSA9IHNjcm9sbFZpZXcuc2Nyb2xsVG9wO1xuICAgIC8vIEFjY291bnQgZm9yIHRvcC9sZWZ0IGJvcmRlciBvZmZzZXR0aW5nIHRoZSBzY3JvbGwgdG9wL0xlZnRcbiAgICBsZXQgeyBib3JkZXJUb3BXaWR0aDogYm9yZGVyVG9wV2lkdGgsIGJvcmRlckxlZnRXaWR0aDogYm9yZGVyTGVmdFdpZHRoIH0gPSBnZXRDb21wdXRlZFN0eWxlKHNjcm9sbFZpZXcpO1xuICAgIGxldCBib3JkZXJBZGp1c3RlZFggPSBzY3JvbGxWaWV3LnNjcm9sbExlZnQgKyBwYXJzZUludChib3JkZXJMZWZ0V2lkdGgsIDEwKTtcbiAgICBsZXQgYm9yZGVyQWRqdXN0ZWRZID0gc2Nyb2xsVmlldy5zY3JvbGxUb3AgKyBwYXJzZUludChib3JkZXJUb3BXaWR0aCwgMTApO1xuICAgIC8vIElnbm9yZSBlbmQvYm90dG9tIGJvcmRlciB2aWEgY2xpZW50SGVpZ2h0L1dpZHRoIGluc3RlYWQgb2Ygb2Zmc2V0SGVpZ2h0L1dpZHRoXG4gICAgbGV0IG1heFggPSBib3JkZXJBZGp1c3RlZFggKyBzY3JvbGxWaWV3LmNsaWVudFdpZHRoO1xuICAgIGxldCBtYXhZID0gYm9yZGVyQWRqdXN0ZWRZICsgc2Nyb2xsVmlldy5jbGllbnRIZWlnaHQ7XG4gICAgaWYgKG9mZnNldFggPD0geCkgeCA9IG9mZnNldFggLSBwYXJzZUludChib3JkZXJMZWZ0V2lkdGgsIDEwKTtcbiAgICBlbHNlIGlmIChvZmZzZXRYICsgd2lkdGggPiBtYXhYKSB4ICs9IG9mZnNldFggKyB3aWR0aCAtIG1heFg7XG4gICAgaWYgKG9mZnNldFkgPD0gYm9yZGVyQWRqdXN0ZWRZKSB5ID0gb2Zmc2V0WSAtIHBhcnNlSW50KGJvcmRlclRvcFdpZHRoLCAxMCk7XG4gICAgZWxzZSBpZiAob2Zmc2V0WSArIGhlaWdodCA+IG1heFkpIHkgKz0gb2Zmc2V0WSArIGhlaWdodCAtIG1heFk7XG4gICAgc2Nyb2xsVmlldy5zY3JvbGxMZWZ0ID0geDtcbiAgICBzY3JvbGxWaWV3LnNjcm9sbFRvcCA9IHk7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBvZmZzZXQgbGVmdCBvciB0b3AgZnJvbSBjaGlsZCB0byBhbmNlc3RvciBieSBhY2N1bXVsYXRpbmdcbiAqIG9mZnNldExlZnQgb3Igb2Zmc2V0VG9wIHRocm91Z2ggaW50ZXJ2ZW5pbmcgb2Zmc2V0UGFyZW50cy5cbiAqLyBmdW5jdGlvbiAkMmYwNGNiYzQ0ZWUzMGNlMCR2YXIkcmVsYXRpdmVPZmZzZXQoYW5jZXN0b3IsIGNoaWxkLCBheGlzKSB7XG4gICAgY29uc3QgcHJvcCA9IGF4aXMgPT09IFwibGVmdFwiID8gXCJvZmZzZXRMZWZ0XCIgOiBcIm9mZnNldFRvcFwiO1xuICAgIGxldCBzdW0gPSAwO1xuICAgIHdoaWxlKGNoaWxkLm9mZnNldFBhcmVudCl7XG4gICAgICAgIHN1bSArPSBjaGlsZFtwcm9wXTtcbiAgICAgICAgaWYgKGNoaWxkLm9mZnNldFBhcmVudCA9PT0gYW5jZXN0b3IpIGJyZWFrO1xuICAgICAgICBlbHNlIGlmIChjaGlsZC5vZmZzZXRQYXJlbnQuY29udGFpbnMoYW5jZXN0b3IpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgYW5jZXN0b3IgaXMgbm90IGBwb3NpdGlvbjpyZWxhdGl2ZWAsIHRoZW4gd2Ugc3RvcCBhdFxuICAgICAgICAgICAgLy8gX2l0c18gb2Zmc2V0IHBhcmVudCwgYW5kIHdlIHN1YnRyYWN0IG9mZiBfaXRzXyBvZmZzZXQsIHNvIHRoYXRcbiAgICAgICAgICAgIC8vIHdlIGVuZCB1cCB3aXRoIHRoZSBwcm9wZXIgb2Zmc2V0IGZyb20gY2hpbGQgdG8gYW5jZXN0b3IuXG4gICAgICAgICAgICBzdW0gLT0gYW5jZXN0b3JbcHJvcF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjaGlsZCA9IGNoaWxkLm9mZnNldFBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cbmZ1bmN0aW9uICQyZjA0Y2JjNDRlZTMwY2UwJGV4cG9ydCRjODI2ODYwNzk2MzA5ZDFiKHRhcmdldEVsZW1lbnQsIG9wdHMpIHtcbiAgICBpZiAoZG9jdW1lbnQuY29udGFpbnModGFyZ2V0RWxlbWVudCkpIHtcbiAgICAgICAgbGV0IHJvb3QgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgbGV0IGlzU2Nyb2xsUHJldmVudGVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocm9vdCkub3ZlcmZsb3cgPT09IFwiaGlkZGVuXCI7XG4gICAgICAgIC8vIElmIHNjcm9sbGluZyBpcyBub3QgY3VycmVudGx5IHByZXZlbnRlZCB0aGVuIHdlIGFyZW7igJl0IGluIGEgb3ZlcmxheSBub3IgaXMgYSBvdmVybGF5IG9wZW4sIGp1c3QgdXNlIGVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcgdG8gYnJpbmcgdGhlIGVsZW1lbnQgaW50byB2aWV3XG4gICAgICAgIGlmICghaXNTY3JvbGxQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHZhciAvLyB1c2Ugc2Nyb2xsSW50b1ZpZXcoe2Jsb2NrOiAnbmVhcmVzdCd9KSBpbnN0ZWFkIG9mIC5mb2N1cyB0byBjaGVjayBpZiB0aGUgZWxlbWVudCBpcyBmdWxseSBpbiB2aWV3IG9yIG5vdCBzaW5jZSAuZm9jdXMoKVxuICAgICAgICAgICAgLy8gd29uJ3QgY2F1c2UgYSBzY3JvbGwgaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBmb2N1c2VkIGFuZCBkb2Vzbid0IGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBhbiBlbGVtZW50IGlzIHBhcnRpYWxseSBvdXQgb2YgdmlldyBob3Jpem9udGFsbHkgdnMgdmVydGljYWxseVxuICAgICAgICAgICAgX3RhcmdldEVsZW1lbnRfc2Nyb2xsSW50b1ZpZXc7XG4gICAgICAgICAgICBsZXQgeyBsZWZ0OiBvcmlnaW5hbExlZnQsIHRvcDogb3JpZ2luYWxUb3AgfSA9IHRhcmdldEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50ID09PSBudWxsIHx8IHRhcmdldEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfdGFyZ2V0RWxlbWVudF9zY3JvbGxJbnRvVmlldyA9IHRhcmdldEVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcpID09PSBudWxsIHx8IF90YXJnZXRFbGVtZW50X3Njcm9sbEludG9WaWV3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGFyZ2V0RWxlbWVudF9zY3JvbGxJbnRvVmlldy5jYWxsKHRhcmdldEVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICBibG9jazogXCJuZWFyZXN0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHsgbGVmdDogbmV3TGVmdCwgdG9wOiBuZXdUb3AgfSA9IHRhcmdldEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAvLyBBY2NvdW50IGZvciBzdWIgcGl4ZWwgZGlmZmVyZW5jZXMgZnJvbSByb3VuZGluZ1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKG9yaWdpbmFsTGVmdCAtIG5ld0xlZnQpID4gMSB8fCBNYXRoLmFicyhvcmlnaW5hbFRvcCAtIG5ld1RvcCkgPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9vcHRzX2NvbnRhaW5pbmdFbGVtZW50X3Njcm9sbEludG9WaWV3LCBfb3B0c19jb250YWluaW5nRWxlbWVudCwgX3RhcmdldEVsZW1lbnRfc2Nyb2xsSW50b1ZpZXcxO1xuICAgICAgICAgICAgICAgIG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9vcHRzX2NvbnRhaW5pbmdFbGVtZW50ID0gb3B0cy5jb250YWluaW5nRWxlbWVudCkgPT09IG51bGwgfHwgX29wdHNfY29udGFpbmluZ0VsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfb3B0c19jb250YWluaW5nRWxlbWVudF9zY3JvbGxJbnRvVmlldyA9IF9vcHRzX2NvbnRhaW5pbmdFbGVtZW50LnNjcm9sbEludG9WaWV3KSA9PT0gbnVsbCB8fCBfb3B0c19jb250YWluaW5nRWxlbWVudF9zY3JvbGxJbnRvVmlldyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdHNfY29udGFpbmluZ0VsZW1lbnRfc2Nyb2xsSW50b1ZpZXcuY2FsbChfb3B0c19jb250YWluaW5nRWxlbWVudCwge1xuICAgICAgICAgICAgICAgICAgICBibG9jazogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lOiBcImNlbnRlclwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgKF90YXJnZXRFbGVtZW50X3Njcm9sbEludG9WaWV3MSA9IHRhcmdldEVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcpID09PSBudWxsIHx8IF90YXJnZXRFbGVtZW50X3Njcm9sbEludG9WaWV3MSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RhcmdldEVsZW1lbnRfc2Nyb2xsSW50b1ZpZXcxLmNhbGwodGFyZ2V0RWxlbWVudCwge1xuICAgICAgICAgICAgICAgICAgICBibG9jazogXCJuZWFyZXN0XCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzY3JvbGxQYXJlbnQgPSAoMCwgJDYyZDhkZWQ5Mjk2ZjM4NzIkZXhwb3J0JGNmYTIyMjVlODc5Mzg3ODEpKHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgLy8gSWYgc2Nyb2xsaW5nIGlzIHByZXZlbnRlZCwgd2UgZG9uJ3Qgd2FudCB0byBzY3JvbGwgdGhlIGJvZHkgc2luY2UgaXQgbWlnaHQgbW92ZSB0aGUgb3ZlcmxheSBwYXJ0aWFsbHkgb2Zmc2NyZWVuIGFuZCB0aGUgdXNlciBjYW4ndCBzY3JvbGwgaXQgYmFjayBpbnRvIHZpZXcuXG4gICAgICAgICAgICB3aGlsZSh0YXJnZXRFbGVtZW50ICYmIHNjcm9sbFBhcmVudCAmJiB0YXJnZXRFbGVtZW50ICE9PSByb290ICYmIHNjcm9sbFBhcmVudCAhPT0gcm9vdCl7XG4gICAgICAgICAgICAgICAgJDJmMDRjYmM0NGVlMzBjZTAkZXhwb3J0JDUzYTA5MTBmMDM4MzM3YmQoc2Nyb2xsUGFyZW50LCB0YXJnZXRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50ID0gc2Nyb2xsUGFyZW50O1xuICAgICAgICAgICAgICAgIHNjcm9sbFBhcmVudCA9ICgwLCAkNjJkOGRlZDkyOTZmMzg3MiRleHBvcnQkY2ZhMjIyNWU4NzkzODc4MSkodGFyZ2V0RWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjIgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkNmE3ZGI4NTQzMjQ0OGY3ZiRleHBvcnQkNjAyNzg4NzE0NTc2MjJkZShldmVudCkge1xuICAgIC8vIEpBV1MvTlZEQSB3aXRoIEZpcmVmb3guXG4gICAgaWYgKGV2ZW50Lm1veklucHV0U291cmNlID09PSAwICYmIGV2ZW50LmlzVHJ1c3RlZCkgcmV0dXJuIHRydWU7XG4gICAgLy8gQW5kcm9pZCBUYWxrQmFjaydzIGRldGFpbCB2YWx1ZSB2YXJpZXMgZGVwZW5kaW5nIG9uIHRoZSBldmVudCBsaXN0ZW5lciBwcm92aWRpbmcgdGhlIGV2ZW50IHNvIHdlIGhhdmUgc3BlY2lmaWMgbG9naWMgaGVyZSBpbnN0ZWFkXG4gICAgLy8gSWYgcG9pbnRlclR5cGUgaXMgZGVmaW5lZCwgZXZlbnQgaXMgZnJvbSBhIGNsaWNrIGxpc3RlbmVyLiBGb3IgZXZlbnRzIGZyb20gbW91c2Vkb3duIGxpc3RlbmVyLCBkZXRhaWwgPT09IDAgaXMgYSBzdWZmaWNpZW50IGNoZWNrXG4gICAgLy8gdG8gZGV0ZWN0IFRhbGtCYWNrIHZpcnR1YWwgY2xpY2tzLlxuICAgIGlmICgoMCwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGExMWIwMDU5OTAwY2VlYzgpKCkgJiYgZXZlbnQucG9pbnRlclR5cGUpIHJldHVybiBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9ucyA9PT0gMTtcbiAgICByZXR1cm4gZXZlbnQuZGV0YWlsID09PSAwICYmICFldmVudC5wb2ludGVyVHlwZTtcbn1cbmZ1bmN0aW9uICQ2YTdkYjg1NDMyNDQ4ZjdmJGV4cG9ydCQyOWJmMWI1ZjJjNTZjZjYzKGV2ZW50KSB7XG4gICAgLy8gSWYgdGhlIHBvaW50ZXIgc2l6ZSBpcyB6ZXJvLCB0aGVuIHdlIGFzc3VtZSBpdCdzIGZyb20gYSBzY3JlZW4gcmVhZGVyLlxuICAgIC8vIEFuZHJvaWQgVGFsa0JhY2sgZG91YmxlIHRhcCB3aWxsIHNvbWV0aW1lcyByZXR1cm4gYSBldmVudCB3aXRoIHdpZHRoIGFuZCBoZWlnaHQgb2YgMVxuICAgIC8vIGFuZCBwb2ludGVyVHlwZSA9PT0gJ21vdXNlJyBzbyB3ZSBuZWVkIHRvIGNoZWNrIGZvciBhIHNwZWNpZmljIGNvbWJpbmF0aW9uIG9mIGV2ZW50IGF0dHJpYnV0ZXMuXG4gICAgLy8gQ2Fubm90IHVzZSBcImV2ZW50LnByZXNzdXJlID09PSAwXCIgYXMgdGhlIHNvbGUgY2hlY2sgZHVlIHRvIFNhZmFyaSBwb2ludGVyIGV2ZW50cyBhbHdheXMgcmV0dXJuaW5nIHByZXNzdXJlID09PSAwXG4gICAgLy8gaW5zdGVhZCBvZiAuNSwgc2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDYyMTYuIGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnIGlzIHRvIGRpc3Rpbmd1c2hcbiAgICAvLyBUYWxrYmFjayBkb3VibGUgdGFwIGZyb20gV2luZG93cyBGaXJlZm94IHRvdWNoIHNjcmVlbiBwcmVzc1xuICAgIHJldHVybiAhKDAsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRhMTFiMDA1OTkwMGNlZWM4KSgpICYmIGV2ZW50LndpZHRoID09PSAwICYmIGV2ZW50LmhlaWdodCA9PT0gMCB8fCBldmVudC53aWR0aCA9PT0gMSAmJiBldmVudC5oZWlnaHQgPT09IDEgJiYgZXZlbnQucHJlc3N1cmUgPT09IDAgJiYgZXZlbnQuZGV0YWlsID09PSAwICYmIGV2ZW50LnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCI7XG59XG5cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLyogZXNsaW50LWRpc2FibGUgcnVsZXNkaXIvcHVyZS1yZW5kZXIgKi8gXG5mdW5jdGlvbiAkNWEzODdjYzQ5MzUwZTZkYiRleHBvcnQkNzIyZGViYzBlNTZmZWEzOSh2YWx1ZSwgaXNFcXVhbCkge1xuICAgIC8vIFVzaW5nIGEgcmVmIGR1cmluZyByZW5kZXIgaXMgb2sgaGVyZSBiZWNhdXNlIGl0J3Mgb25seSBhbiBvcHRpbWl6YXRpb24g4oCTIGJvdGggdmFsdWVzIGFyZSBlcXVpdmFsZW50LlxuICAgIC8vIElmIGEgcmVuZGVyIGlzIHRocm93biBhd2F5LCBpdCdsbCBzdGlsbCB3b3JrIHRoZSBzYW1lIG5vIG1hdHRlciBpZiB0aGUgbmV4dCByZW5kZXIgaXMgdGhlIHNhbWUgb3Igbm90LlxuICAgIGxldCBsYXN0VmFsdWUgPSAoMCwgJDEydUdwJHVzZVJlZikobnVsbCk7XG4gICAgaWYgKHZhbHVlICYmIGxhc3RWYWx1ZS5jdXJyZW50ICYmIGlzRXF1YWwodmFsdWUsIGxhc3RWYWx1ZS5jdXJyZW50KSkgdmFsdWUgPSBsYXN0VmFsdWUuY3VycmVudDtcbiAgICBsYXN0VmFsdWUuY3VycmVudCA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmZ1bmN0aW9uICQ5OWZhY2FiNzMyNjZmNjYyJGV4cG9ydCQ1YWRkMWQwMDYyOTNkMTM2KHJlZiwgaW5pdGlhbFZhbHVlLCBvblJlc2V0KSB7XG4gICAgbGV0IHJlc2V0VmFsdWUgPSAoMCwgJDEydUdwJHVzZVJlZikoaW5pdGlhbFZhbHVlKTtcbiAgICBsZXQgaGFuZGxlUmVzZXQgPSAoMCwgJDhhZTA1ZWFhNWMxMTRlOWMkZXhwb3J0JDdmNTRmYzMxODA1MDhhNTIpKCgpPT57XG4gICAgICAgIGlmIChvblJlc2V0KSBvblJlc2V0KHJlc2V0VmFsdWUuY3VycmVudCk7XG4gICAgfSk7XG4gICAgKDAsICQxMnVHcCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIHZhciBfcmVmX2N1cnJlbnQ7XG4gICAgICAgIGxldCBmb3JtID0gcmVmID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9yZWZfY3VycmVudCA9IHJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfcmVmX2N1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZWZfY3VycmVudC5mb3JtO1xuICAgICAgICBmb3JtID09PSBudWxsIHx8IGZvcm0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0XCIsIGhhbmRsZVJlc2V0KTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBmb3JtID09PSBudWxsIHx8IGZvcm0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2V0XCIsIGhhbmRsZVJlc2V0KTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHJlZixcbiAgICAgICAgaGFuZGxlUmVzZXRcbiAgICBdKTtcbn1cblxuXG5cblxuZXhwb3J0IHskYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkZjY4MDg3N2EzNDcxMWUzNyBhcyB1c2VJZCwgJGJkYjExMDEwY2VmNzAyMzYkZXhwb3J0JGNkOGM5Y2I2OGY4NDI2MjkgYXMgbWVyZ2VJZHMsICRiZGIxMTAxMGNlZjcwMjM2JGV4cG9ydCRiNGNjMDljNTkyZThmZGI4IGFzIHVzZVNsb3RJZCwgJGZmNTk2M2ViMWZjY2Y1NTIkZXhwb3J0JGUwOGUzYjY3ZTM5MjEwMWUgYXMgY2hhaW4sICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRiMjA0YWYxNTgwNDJmYmFjIGFzIGdldE93bmVyRG9jdW1lbnQsICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRmMjFhMWZmYWUyNjAxNDVhIGFzIGdldE93bmVyV2luZG93LCAkM2VmNDI1NzVkZjg0YjMwYiRleHBvcnQkOWQxNjExYzc3YzJmZTkyOCBhcyBtZXJnZVByb3BzLCAkNWRjOTU4OTliMzA2ZjYzMCRleHBvcnQkYzkwNTgzMTY3NjRjMTQwZSBhcyBtZXJnZVJlZnMsICQ2NTQ4NGQwMmRjYjdlYjNlJGV4cG9ydCQ0NTdjM2Q2NTE4ZGQ0YzZmIGFzIGZpbHRlckRPTVByb3BzLCAkNzIxNWFmYzZkZTYwNmQ2YiRleHBvcnQkZGU3OWUyYzY5NWUwNTJmMyBhcyBmb2N1c1dpdGhvdXRTY3JvbGxpbmcsICRhYjcxZGFkYjAzYTZmYjJlJGV4cG9ydCQ2MjJjZWE0NDVhMWM1YjdkIGFzIGdldE9mZnNldCwgJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDk1MTg1ZDY5OWUwNWQ0ZDcgYXMgb3BlbkxpbmssICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ1MTQzN2Q1MDMzNzNkMjIzIGFzIGdldFN5bnRoZXRpY0xpbmtQcm9wcywgJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDMyM2U0ZmMyZmE0NzUzZmIgYXMgUm91dGVyUHJvdmlkZXIsICRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCRlZmE4YzkwOTllNTMwMjM1IGFzIHNob3VsZENsaWVudE5hdmlnYXRlLCAkZWE4ZGNiY2I5ZWExYjU1NiRleHBvcnQkOWEzMDJhNDVmNjVkMDU3MiBhcyB1c2VSb3V0ZXIsICRiYmVkOGI0MWY4NTdiY2MwJGV4cG9ydCQyNDQ5MDMxNmY3NjRjNDMwIGFzIHJ1bkFmdGVyVHJhbnNpdGlvbiwgJDljYzA5ZGY5ZmQ3Njc2YmUkZXhwb3J0JDdiYmVkNzVmZWJhMzk3MDYgYXMgdXNlRHJhZzFELCAkMDNkZWIyM2ZmMTQ5MjBjNCRleHBvcnQkNGVhZjA0ZTU0YWE4ZWVkNiBhcyB1c2VHbG9iYWxMaXN0ZW5lcnMsICQzMTNiOTg4NjFlZTVkZDZjJGV4cG9ydCRkNjg3NTEyMjE5NGM3YjQ0IGFzIHVzZUxhYmVscywgJGRmNTYxNjRkZmY1Nzg1ZTIkZXhwb3J0JDQzMzhiNTMzMTVhYmY2NjYgYXMgdXNlT2JqZWN0UmVmLCAkNGY1OGM1ZjcyYmNmNzlmNyRleHBvcnQkNDk2MzE1YTE2MDhkOTYwMiBhcyB1c2VVcGRhdGVFZmZlY3QsICRmMGEwNGNjZDhkYmRkODNiJGV4cG9ydCRlNWM1YTVmOTE3YTU4NzFjIGFzIHVzZUxheW91dEVmZmVjdCwgJDlkYWFiMDJkNDYxODA5ZGIkZXhwb3J0JDY4MzQ4MGYxOTFjMGUzZWEgYXMgdXNlUmVzaXplT2JzZXJ2ZXIsICRlNzgwMWJlODJiNGIyYTUzJGV4cG9ydCQ0ZGViZGIxYTNmMGZhNzllIGFzIHVzZVN5bmNSZWYsICQ2MmQ4ZGVkOTI5NmYzODcyJGV4cG9ydCRjZmEyMjI1ZTg3OTM4NzgxIGFzIGdldFNjcm9sbFBhcmVudCwgJDYyZDhkZWQ5Mjk2ZjM4NzIkZXhwb3J0JDJiYjc0NzQwYzRlMTlkZWYgYXMgaXNTY3JvbGxhYmxlLCAkNWRmNjRiMzgwN2RjMTVlZSRleHBvcnQkZDY5OTkwNWRkNTdjNzNjYSBhcyB1c2VWaWV3cG9ydFNpemUsICRlZjA2MjU2MDc5Njg2YmEwJGV4cG9ydCRmOGFlZGE3YjEwNzUzZmExIGFzIHVzZURlc2NyaXB0aW9uLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkOWFjMTAwZTQwNjEzZWExMCBhcyBpc01hYywgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDE4NmM2OTY0Y2ExN2Q5OSBhcyBpc0lQaG9uZSwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDdiZWYwNDljZTkyZTQyMjQgYXMgaXNJUGFkLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkZmVkYjM2OWNiNzAyMDdmMSBhcyBpc0lPUywgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGUxODY1YzNiZWRjZDgyMmIgYXMgaXNBcHBsZURldmljZSwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDc4NTUxMDQzNTgyYTZhOTggYXMgaXNXZWJLaXQsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ2NDQ2YTE4NmQwOWUzNzllIGFzIGlzQ2hyb21lLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkYTExYjAwNTk5MDBjZWVjOCBhcyBpc0FuZHJvaWQsICRlOWZhYWZiNjQxZTE2N2RiJGV4cG9ydCQ5MGZjM2ExN2Q5M2Y3MDRjIGFzIHVzZUV2ZW50LCAkMWRiZWNiZTI3YTA0ZjlhZiRleHBvcnQkMTRkMjM4ZjM0MjcyM2YyNSBhcyB1c2VWYWx1ZUVmZmVjdCwgJDJmMDRjYmM0NGVlMzBjZTAkZXhwb3J0JDUzYTA5MTBmMDM4MzM3YmQgYXMgc2Nyb2xsSW50b1ZpZXcsICQyZjA0Y2JjNDRlZTMwY2UwJGV4cG9ydCRjODI2ODYwNzk2MzA5ZDFiIGFzIHNjcm9sbEludG9WaWV3cG9ydCwgJDQ1MDc0NjFhMWI4NzAxMjMkcmVfZXhwb3J0JGNsYW1wIGFzIGNsYW1wLCAkNDUwNzQ2MWExYjg3MDEyMyRyZV9leHBvcnQkc25hcFZhbHVlVG9TdGVwIGFzIHNuYXBWYWx1ZVRvU3RlcCwgJDZhN2RiODU0MzI0NDhmN2YkZXhwb3J0JDYwMjc4ODcxNDU3NjIyZGUgYXMgaXNWaXJ0dWFsQ2xpY2ssICQ2YTdkYjg1NDMyNDQ4ZjdmJGV4cG9ydCQyOWJmMWI1ZjJjNTZjZjYzIGFzIGlzVmlydHVhbFBvaW50ZXJFdmVudCwgJDhhZTA1ZWFhNWMxMTRlOWMkZXhwb3J0JDdmNTRmYzMxODA1MDhhNTIgYXMgdXNlRWZmZWN0RXZlbnQsICQ1YTM4N2NjNDkzNTBlNmRiJGV4cG9ydCQ3MjJkZWJjMGU1NmZlYTM5IGFzIHVzZURlZXBNZW1vLCAkOTlmYWNhYjczMjY2ZjY2MiRleHBvcnQkNWFkZDFkMDA2MjkzZDEzNiBhcyB1c2VGb3JtUmVzZXR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbImNsYW1wIiwiJDQ1MDc0NjFhMWI4NzAxMjMkcmVfZXhwb3J0JGNsYW1wIiwic25hcFZhbHVlVG9TdGVwIiwiJDQ1MDc0NjFhMWI4NzAxMjMkcmVfZXhwb3J0JHNuYXBWYWx1ZVRvU3RlcCIsIiQxMnVHcCRyZWFjdCIsInVzZVN0YXRlIiwiJDEydUdwJHVzZVN0YXRlIiwidXNlUmVmIiwiJDEydUdwJHVzZVJlZiIsInVzZUNhbGxiYWNrIiwiJDEydUdwJHVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwiJDEydUdwJHVzZUVmZmVjdCIsImNyZWF0ZUNvbnRleHQiLCIkMTJ1R3AkY3JlYXRlQ29udGV4dCIsInVzZU1lbW8iLCIkMTJ1R3AkdXNlTWVtbyIsInVzZUNvbnRleHQiLCIkMTJ1R3AkdXNlQ29udGV4dCIsInVzZVNTUlNhZmVJZCIsIiQxMnVHcCR1c2VTU1JTYWZlSWQiLCJ1c2VJc1NTUiIsIiQxMnVHcCR1c2VJc1NTUiIsIiQxMnVHcCRjbHN4IiwiJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMiLCJkb2N1bWVudCIsInVzZUxheW91dEVmZmVjdCIsIiQ4YWUwNWVhYTVjMTE0ZTljJGV4cG9ydCQ3ZjU0ZmMzMTgwNTA4YTUyIiwiZm4iLCJyZWYiLCJjdXJyZW50IiwiYXJncyIsImYiLCIkMWRiZWNiZTI3YTA0ZjlhZiRleHBvcnQkMTRkMjM4ZjM0MjcyM2YyNSIsImRlZmF1bHRWYWx1ZSIsInZhbHVlIiwic2V0VmFsdWUiLCJlZmZlY3QiLCJuZXh0UmVmIiwibmV3VmFsdWUiLCJuZXh0IiwiZG9uZSIsInF1ZXVlIiwiJGJkYjExMDEwY2VmNzAyMzYkdmFyJGNhblVzZURPTSIsIkJvb2xlYW4iLCJ3aW5kb3ciLCJjcmVhdGVFbGVtZW50IiwiJGJkYjExMDEwY2VmNzAyMzYkdmFyJGlkc1VwZGF0ZXJNYXAiLCJNYXAiLCIkYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkZjY4MDg3N2EzNDcxMWUzNyIsImRlZmF1bHRJZCIsIm5leHRJZCIsInJlcyIsInVwZGF0ZVZhbHVlIiwidmFsIiwic2V0IiwiciIsImRlbGV0ZSIsIm5ld0lkIiwiJGJkYjExMDEwY2VmNzAyMzYkZXhwb3J0JGNkOGM5Y2I2OGY4NDI2MjkiLCJpZEEiLCJpZEIiLCJzZXRJZEEiLCJnZXQiLCJzZXRJZEIiLCIkYmRiMTEwMTBjZWY3MDIzNiRleHBvcnQkYjRjYzA5YzU5MmU4ZmRiOCIsImRlcEFycmF5IiwiaWQiLCJyZXNvbHZlZElkIiwic2V0UmVzb2x2ZWRJZCIsInVwZGF0ZUlkIiwiZ2V0RWxlbWVudEJ5SWQiLCJ1bmRlZmluZWQiLCIkZmY1OTYzZWIxZmNjZjU1MiRleHBvcnQkZTA4ZTNiNjdlMzkyMTAxZSIsImNhbGxiYWNrcyIsImNhbGxiYWNrIiwiJDQzMWZiZDg2Y2E3ZGMyMTYkZXhwb3J0JGIyMDRhZjE1ODA0MmZiYWMiLCJlbCIsIl9lbF9vd25lckRvY3VtZW50Iiwib3duZXJEb2N1bWVudCIsIiQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRmMjFhMWZmYWUyNjAxNDVhIiwiZG9jIiwiZGVmYXVsdFZpZXciLCIkM2VmNDI1NzVkZjg0YjMwYiRleHBvcnQkOWQxNjExYzc3YzJmZTkyOCIsInJlc3VsdCIsImkiLCJsZW5ndGgiLCJwcm9wcyIsImtleSIsImEiLCJiIiwiY2hhckNvZGVBdCIsIiQ1ZGM5NTg5OWIzMDZmNjMwJGV4cG9ydCRjOTA1ODMxNjc2NGMxNDBlIiwicmVmcyIsIiQ2NTQ4NGQwMmRjYjdlYjNlJHZhciRET01Qcm9wTmFtZXMiLCJTZXQiLCIkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkbGFiZWxhYmxlUHJvcE5hbWVzIiwiJDY1NDg0ZDAyZGNiN2ViM2UkdmFyJGxpbmtQcm9wTmFtZXMiLCIkNjU0ODRkMDJkY2I3ZWIzZSR2YXIkcHJvcFJlIiwiJDY1NDg0ZDAyZGNiN2ViM2UkZXhwb3J0JDQ1N2MzZDY1MThkZDRjNmYiLCJvcHRzIiwibGFiZWxhYmxlIiwiaXNMaW5rIiwicHJvcE5hbWVzIiwiZmlsdGVyZWRQcm9wcyIsInByb3AiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJoYXMiLCJ0ZXN0IiwiJDcyMTVhZmM2ZGU2MDZkNmIkZXhwb3J0JGRlNzllMmM2OTVlMDUyZjMiLCJlbGVtZW50IiwiJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbCIsImZvY3VzIiwicHJldmVudFNjcm9sbCIsInNjcm9sbGFibGVFbGVtZW50cyIsIiQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRnZXRTY3JvbGxhYmxlRWxlbWVudHMiLCIkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkcmVzdG9yZVNjcm9sbFBvc2l0aW9uIiwiJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbENhY2hlZCIsImZvY3VzRWxlbSIsImUiLCJwYXJlbnQiLCJwYXJlbnROb2RlIiwicm9vdFNjcm9sbGluZ0VsZW1lbnQiLCJzY3JvbGxpbmdFbGVtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJvZmZzZXRIZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJvZmZzZXRXaWR0aCIsInNjcm9sbFdpZHRoIiwicHVzaCIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCIkYWI3MWRhZGIwM2E2ZmIyZSRleHBvcnQkNjIyY2VhNDQ1YTFjNWI3ZCIsInJldmVyc2UiLCJvcmllbnRhdGlvbiIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJ0b3AiLCIkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFVzZXJBZ2VudCIsInJlIiwiX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YSIsIm5hdmlnYXRvciIsImJyYW5kcyIsInNvbWUiLCJicmFuZCIsInVzZXJBZ2VudCIsIiRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0UGxhdGZvcm0iLCJwbGF0Zm9ybSIsIiRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ5YWMxMDBlNDA2MTNlYTEwIiwiJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDE4NmM2OTY0Y2ExN2Q5OSIsIiRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ3YmVmMDQ5Y2U5MmU0MjI0IiwibWF4VG91Y2hQb2ludHMiLCIkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkZmVkYjM2OWNiNzAyMDdmMSIsIiRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRlMTg2NWMzYmVkY2Q4MjJiIiwiJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDc4NTUxMDQzNTgyYTZhOTgiLCIkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkNjQ0NmExODZkMDllMzc5ZSIsIiRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRhMTFiMDA1OTkwMGNlZWM4IiwiJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGI3ZDc4OTkzYjc0Zjc2NmQiLCIkZWE4ZGNiY2I5ZWExYjU1NiR2YXIkUm91dGVyQ29udGV4dCIsImlzTmF0aXZlIiwib3BlbiIsIiRlYThkY2JjYjllYTFiNTU2JHZhciRvcGVuU3ludGhldGljTGluayIsIiRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQzMjNlNGZjMmZhNDc1M2ZiIiwiY2hpbGRyZW4iLCJuYXZpZ2F0ZSIsImN0eCIsInRhcmdldCIsIm1vZGlmaWVycyIsIiRlYThkY2JjYjllYTFiNTU2JHZhciRnZXRTeW50aGV0aWNMaW5rIiwibGluayIsIiRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCRlZmE4YzkwOTllNTMwMjM1IiwicGF0aG5hbWUiLCJzZWFyY2giLCJoYXNoIiwiJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDk1MTg1ZDY5OWUwNWQ0ZDciLCJQcm92aWRlciIsIiRlYThkY2JjYjllYTFiNTU2JGV4cG9ydCQ5YTMwMmE0NWY2NWQwNTcyIiwiZ2V0QXR0cmlidXRlIiwib3JpZ2luIiwibG9jYXRpb24iLCJoYXNBdHRyaWJ1dGUiLCJtZXRhS2V5IiwiY3RybEtleSIsImFsdEtleSIsInNoaWZ0S2V5Iiwic2V0T3BlbmluZyIsIl93aW5kb3dfZXZlbnRfdHlwZSIsIl93aW5kb3dfZXZlbnQiLCJldmVudCIsInR5cGUiLCJzdGFydHNXaXRoIiwiS2V5Ym9hcmRFdmVudCIsImtleUlkZW50aWZpZXIiLCJNb3VzZUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJpc09wZW5pbmciLCJkaXNwYXRjaEV2ZW50IiwiSFRNTEFuY2hvckVsZW1lbnQiLCJocmVmIiwicmVsIiwiZG93bmxvYWQiLCJwaW5nIiwicmVmZXJyZXJQb2xpY3kiLCJhcHBlbmRDaGlsZCIsInJlbW92ZUNoaWxkIiwiJGVhOGRjYmNiOWVhMWI1NTYkZXhwb3J0JDUxNDM3ZDUwMzM3M2QyMjMiLCIkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbnNCeUVsZW1lbnQiLCIkYmJlZDhiNDFmODU3YmNjMCR2YXIkdHJhbnNpdGlvbkNhbGxiYWNrcyIsIiRiYmVkOGI0MWY4NTdiY2MwJHZhciRzZXR1cEdsb2JhbEV2ZW50cyIsIm9uVHJhbnNpdGlvblN0YXJ0IiwidHJhbnNpdGlvbnMiLCJhZGRFdmVudExpc3RlbmVyIiwib25UcmFuc2l0aW9uRW5kIiwiYWRkIiwicHJvcGVydHlOYW1lIiwicHJvcGVydGllcyIsInNpemUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2IiLCJjbGVhciIsImJvZHkiLCJyZWFkeVN0YXRlIiwiJGJiZWQ4YjQxZjg1N2JjYzAkZXhwb3J0JDI0NDkwMzE2Zjc2NGM0MzAiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCIkOWNjMDlkZjlmZDc2NzZiZSR2YXIkZHJhZ2dpbmdFbGVtZW50cyIsIiQ5Y2MwOWRmOWZkNzY3NmJlJGV4cG9ydCQ3YmJlZDc1ZmViYTM5NzA2IiwiY29uc29sZSIsIndhcm4iLCJjb250YWluZXJSZWYiLCJvbkhvdmVyIiwib25EcmFnIiwib25Qb3NpdGlvbkNoYW5nZSIsIm9uSW5jcmVtZW50Iiwib25EZWNyZW1lbnQiLCJvbkluY3JlbWVudFRvTWF4Iiwib25EZWNyZW1lbnRUb01pbiIsIm9uQ29sbGFwc2VUb2dnbGUiLCJnZXRQb3NpdGlvbiIsImNsaWVudFgiLCJjbGllbnRZIiwiZ2V0TmV4dE9mZnNldCIsImNvbnRhaW5lck9mZnNldCIsIm1vdXNlT2Zmc2V0IiwibmV4dE9mZnNldCIsImRyYWdnaW5nIiwicHJldlBvc2l0aW9uIiwiaGFuZGxlcnMiLCJvbk1vdXNlRHJhZ2dlZCIsInByZXZlbnREZWZhdWx0Iiwib25Nb3VzZVVwIiwic3BsaWNlIiwiaW5kZXhPZiIsIm9uTW91c2VEb3duIiwiY3VycmVudFRhcmdldCIsImVsdCIsImNvbnRhaW5zIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZU91dCIsIm9uS2V5RG93biIsIiQwM2RlYjIzZmYxNDkyMGM0JGV4cG9ydCQ0ZWFmMDRlNTRhYThlZWQ2IiwiZ2xvYmFsTGlzdGVuZXJzIiwiYWRkR2xvYmFsTGlzdGVuZXIiLCJldmVudFRhcmdldCIsImxpc3RlbmVyIiwib3B0aW9ucyIsIm9uY2UiLCJyZW1vdmVHbG9iYWxMaXN0ZW5lciIsIl9nbG9iYWxMaXN0ZW5lcnNfY3VycmVudF9nZXQiLCJyZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMiLCJmb3JFYWNoIiwiJDMxM2I5ODg2MWVlNWRkNmMkZXhwb3J0JGQ2ODc1MTIyMTk0YzdiNDQiLCJkZWZhdWx0TGFiZWwiLCJsYWJlbCIsImxhYmVsbGVkQnkiLCJpZHMiLCJ0cmltIiwic3BsaXQiLCJqb2luIiwiJGRmNTYxNjRkZmY1Nzg1ZTIkZXhwb3J0JDQzMzhiNTMzMTVhYmY2NjYiLCJmb3J3YXJkZWRSZWYiLCJvYmpSZWYiLCIkNGY1OGM1ZjcyYmNmNzlmNyRleHBvcnQkNDk2MzE1YTE2MDhkOTYwMiIsImRlcGVuZGVuY2llcyIsImlzSW5pdGlhbE1vdW50IiwibGFzdERlcHMiLCJkZXAiLCJpcyIsIiQ5ZGFhYjAyZDQ2MTgwOWRiJHZhciRoYXNSZXNpemVPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwiJDlkYWFiMDJkNDYxODA5ZGIkZXhwb3J0JDY4MzQ4MGYxOTFjMGUzZWEiLCJvblJlc2l6ZSIsInJlc2l6ZU9ic2VydmVySW5zdGFuY2UiLCJlbnRyaWVzIiwib2JzZXJ2ZSIsInVub2JzZXJ2ZSIsIiRlNzgwMWJlODJiNGIyYTUzJGV4cG9ydCQ0ZGViZGIxYTNmMGZhNzllIiwiY29udGV4dCIsIiQ2MmQ4ZGVkOTI5NmYzODcyJGV4cG9ydCRjZmEyMjI1ZTg3OTM4NzgxIiwibm9kZSIsIiQ2MmQ4ZGVkOTI5NmYzODcyJGV4cG9ydCQyYmI3NDc0MGM0ZTE5ZGVmIiwicGFyZW50RWxlbWVudCIsInN0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwiJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJHZpc3VhbFZpZXdwb3J0IiwidmlzdWFsVmlld3BvcnQiLCIkNWRmNjRiMzgwN2RjMTVlZSRleHBvcnQkZDY5OTkwNWRkNTdjNzNjYSIsImlzU1NSIiwic2V0U2l6ZSIsIndpZHRoIiwiaGVpZ2h0IiwiJDVkZjY0YjM4MDdkYzE1ZWUkdmFyJGdldFZpZXdwb3J0U2l6ZSIsIm5ld1NpemUiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCIkZWYwNjI1NjA3OTY4NmJhMCR2YXIkZGVzY3JpcHRpb25JZCIsIiRlZjA2MjU2MDc5Njg2YmEwJHZhciRkZXNjcmlwdGlvbk5vZGVzIiwiJGVmMDYyNTYwNzk2ODZiYTAkZXhwb3J0JGY4YWVkYTdiMTA3NTNmYTEiLCJkZXNjcmlwdGlvbiIsInNldElkIiwiZGVzYyIsImRpc3BsYXkiLCJ0ZXh0Q29udGVudCIsInJlZkNvdW50IiwicmVtb3ZlIiwiJGU5ZmFhZmI2NDFlMTY3ZGIkZXhwb3J0JDkwZmMzYTE3ZDkzZjcwNGMiLCJoYW5kbGVyIiwiaGFuZGxlRXZlbnQiLCJpc0Rpc2FibGVkIiwiJDJmMDRjYmM0NGVlMzBjZTAkZXhwb3J0JDUzYTA5MTBmMDM4MzM3YmQiLCJzY3JvbGxWaWV3Iiwib2Zmc2V0WCIsIiQyZjA0Y2JjNDRlZTMwY2UwJHZhciRyZWxhdGl2ZU9mZnNldCIsIm9mZnNldFkiLCJ4IiwieSIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyTGVmdFdpZHRoIiwiYm9yZGVyQWRqdXN0ZWRYIiwicGFyc2VJbnQiLCJib3JkZXJBZGp1c3RlZFkiLCJtYXhYIiwiY2xpZW50V2lkdGgiLCJtYXhZIiwiY2xpZW50SGVpZ2h0IiwiYW5jZXN0b3IiLCJjaGlsZCIsImF4aXMiLCJzdW0iLCJvZmZzZXRQYXJlbnQiLCIkMmYwNGNiYzQ0ZWUzMGNlMCRleHBvcnQkYzgyNjg2MDc5NjMwOWQxYiIsInRhcmdldEVsZW1lbnQiLCJyb290IiwiaXNTY3JvbGxQcmV2ZW50ZWQiLCJfdGFyZ2V0RWxlbWVudF9zY3JvbGxJbnRvVmlldyIsIm9yaWdpbmFsTGVmdCIsIm9yaWdpbmFsVG9wIiwic2Nyb2xsSW50b1ZpZXciLCJibG9jayIsIm5ld0xlZnQiLCJuZXdUb3AiLCJNYXRoIiwiYWJzIiwiX29wdHNfY29udGFpbmluZ0VsZW1lbnRfc2Nyb2xsSW50b1ZpZXciLCJfb3B0c19jb250YWluaW5nRWxlbWVudCIsIl90YXJnZXRFbGVtZW50X3Njcm9sbEludG9WaWV3MSIsImNvbnRhaW5pbmdFbGVtZW50IiwiaW5saW5lIiwic2Nyb2xsUGFyZW50IiwiJDZhN2RiODU0MzI0NDhmN2YkZXhwb3J0JDYwMjc4ODcxNDU3NjIyZGUiLCJtb3pJbnB1dFNvdXJjZSIsImlzVHJ1c3RlZCIsInBvaW50ZXJUeXBlIiwiYnV0dG9ucyIsImRldGFpbCIsIiQ2YTdkYjg1NDMyNDQ4ZjdmJGV4cG9ydCQyOWJmMWI1ZjJjNTZjZjYzIiwicHJlc3N1cmUiLCIkNWEzODdjYzQ5MzUwZTZkYiRleHBvcnQkNzIyZGViYzBlNTZmZWEzOSIsImlzRXF1YWwiLCJsYXN0VmFsdWUiLCIkOTlmYWNhYjczMjY2ZjY2MiRleHBvcnQkNWFkZDFkMDA2MjkzZDEzNiIsImluaXRpYWxWYWx1ZSIsIm9uUmVzZXQiLCJyZXNldFZhbHVlIiwiaGFuZGxlUmVzZXQiLCJfcmVmX2N1cnJlbnQiLCJmb3JtIiwidXNlSWQiLCJtZXJnZUlkcyIsInVzZVNsb3RJZCIsImNoYWluIiwiZ2V0T3duZXJEb2N1bWVudCIsImdldE93bmVyV2luZG93IiwibWVyZ2VQcm9wcyIsIm1lcmdlUmVmcyIsImZpbHRlckRPTVByb3BzIiwiZm9jdXNXaXRob3V0U2Nyb2xsaW5nIiwiZ2V0T2Zmc2V0Iiwib3BlbkxpbmsiLCJnZXRTeW50aGV0aWNMaW5rUHJvcHMiLCJSb3V0ZXJQcm92aWRlciIsInNob3VsZENsaWVudE5hdmlnYXRlIiwidXNlUm91dGVyIiwicnVuQWZ0ZXJUcmFuc2l0aW9uIiwidXNlRHJhZzFEIiwidXNlR2xvYmFsTGlzdGVuZXJzIiwidXNlTGFiZWxzIiwidXNlT2JqZWN0UmVmIiwidXNlVXBkYXRlRWZmZWN0IiwidXNlUmVzaXplT2JzZXJ2ZXIiLCJ1c2VTeW5jUmVmIiwiZ2V0U2Nyb2xsUGFyZW50IiwiaXNTY3JvbGxhYmxlIiwidXNlVmlld3BvcnRTaXplIiwidXNlRGVzY3JpcHRpb24iLCJpc01hYyIsImlzSVBob25lIiwiaXNJUGFkIiwiaXNJT1MiLCJpc0FwcGxlRGV2aWNlIiwiaXNXZWJLaXQiLCJpc0Nocm9tZSIsImlzQW5kcm9pZCIsInVzZUV2ZW50IiwidXNlVmFsdWVFZmZlY3QiLCJzY3JvbGxJbnRvVmlld3BvcnQiLCJpc1ZpcnR1YWxDbGljayIsImlzVmlydHVhbFBvaW50ZXJFdmVudCIsInVzZUVmZmVjdEV2ZW50IiwidXNlRGVlcE1lbW8iLCJ1c2VGb3JtUmVzZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-aria/utils/dist/import.mjs\n");

/***/ })

};
;